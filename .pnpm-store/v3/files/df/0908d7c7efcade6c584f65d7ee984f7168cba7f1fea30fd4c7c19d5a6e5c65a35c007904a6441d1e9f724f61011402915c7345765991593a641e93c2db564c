var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CryptoUtils } from '@web5/crypto';
import { createJsonRpcRequest } from './prototyping/clients/json-rpc.js';
import { HttpDwnRpcClient } from './prototyping/clients/http-dwn-rpc-client.js';
import { WebSocketDwnRpcClient } from './prototyping/clients/web-socket-clients.js';
export var DidRpcMethod;
(function (DidRpcMethod) {
    DidRpcMethod["Create"] = "did.create";
    DidRpcMethod["Resolve"] = "did.resolve";
})(DidRpcMethod || (DidRpcMethod = {}));
/**
 * Client used to communicate with Dwn Servers
 */
export class Web5RpcClient {
    constructor(clients = []) {
        this.transportClients = new Map();
        // include http and socket clients as default.
        // can be overwritten for 'http:', 'https:', 'ws: or ':wss' if instantiated with other clients.
        clients = [new HttpWeb5RpcClient(), new WebSocketWeb5RpcClient(), ...clients];
        for (let client of clients) {
            for (let transportScheme of client.transportProtocols) {
                this.transportClients.set(transportScheme, client);
            }
        }
    }
    get transportProtocols() {
        return Array.from(this.transportClients.keys());
    }
    sendDidRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            // URL() will throw if provided `url` is invalid.
            const url = new URL(request.url);
            const transportClient = this.transportClients.get(url.protocol);
            if (!transportClient) {
                const error = new Error(`no ${url.protocol} transport client available`);
                error.name = 'NO_TRANSPORT_CLIENT';
                throw error;
            }
            return transportClient.sendDidRequest(request);
        });
    }
    sendDwnRequest(request) {
        // will throw if url is invalid
        const url = new URL(request.dwnUrl);
        const transportClient = this.transportClients.get(url.protocol);
        if (!transportClient) {
            const error = new Error(`no ${url.protocol} transport client available`);
            error.name = 'NO_TRANSPORT_CLIENT';
            throw error;
        }
        return transportClient.sendDwnRequest(request);
    }
    getServerInfo(dwnUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            // will throw if url is invalid
            const url = new URL(dwnUrl);
            const transportClient = this.transportClients.get(url.protocol);
            if (!transportClient) {
                const error = new Error(`no ${url.protocol} transport client available`);
                error.name = 'NO_TRANSPORT_CLIENT';
                throw error;
            }
            return transportClient.getServerInfo(dwnUrl);
        });
    }
}
export class HttpWeb5RpcClient extends HttpDwnRpcClient {
    sendDidRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = CryptoUtils.randomUuid();
            const jsonRpcRequest = createJsonRpcRequest(requestId, request.method, {
                data: request.data
            });
            const httpRequest = new Request(request.url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(jsonRpcRequest),
            });
            let jsonRpcResponse;
            try {
                const response = yield fetch(httpRequest);
                if (response.ok) {
                    jsonRpcResponse = yield response.json();
                    // If the response is an error, throw an error.
                    if (jsonRpcResponse.error) {
                        const { code, message } = jsonRpcResponse.error;
                        throw new Error(`JSON RPC (${code}) - ${message}`);
                    }
                }
                else {
                    throw new Error(`HTTP (${response.status}) - ${response.statusText}`);
                }
            }
            catch (error) {
                throw new Error(`Error encountered while processing response from ${request.url}: ${error.message}`);
            }
            return jsonRpcResponse.result;
        });
    }
}
export class WebSocketWeb5RpcClient extends WebSocketDwnRpcClient {
    sendDidRequest(_request) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(`not implemented for transports [${this.transportProtocols.join(', ')}]`);
        });
    }
    getServerInfo(_dwnUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(`not implemented for transports [${this.transportProtocols.join(', ')}]`);
        });
    }
}
//# sourceMappingURL=rpc-client.js.map