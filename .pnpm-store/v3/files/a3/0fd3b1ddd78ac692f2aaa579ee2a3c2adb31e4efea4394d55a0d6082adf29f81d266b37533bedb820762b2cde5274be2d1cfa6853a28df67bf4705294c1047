var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CryptoUtils } from '@web5/crypto';
import { Jwt } from './jwt.js';
import { SsiValidator } from './validators.js';
import { VerifiableCredential, DEFAULT_VC_CONTEXT } from './verifiable-credential.js';
/** The default type for a Verifiable Presentation. */
export const DEFAULT_VP_TYPE = 'VerifiablePresentation';
/**
 * `VerifiablePresentation` is a tamper-evident presentation encoded in such a way that authorship of the data
 * can be trusted after a process of cryptographic verification.
 * [W3C Verifiable Presentation Data Model](https://www.w3.org/TR/vc-data-model/#presentations).
 *
 * It provides functionalities to sign, verify, and create presentations, offering a concise API to
 * work with JWT representations of verifiable presentations and ensuring that the signatures
 * and claims within those JWTs can be validated.
 *
 * @property vpDataModel The [vpDataModel] instance representing the core data model of a verifiable presentation.
 */
export class VerifiablePresentation {
    constructor(vpDataModel) {
        this.vpDataModel = vpDataModel;
    }
    /** The type of the Verifiable Presentation. */
    get type() {
        return this.vpDataModel.type[this.vpDataModel.type.length - 1];
    }
    /** The holder of the Verifiable Presentation. */
    get holder() {
        return this.vpDataModel.holder.toString();
    }
    /** The verifiable credentials contained in the Verifiable Presentation. */
    get verifiableCredential() {
        return this.vpDataModel.verifiableCredential;
    }
    /**
     * Signs the verifiable presentation and returns it as a signed JWT.
     *
     * @example
     * ```ts
     * const vpJwt = verifiablePresentation.sign({ did: myDid });
     * ```
     *
     * @param options - The sign options used to sign the presentation.
     * @returns The JWT representing the signed verifiable presentation.
     */
    sign(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const vpJwt = yield Jwt.sign({
                signerDid: options.did,
                payload: {
                    vp: this.vpDataModel,
                    iss: options.did.uri,
                    sub: options.did.uri,
                    jti: this.vpDataModel.id,
                    iat: Math.floor(Date.now() / 1000)
                }
            });
            return vpJwt;
        });
    }
    /**
     * Converts the current object to its JSON representation.
     *
     * @returns The JSON representation of the object.
     */
    toString() {
        return JSON.stringify(this.vpDataModel);
    }
    /**
     * Create a [VerifiablePresentation] based on the provided parameters.
     *
     * @example
     * ```ts
     * const vp = await VerifiablePresentation.create({
     *     type: 'PresentationSubmission',
     *     holder: 'did:ex:holder',
     *     vcJwts: vcJwts,
     *     additionalData: { 'arbitrary': 'data' }
     *   })
     * ```
     *
     * @param options - The options to use when creating the Verifiable Presentation.
     * @returns A [VerifiablePresentation] instance.
     */
    static create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type, holder, vcJwts, additionalData } = options;
            if (additionalData) {
                const jsonData = JSON.parse(JSON.stringify(additionalData));
                if (typeof jsonData !== 'object') {
                    throw new Error('Expected data to be parseable into a JSON object');
                }
            }
            if (!holder) {
                throw new Error('Holder must be defined');
            }
            if (typeof holder !== 'string') {
                throw new Error('Holder must be of type string');
            }
            const vpDataModel = Object.assign({ '@context': [DEFAULT_VC_CONTEXT], type: Array.isArray(type)
                    ? [DEFAULT_VP_TYPE, ...type]
                    : (type ? [DEFAULT_VP_TYPE, type] : [DEFAULT_VP_TYPE]), id: `urn:uuid:${CryptoUtils.randomUuid()}`, holder: holder, verifiableCredential: vcJwts }, additionalData);
            validatePayload(vpDataModel);
            return new VerifiablePresentation(vpDataModel);
        });
    }
    /**
     * Verifies the integrity and authenticity of a Verifiable Presentation (VP) encoded as a JSON Web Token (JWT).
     *
     * This function performs several crucial validation steps to ensure the trustworthiness of the provided VP:
     * - Parses and validates the structure of the JWT.
     * - Ensures the presence of critical header elements `alg` and `kid` in the JWT header.
     * - Resolves the Decentralized Identifier (DID) and retrieves the associated DID Document.
     * - Validates the DID and establishes a set of valid verification method IDs.
     * - Identifies the correct Verification Method from the DID Document based on the `kid` parameter.
     * - Verifies the JWT's signature using the public key associated with the Verification Method.
     *
     * If any of these steps fail, the function will throw a [Error] with a message indicating the nature of the failure.
     *
     * @example
     * ```ts
     * try {
     *     VerifiablePresentation.verify({ vpJwt: signedVpJwt })
     *     console.log("VC Verification successful!")
     * } catch (e: Error) {
     *     console.log("VC Verification failed: ${e.message}")
     * }
     * ```
     *
     * @param vpJwt The Verifiable Presentation in JWT format as a [string].
     * @throws Error if the verification fails at any step, providing a message with failure details.
     * @throws Error if critical JWT header elements are absent.
     */
    static verify(_a) {
        return __awaiter(this, arguments, void 0, function* ({ vpJwt }) {
            const { payload } = yield Jwt.verify({ jwt: vpJwt });
            const vp = payload['vp'];
            if (!vp) {
                throw new Error('vp property missing.');
            }
            validatePayload(vp);
            for (const vcJwt of vp.verifiableCredential) {
                yield VerifiableCredential.verify({ vcJwt: vcJwt });
            }
            return {
                /** The issuer of the VP */
                issuer: payload.iss,
                /** The subject of the VP. */
                subject: payload.sub,
                /** The VP data model object. */
                vp: payload['vp']
            };
        });
    }
    /**
     * Parses a JWT into a [VerifiablePresentation] instance.
     *
     * @example
     * ```ts
     * const vp = VerifiablePresentation.parseJwt({ vpJwt: signedVpJwt })
     * ```
     *
     * @param vpJwt The verifiable presentation JWT as a [String].
     * @returns A [VerifiablePresentation] instance derived from the JWT.
     */
    static parseJwt({ vpJwt }) {
        const parsedJwt = Jwt.parse({ jwt: vpJwt });
        const vpDataModel = parsedJwt.decoded.payload['vp'];
        if (!vpDataModel) {
            throw Error('Jwt payload missing vp property');
        }
        return new VerifiablePresentation(vpDataModel);
    }
}
/**
 * Validates the structure and integrity of a Verifiable Presentation payload.
 *
 * @param vp - The Verifiable Presentaation object to validate.
 * @throws Error if any validation check fails.
 */
function validatePayload(vp) {
    SsiValidator.validateContext(vp['@context']);
    SsiValidator.validateVpType(vp.type);
}
//# sourceMappingURL=verifiable-presentation.js.map