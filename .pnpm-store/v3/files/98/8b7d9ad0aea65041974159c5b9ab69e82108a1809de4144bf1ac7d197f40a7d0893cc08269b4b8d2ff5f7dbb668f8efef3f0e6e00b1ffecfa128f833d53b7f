import type { DerivedPrivateJwk } from './hd-key.js';
import type { Readable } from 'readable-stream';
import type { Filter, KeyValues, StartsWithFilter } from '../types/query-types.js';
import type { GenericMessage, GenericSignaturePayload } from '../types/message-types.js';
import type { RecordsDeleteMessage, RecordsFilter, RecordsQueryMessage, RecordsReadMessage, RecordsSubscribeMessage, RecordsWriteDescriptor, RecordsWriteMessage, RecordsWriteTags, RecordsWriteTagsFilter } from '../types/records-types.js';
import { DateSort } from '../types/records-types.js';
import { KeyDerivationScheme } from './hd-key.js';
/**
 * Class containing useful utilities related to the Records interface.
 */
export declare class Records {
    /**
     * Checks if the given message is a `RecordsWriteMessage`.
     */
    static isRecordsWrite(message: GenericMessage): message is RecordsWriteMessage;
    /**
     * Gets the DID of the author of the given message.
     */
    static getAuthor(message: RecordsWriteMessage | RecordsDeleteMessage): string | undefined;
    /**
     * Decrypts the encrypted data in a message reply using the given ancestor private key.
     * @param ancestorPrivateKey Any ancestor private key in the key derivation path.
     */
    static decrypt(recordsWrite: RecordsWriteMessage, ancestorPrivateKey: DerivedPrivateJwk, cipherStream: Readable): Promise<Readable>;
    /**
     * Constructs full key derivation path using the specified scheme.
     */
    static constructKeyDerivationPath(keyDerivationScheme: KeyDerivationScheme, recordsWriteMessage: RecordsWriteMessage): string[];
    /**
     * Constructs the full key derivation path using `dataFormats` scheme.
     */
    static constructKeyDerivationPathUsingDataFormatsScheme(schema: string | undefined, dataFormat: string): string[];
    /**
     * Constructs the full key derivation path using `protocolPath` scheme.
     */
    static constructKeyDerivationPathUsingProtocolPathScheme(descriptor: RecordsWriteDescriptor): string[];
    /**
     * Constructs the full key derivation path using `protocolContext` scheme.
     */
    static constructKeyDerivationPathUsingProtocolContextScheme(contextId: string | undefined): string[];
    /**
     * Constructs the full key derivation path using `schemas` scheme.
     */
    static constructKeyDerivationPathUsingSchemasScheme(schema: string | undefined): string[];
    /**
     * Derives a descendant private key given an ancestor private key and the full absolute derivation path.
     * NOTE: right now only `ECIES-ES256K` algorithm is supported for asymmetric encryption,
     *       so we will only derive SECP256K1 key without additional conditional checks
     */
    static derivePrivateKey(ancestorPrivateKey: DerivedPrivateJwk, fullDescendantDerivationPath: string[]): Promise<Uint8Array>;
    /**
     * Validates that ancestor derivation path matches the descendant derivation path completely.
     * @throws {DwnError} with `DwnErrorCode.RecordsInvalidAncestorKeyDerivationSegment` if fails validation.
     */
    static validateAncestorKeyAndDescentKeyDerivationPathsMatch(ancestorKeyDerivationPath: string[], descendantKeyDerivationPath: string[]): void;
    /**
     * Extracts the parent context ID from the given context ID.
     */
    static getParentContextFromOfContextId(contextId: string | undefined): string | undefined;
    /**
     * Normalizes the protocol and schema URLs within a provided RecordsFilter and returns a copy of RecordsFilter with the modified values.
     *
     * @param filter incoming RecordsFilter to normalize.
     * @returns {RecordsFilter} a copy of the incoming RecordsFilter with the normalized properties.
     */
    static normalizeFilter(filter: RecordsFilter): RecordsFilter;
    static isStartsWithFilter(filter: RecordsWriteTagsFilter): filter is StartsWithFilter;
    /**
     * This will create individual keys for each of the tags that look like `tag.tag_property`
     */
    static buildTagIndexes(tags: RecordsWriteTags): KeyValues;
    /**
     * This will create individual keys for each of the tag filters that look like `tag.tag_filter_property`
     */
    static convertTagsFilter(tags: {
        [property: string]: RecordsWriteTagsFilter;
    }): Filter;
    /**
     *  Converts an incoming RecordsFilter into a Filter usable by MessageStore.
     *
     * @param filter A RecordsFilter
     * @returns {Filter} a generic Filter able to be used with MessageStore.
     */
    static convertFilter(filter: RecordsFilter, dateSort?: DateSort): Filter;
    /**
     * Validates the referential integrity of both author-delegated grant and owner-delegated grant.
     * @param authorSignaturePayload Decoded payload of the author signature of the message. Pass `undefined` if message is not signed.
     *                               Passed purely as a performance optimization so we don't have to decode the signature payload again.
     * @param ownerSignaturePayload Decoded payload of the owner signature of the message. Pass `undefined` if no owner signature is present.
     *                              Passed purely as a performance optimization so we don't have to decode the owner signature payload again.
     */
    static validateDelegatedGrantReferentialIntegrity(message: RecordsReadMessage | RecordsQueryMessage | RecordsWriteMessage | RecordsDeleteMessage | RecordsSubscribeMessage, authorSignaturePayload: GenericSignaturePayload | undefined, ownerSignaturePayload?: GenericSignaturePayload | undefined): Promise<void>;
    /**
     * Determines if signature payload contains a protocolRole and should be authorized as such.
     */
    static shouldProtocolAuthorize(signaturePayload: GenericSignaturePayload): boolean;
    /**
     * Checks if the filter supports returning published records.
     */
    static filterIncludesPublishedRecords(filter: RecordsFilter): boolean;
    /**
     * Checks if the filter supports returning unpublished records.
     */
    static filterIncludesUnpublishedRecords(filter: RecordsFilter): boolean;
    /**
     * Checks if the given RecordsDelete message can be performed against a record with the given newest existing state.
     */
    static canPerformDeleteAgainstRecord(deleteToBePerformed: RecordsDeleteMessage, newestExistingMessage: GenericMessage | undefined): boolean;
    /**
     * Checks whether or not the incoming records query filter should build an unpublished recipient MessageStore filter.
     *
     * @param filter The incoming RecordsFilter to evaluate against.
     * @param recipient The recipient to check against the filter, typically the query/subscribe message author.
     * @returns {boolean} True if the filter contains the recipient, or if the recipient filter is undefined/empty.
     */
    static shouldBuildUnpublishedRecipientFilter(filter: RecordsFilter, recipient: string): boolean;
    /**
     * Checks whether or not the incoming records query filter should build an unpublished author MessageStore filter.
     *
     * @param filter The incoming RecordsFilter to evaluate against.
     * @param author The author to check against the filter, typically the query/subscribe message author.
     * @returns {boolean} True if the filter contains the author, or if the author filter is undefined/empty.
     */
    static shouldBuildUnpublishedAuthorFilter(filter: RecordsFilter, author: string): boolean;
}
//# sourceMappingURL=records.d.ts.map