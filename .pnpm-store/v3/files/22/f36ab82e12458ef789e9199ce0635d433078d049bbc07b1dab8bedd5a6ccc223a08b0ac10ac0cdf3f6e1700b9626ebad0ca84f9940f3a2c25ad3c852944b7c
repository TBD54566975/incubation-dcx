import type { DidDocument, DidMetadata, PortableDid, DidMethodApi, DidDhtCreateOptions, DidJwkCreateOptions, DidResolutionResult, DidResolutionOptions, DidVerificationMethod, DidResolverCache } from '@web5/dids';
import { BearerDid, UniversalResolver } from '@web5/dids';
import type { AgentDataStore } from './store-data.js';
import type { AgentKeyManager } from './types/key-manager.js';
import type { ResponseStatus, Web5PlatformAgent } from './types/agent.js';
export declare enum DidInterface {
    Create = "Create",
    Resolve = "Resolve"
}
export interface DidMessageParams {
    [DidInterface.Create]: DidCreateParams;
    [DidInterface.Resolve]: DidResolveParams;
}
export interface DidMessageResult {
    [DidInterface.Create]: DidCreateResult;
    [DidInterface.Resolve]: DidResolveResult;
}
export type DidCreateResult = {
    uri: string;
    document: DidDocument;
    metadata: DidMetadata;
};
export type DidResolveResult = DidResolutionResult;
export type DidRequest<T extends DidInterface> = {
    messageType: T;
    messageParams: DidMessageParams[T];
};
export type DidResolveParams = {
    didUri: string;
    options?: DidResolutionOptions;
};
export type DidResponse<T extends DidInterface> = ResponseStatus & {
    result?: DidMessageResult[T];
};
export interface DidCreateParams<TKeyManager = AgentKeyManager, TMethod extends keyof DidMethodCreateOptions<TKeyManager> = keyof DidMethodCreateOptions<TKeyManager>> {
    method: TMethod;
    options?: DidMethodCreateOptions<TKeyManager>[TMethod];
    store?: boolean;
    tenant?: string;
}
export interface DidMethodCreateOptions<TKeyManager> {
    dht: DidDhtCreateOptions<TKeyManager>;
    jwk: DidJwkCreateOptions<TKeyManager>;
}
export interface DidApiParams {
    didMethods: DidMethodApi[];
    agent?: Web5PlatformAgent;
    /**
     * An optional `DidResolverCache` instance used for caching resolved DID documents.
     *
     * Providing a cache implementation can significantly enhance resolution performance by avoiding
     * redundant resolutions for previously resolved DIDs. If omitted, the default is an instance of `AgentDidResolverCache`.
     *
     * `AgentDidResolverCache` keeps a stale copy of the Agent's managed Identity DIDs and only refreshes upon a successful resolution.
     * This allows for quick and offline access to the internal DIDs used by the agent.
     */
    resolverCache?: DidResolverCache;
    store?: AgentDataStore<PortableDid>;
}
export declare function isDidRequest<T extends DidInterface>(didRequest: DidRequest<DidInterface>, messageType: T): didRequest is DidRequest<T>;
export declare class AgentDidApi<TKeyManager extends AgentKeyManager = AgentKeyManager> extends UniversalResolver {
    /**
     * Holds the instance of a `Web5PlatformAgent` that represents the current execution context for
     * the `AgentDidApi`. This agent is used to interact with other Web5 agent components. It's vital
     * to ensure this instance is set to correctly contextualize operations within the broader Web5
     * Agent framework.
     */
    private _agent?;
    private _didMethods;
    private _store;
    constructor({ agent, didMethods, resolverCache, store }: DidApiParams);
    /**
     * Retrieves the `Web5PlatformAgent` execution context.
     *
     * @returns The `Web5PlatformAgent` instance that represents the current execution context.
     * @throws Will throw an error if the `agent` instance property is undefined.
     */
    get agent(): Web5PlatformAgent;
    set agent(agent: Web5PlatformAgent);
    create({ method, tenant, options, store }: DidCreateParams<TKeyManager>): Promise<BearerDid>;
    export({ didUri, tenant }: {
        didUri: string;
        tenant?: string;
    }): Promise<PortableDid>;
    get({ didUri, tenant }: {
        didUri: string;
        tenant?: string;
    }): Promise<BearerDid | undefined>;
    getSigningMethod({ didUri, methodId }: {
        didUri: string;
        methodId?: string;
    }): Promise<DidVerificationMethod>;
    import({ portableDid, tenant }: {
        portableDid: PortableDid;
        tenant?: string;
    }): Promise<BearerDid>;
    delete({ didUri, tenant, deleteKey }: {
        didUri: string;
        tenant?: string;
        deleteKey?: boolean;
    }): Promise<void>;
    deleteKeys({ portableDid }: {
        portableDid: PortableDid;
    }): Promise<void>;
    processRequest<T extends DidInterface>(request: DidRequest<T>): Promise<DidResponse<T>>;
    private getMethod;
}
//# sourceMappingURL=did-api.d.ts.map