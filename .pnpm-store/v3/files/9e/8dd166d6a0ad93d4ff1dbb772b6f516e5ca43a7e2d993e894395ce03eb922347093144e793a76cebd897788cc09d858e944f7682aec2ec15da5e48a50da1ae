var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { DidResolverCacheLevel } from '@web5/dids';
/**
 * AgentDidResolverCache keeps a stale copy of the Agent's managed Identity DIDs and only evicts and refreshes upon a successful resolution.
 * This allows for quick and offline access to the internal DIDs used by the agent.
 */
export class AgentDidResolverCache extends DidResolverCacheLevel {
    constructor({ agent, db, location, ttl }) {
        super({ db, location, ttl });
        /** A map of DIDs that are currently in-flight. This helps avoid going into an infinite loop */
        this._resolving = new Map();
        this._agent = agent;
    }
    get agent() {
        if (!this._agent) {
            throw new Error('Agent not initialized');
        }
        return this._agent;
    }
    set agent(agent) {
        this._agent = agent;
    }
    /**
     * Get the DID resolution result from the cache for the given DID.
     *
     * If the DID is managed by the agent, or is the agent's own DID, it will not evict it from the cache until a new resolution is successful.
     * This is done to achieve quick and offline access to the agent's own managed DIDs.
     */
    get(did) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const str = yield this.cache.get(did);
                const cachedResult = JSON.parse(str);
                if (!this._resolving.has(did) && Date.now() >= cachedResult.ttlMillis) {
                    this._resolving.set(did, true);
                    if (this.agent.agentDid.uri === did || 'undefined' !== typeof (yield this.agent.identity.get({ didUri: did }))) {
                        try {
                            const result = yield this.agent.did.resolve(did);
                            if (!result.didResolutionMetadata.error) {
                                this.set(did, result);
                            }
                        }
                        finally {
                            this._resolving.delete(did);
                        }
                    }
                    else {
                        this._resolving.delete(did);
                        this.cache.nextTick(() => this.cache.del(did));
                    }
                }
                return cachedResult.value;
            }
            catch (error) {
                if (error.notFound) {
                    return;
                }
                throw error;
            }
        });
    }
}
//# sourceMappingURL=agent-did-resolver-cache.js.map