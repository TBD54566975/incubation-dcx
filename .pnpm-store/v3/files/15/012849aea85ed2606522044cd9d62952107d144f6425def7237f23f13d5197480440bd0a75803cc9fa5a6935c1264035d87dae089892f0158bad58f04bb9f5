{"version":3,"file":"index.umd.js","sources":["../lib/intrinsicclass.ts","../lib/slots.ts","../lib/regex.ts","../lib/ecmascript.ts","../lib/intl.ts","../lib/instant.ts","../lib/calendar.ts","../lib/plaindate.ts","../lib/plaindatetime.ts","../lib/duration.ts","../lib/plainmonthday.ts","../lib/now.ts","../lib/plaintime.ts","../lib/timezone.ts","../lib/plainyearmonth.ts","../lib/zoneddatetime.ts","../lib/index.ts","../lib/legacydate.ts"],"sourcesContent":["import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\n\nimport { DEBUG } from './debug';\n\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\n\ntype TemporalIntrinsics = Omit<typeof Temporal, 'Now' | 'Instant' | 'ZonedDateTime'> & {\n  Instant: OmitConstructor<Temporal.Instant> &\n    (new (epochNanoseconds: JSBI) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\n  ZonedDateTime: OmitConstructor<Temporal.ZonedDateTime> &\n    (new (\n      epochNanoseconds: JSBI,\n      timeZone: string | Temporal.TimeZoneProtocol,\n      calendar?: string | Temporal.CalendarProtocol\n    ) => Temporal.ZonedDateTime) & {\n      prototype: typeof Temporal.ZonedDateTime.prototype;\n      from: typeof Temporal.ZonedDateTime.from;\n      compare: typeof Temporal.ZonedDateTime.compare;\n    };\n};\ntype TemporalIntrinsicRegistrations = {\n  [key in keyof TemporalIntrinsics as `Temporal.${key}`]: TemporalIntrinsics[key];\n};\ntype TemporalIntrinsicPrototypeRegistrations = {\n  [key in keyof TemporalIntrinsics as `Temporal.${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\n};\ntype TemporalIntrinsicRegisteredKeys = {\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\n};\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\n};\n\ntype CalendarPrototypeKeys = keyof Omit<Temporal.Calendar, typeof Symbol.toStringTag>;\ntype TemporalCalendarIntrinsicRegistrations = {\n  [key in CalendarPrototypeKeys as `Temporal.Calendar.prototype.${key}`]: Temporal.Calendar[key];\n} & {\n  'Temporal.Calendar.from': typeof Temporal.Calendar.from;\n};\ntype TemporalCalendarIntrinsicRegisteredKeys = {\n  [key in keyof TemporalCalendarIntrinsicRegistrations as `%${key}%`]: TemporalCalendarIntrinsicRegistrations[key];\n};\n\ntype TimeZonePrototypeKeys = 'getOffsetNanosecondsFor' | 'getPossibleInstantsFor';\ntype TemporalTimeZoneIntrinsicRegistrations = {\n  [key in TimeZonePrototypeKeys as `Temporal.TimeZone.prototype.${key}`]: Temporal.TimeZone[key];\n} & {\n  'Temporal.TimeZone.from': typeof Temporal.TimeZone.from;\n};\ntype TemporalTimeZoneIntrinsicRegisteredKeys = {\n  [key in keyof TemporalTimeZoneIntrinsicRegistrations as `%${key}%`]: TemporalTimeZoneIntrinsicRegistrations[key];\n};\n\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\n  TemporalIntrinsicPrototypeRegisteredKeys &\n  TemporalTimeZoneIntrinsicRegisteredKeys &\n  TemporalCalendarIntrinsicRegisteredKeys;\n\ntype customFormatFunction<T> = (\n  this: T,\n  depth: number,\n  options: { stylize: (value: unknown, type: 'number' | 'special') => string }\n) => string;\nconst customUtilInspectFormatters: Partial<{\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\n    InstanceType<TemporalIntrinsicRegistrations[key]>\n  >;\n}> = {\n  ['Temporal.Duration'](depth, options) {\n    const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n    if (depth < 1) return descr;\n    const entries = [];\n    for (const prop of [\n      'years',\n      'months',\n      'weeks',\n      'days',\n      'hours',\n      'minutes',\n      'seconds',\n      'milliseconds',\n      'microseconds',\n      'nanoseconds'\n    ] as const) {\n      if (this[prop] !== 0) entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n    }\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n  }\n};\n\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\n  return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\n\nexport function MakeIntrinsicClass(\n  Class: TemporalIntrinsicRegistrations[typeof name],\n  name: keyof TemporalIntrinsicRegistrations\n) {\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  if (DEBUG) {\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  for (const prop of Object.getOwnPropertyNames(Class)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class, prop, desc);\n  }\n  for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class.prototype, prop, desc);\n  }\n\n  DefineIntrinsic(name, Class);\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\n\ntype IntrinsicDefinitionKeys =\n  | keyof TemporalIntrinsicRegistrations\n  | keyof TemporalIntrinsicPrototypeRegistrations\n  | keyof TemporalCalendarIntrinsicRegistrations\n  | keyof TemporalTimeZoneIntrinsicRegistrations;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalCalendarIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalCalendarIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalTimeZoneIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalTimeZoneIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\n  INTRINSICS[key] = value;\n}\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): typeof INTRINSICS[KeyT] {\n  return INTRINSICS[intrinsic];\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { BuiltinCalendarId, AnyTemporalType, CalendarSlot, TimeZoneSlot } from './internaltypes';\n\n// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n\n// TimeZone\nexport const TIMEZONE_ID = 'slot-timezone-identifier';\n\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_YEAR = 'slot-year';\nexport const ISO_MONTH = 'slot-month';\nexport const ISO_DAY = 'slot-day';\nexport const ISO_HOUR = 'slot-hour';\nexport const ISO_MINUTE = 'slot-minute';\nexport const ISO_SECOND = 'slot-second';\nexport const ISO_MILLISECOND = 'slot-millisecond';\nexport const ISO_MICROSECOND = 'slot-microsecond';\nexport const ISO_NANOSECOND = 'slot-nanosecond';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n\n// ZonedDateTime\nexport const INSTANT = 'slot-cached-instant';\nexport const TIME_ZONE = 'slot-time-zone';\n\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n\n// Calendar\nexport const CALENDAR_ID = 'slot-calendar-identifier';\n\ninterface SlotInfo<ValueType, UsedByType extends AnyTemporalType> {\n  value: ValueType;\n  usedBy: UsedByType;\n}\n\ninterface SlotInfoRecord {\n  [k: string]: SlotInfo<unknown, AnyTemporalType>;\n}\n\ninterface Slots extends SlotInfoRecord {\n  // Instant\n  [EPOCHNANOSECONDS]: SlotInfo<JSBI, Temporal.Instant | Temporal.ZonedDateTime>; // number? JSBI?\n\n  // TimeZone\n  [TIMEZONE_ID]: SlotInfo<string, Temporal.TimeZone>;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_YEAR]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MONTH]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_DAY]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_HOUR]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MINUTE]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_SECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MILLISECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MICROSECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_NANOSECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [CALENDAR]: SlotInfo<CalendarSlot, TypesWithCalendarUnits>;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\n\n  // ZonedDateTime\n  [INSTANT]: SlotInfo<Temporal.Instant, Temporal.ZonedDateTime>;\n  [TIME_ZONE]: SlotInfo<TimeZoneSlot, Temporal.ZonedDateTime>;\n\n  // Duration\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\n\n  // Calendar\n  [CALENDAR_ID]: SlotInfo<BuiltinCalendarId, Temporal.Calendar>;\n}\n\ntype TypesWithCalendarUnits =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime;\n\ninterface SlotsToTypes {\n  // Instant\n  [EPOCHNANOSECONDS]: Temporal.Instant;\n\n  // TimeZone\n  [TIMEZONE_ID]: Temporal.TimeZone;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_YEAR]: TypesWithCalendarUnits;\n  [ISO_MONTH]: TypesWithCalendarUnits;\n  [ISO_DAY]: TypesWithCalendarUnits;\n  [ISO_HOUR]: TypesWithCalendarUnits;\n  [ISO_MINUTE]: TypesWithCalendarUnits;\n  [ISO_SECOND]: TypesWithCalendarUnits;\n  [ISO_MILLISECOND]: TypesWithCalendarUnits;\n  [ISO_MICROSECOND]: TypesWithCalendarUnits;\n  [ISO_NANOSECOND]: TypesWithCalendarUnits;\n  [CALENDAR]: TypesWithCalendarUnits;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: Temporal.PlainDate;\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\n\n  // ZonedDateTime\n  [INSTANT]: Temporal.ZonedDateTime;\n  [TIME_ZONE]: Temporal.ZonedDateTime;\n\n  // Duration\n  [YEARS]: Temporal.Duration;\n  [MONTHS]: Temporal.Duration;\n  [WEEKS]: Temporal.Duration;\n  [DAYS]: Temporal.Duration;\n  [HOURS]: Temporal.Duration;\n  [MINUTES]: Temporal.Duration;\n  [SECONDS]: Temporal.Duration;\n  [MILLISECONDS]: Temporal.Duration;\n  [MICROSECONDS]: Temporal.Duration;\n  [NANOSECONDS]: Temporal.Duration;\n\n  // Calendar\n  [CALENDAR_ID]: Temporal.Calendar;\n}\n\ntype SlotKey = keyof SlotsToTypes;\n\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\n\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\n  return globalSlots.get(container);\n}\n\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\n\n// expose GetSlots to avoid dual package hazards\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\n\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\n\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\n  globalSlots.set(container, Object.create(null));\n}\n\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\n\n// expose CreateSlots to avoid dual package hazards\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\n\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\n\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\n// guard that takes a variable number of parameters?\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey,\n  ID9 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8,\n  id9: ID9\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\n  if (!container || 'object' !== typeof container) return false;\n  const myslots = GetSlots(container as AnyTemporalType);\n  return !!myslots && ids.every((id) => id in myslots);\n}\nexport function GetSlot<KeyT extends keyof Slots>(\n  container: Slots[typeof id]['usedBy'],\n  id: KeyT\n): Slots[KeyT]['value'] {\n  const value = GetSlots(container)?.[id];\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\n  return value;\n}\nexport function SetSlot<KeyT extends SlotKey>(\n  container: Slots[KeyT]['usedBy'],\n  id: KeyT,\n  value: Slots[KeyT]['value']\n): void {\n  const slots = GetSlots(container);\n\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\n\n  const existingSlot = slots[id];\n\n  if (existingSlot) throw new TypeError(`${id} already has set`);\n\n  slots[id] = value;\n}\n","const tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nexport const timeZoneID = new RegExp(\n  '(?:' +\n    [\n      `(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*`,\n      'Etc/GMT(?:0|[-+]\\\\d{1,2})',\n      'GMT[-+]?0',\n      'EST5EDT',\n      'CST6CDT',\n      'MST7MDT',\n      'PST8PDT',\n      offsetNoCapture.source\n    ].join('|') +\n    ')'\n);\n\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\n);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\n\nexport const zoneddatetime = new RegExp(\n  [\n    `^${datesplit.source}`,\n    `(?:(?:T|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join(''),\n  'i'\n);\n\nexport const time = new RegExp(\n  [\n    `^T?${timesplit.source}`,\n    `(?:${offsetpart.source})?`,\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join(''),\n  'i'\n);\n\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\n// annotations are still allowed, and will throw if the calendar annotation is\n// not ISO.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\n// UTC offsets are not allowed, because they are not allowed with any date-only\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\nexport const yearmonth = new RegExp(\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\nexport const monthday = new RegExp(\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\n\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\n\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n","const ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nconst ReflectApply = Reflect.apply;\nconst ReflectOwnKeys = Reflect.ownKeys;\n\nimport { DEBUG } from './debug';\nimport JSBI from 'jsbi';\n\nimport type { Temporal } from '..';\nimport type {\n  AnyTemporalLikeType,\n  UnitSmallerThanOrEqualTo,\n  CalendarProtocolParams,\n  TimeZoneProtocolParams,\n  InstantParams,\n  PlainMonthDayParams,\n  ZonedDateTimeParams,\n  CalendarParams,\n  TimeZoneParams,\n  PlainDateParams,\n  PlainTimeParams,\n  DurationParams,\n  PlainDateTimeParams,\n  PlainYearMonthParams,\n  PrimitiveFieldsOf,\n  BuiltinCalendarId,\n  Keys,\n  AnyTemporalKey,\n  CalendarSlot,\n  TimeZoneSlot\n} from './internaltypes';\nimport { GetIntrinsic } from './intrinsicclass';\nimport {\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot,\n  EPOCHNANOSECONDS,\n  TIMEZONE_ID,\n  CALENDAR_ID,\n  INSTANT,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  DATE_BRAND,\n  YEAR_MONTH_BRAND,\n  MONTH_DAY_BRAND,\n  TIME_ZONE,\n  CALENDAR,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS\n} from './slots';\n\nexport const ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst SIXTY = JSBI.BigInt(60);\nconst TWENTY_FOUR = JSBI.BigInt(24);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst NEGATIVE_ONE = JSBI.BigInt(-1);\nconst HOUR_SECONDS = 3600;\nexport const HOUR_NANOS = JSBI.multiply(JSBI.BigInt(HOUR_SECONDS), BILLION);\nconst MINUTE_NANOS = JSBI.multiply(SIXTY, BILLION);\nconst DAY_NANOS = JSBI.multiply(HOUR_NANOS, TWENTY_FOUR);\nconst NS_MIN = JSBI.multiply(JSBI.BigInt(-86400), JSBI.BigInt(1e17));\nconst NS_MAX = JSBI.multiply(JSBI.BigInt(86400), JSBI.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = JSBI.multiply(JSBI.BigInt(-388152), JSBI.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(2 * 7));\n\nconst BUILTIN_CALENDAR_IDS = [\n  'iso8601',\n  'hebrew',\n  'islamic',\n  'islamic-umalqura',\n  'islamic-tbla',\n  'islamic-civil',\n  'islamic-rgsa',\n  'islamicc',\n  'persian',\n  'ethiopic',\n  'ethioaa',\n  'coptic',\n  'chinese',\n  'dangi',\n  'roc',\n  'indian',\n  'buddhist',\n  'japanese',\n  'gregory'\n];\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\n/**\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\n * the type parameter. This should only be used to help TS understand when variables change types,\n * but TS can't or won't infer this automatically. They should be used sparingly, because\n * if used incorrectly can lead to difficult-to-diagnose problems.\n * */\nexport function uncheckedAssertNarrowedType<T = unknown>(\n  arg: unknown,\n  justification: string\n): asserts arg is T extends typeof arg ? T : never {}\n/* eslint-enable */\n\ntype ArrayElement<ArrayType> = ArrayType extends readonly (infer ElementType)[] ? ElementType : never;\ntype ArrayWithNewKeys<T, Keys> = Array<ArrayElement<T> | Keys>;\n\n/**\n * In debug builds, this function verifies that the given argument \"exists\" (is not\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\n * @param arg\n */\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\n  if (DEBUG) {\n    if (arg != null) {\n      throw new Error('Expected arg to be set.');\n    }\n  }\n}\n\nfunction isZero(value: JSBI): boolean {\n  return JSBI.equal(value, ZERO);\n}\n\ntype Stringless<T> = Exclude<T, string>;\n\nfunction GetMethod<T extends { [s in M]?: (...args: any[]) => unknown }, M extends string & keyof T>(\n  obj: T,\n  methodName: M\n): T[M];\nfunction GetMethod<\n  T extends string | { [s in M]?: (...args: any[]) => unknown },\n  M extends string & keyof Stringless<T>\n>(obj: T, methodName: M): Stringless<T>[M] | undefined;\nfunction GetMethod<\n  T extends string | { [s in M]?: undefined | ((...args: any[]) => unknown) },\n  M extends string & keyof T\n>(obj: T, methodName: M): T[M] | undefined {\n  const result = obj[methodName];\n  if (result === undefined) return undefined;\n  if (DEBUG) {\n    if (typeof result !== 'function') throw new TypeError(`'${methodName}' must be a function`);\n  }\n  return result;\n}\n\nexport function Call<T, A extends readonly any[], R>(\n  target: (this: T, ...args: A) => R,\n  thisArgument: T,\n  argumentsList: Readonly<A>\n): R {\n  const args = arguments.length > 2 ? argumentsList : [];\n  if (DEBUG) {\n    if (!Array.isArray(argumentsList)) {\n      throw new TypeError('Assertion failed: optional `argumentsList`, if provided, must be an array');\n    }\n  }\n  return ReflectApply(target, thisArgument, args);\n}\n\n// For unknown values, this narrows the result to a Record. But for union types\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\n// leaving the object type(s) unchanged.\nexport function IsObject<T>(\n  value: T\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\n\nexport function ToNumber(value: unknown): number {\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\n  // we'll leave ToNumber as-is.\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\n  return NumberCtor(value);\n}\n\nfunction ToIntegerOrInfinity(value: unknown) {\n  const number = ToNumber(value);\n  if (NumberIsNaN(number) || number === 0) {\n    return 0;\n  }\n  if (!NumberIsFinite(number)) {\n    return number;\n  }\n  const integer = MathFloor(MathAbs(number));\n  if (integer === 0) {\n    return 0;\n  }\n  return MathSign(number) * integer;\n}\n\nfunction IsIntegralNumber(argument: unknown) {\n  if (typeof argument !== 'number' || NumberIsNaN(argument) || !NumberIsFinite(argument)) {\n    return false;\n  }\n  const absValue = MathAbs(argument);\n  return MathFloor(absValue) === absValue;\n}\n\nexport function ToString(value: unknown): string {\n  if (typeof value === 'symbol') {\n    throw new TypeError('Cannot convert a Symbol value to a String');\n  }\n  return StringCtor(value);\n}\n\nexport function ToIntegerWithTruncation(value: unknown): number {\n  const number = ToNumber(value);\n  if (number === 0) return 0;\n  if (NumberIsNaN(number) || !NumberIsFinite(number)) {\n    throw new RangeError('invalid number value');\n  }\n  const integer = MathTrunc(number);\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return integer;\n}\n\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\n  const integer = ToIntegerWithTruncation(valueParam);\n  if (integer <= 0) {\n    if (property !== undefined) {\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\n    }\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\n  }\n  return integer;\n}\n\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\n  const number = ToNumber(valueParam);\n  if (!NumberIsFinite(number)) throw new RangeError('infinity is out of range');\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return number;\n}\n\nfunction divmod(x: JSBI, y: JSBI): { quotient: JSBI; remainder: JSBI } {\n  const quotient = JSBI.divide(x, y);\n  const remainder = JSBI.remainder(x, y);\n  return { quotient, remainder };\n}\n\nfunction isNegativeJSBI(value: JSBI): boolean {\n  return JSBI.lessThan(value, ZERO);\n}\n\nfunction signJSBI(value: JSBI): 1 | 0 | -1 {\n  if (isZero(value)) return 0;\n  if (isNegativeJSBI(value)) return -1;\n  return 1;\n}\nfunction abs(x: JSBI): JSBI {\n  if (JSBI.lessThan(x, ZERO)) return JSBI.multiply(x, NEGATIVE_ONE);\n  return x;\n}\n\ntype BuiltinCastFunction = (v: unknown) => string | number;\nconst BUILTIN_CASTS = new Map<AnyTemporalKey, BuiltinCastFunction>([\n  ['year', ToIntegerWithTruncation],\n  ['month', ToPositiveIntegerWithTruncation],\n  ['monthCode', ToString],\n  ['day', ToPositiveIntegerWithTruncation],\n  ['hour', ToIntegerWithTruncation],\n  ['minute', ToIntegerWithTruncation],\n  ['second', ToIntegerWithTruncation],\n  ['millisecond', ToIntegerWithTruncation],\n  ['microsecond', ToIntegerWithTruncation],\n  ['nanosecond', ToIntegerWithTruncation],\n  ['years', ToIntegerIfIntegral],\n  ['months', ToIntegerIfIntegral],\n  ['weeks', ToIntegerIfIntegral],\n  ['days', ToIntegerIfIntegral],\n  ['hours', ToIntegerIfIntegral],\n  ['minutes', ToIntegerIfIntegral],\n  ['seconds', ToIntegerIfIntegral],\n  ['milliseconds', ToIntegerIfIntegral],\n  ['microseconds', ToIntegerIfIntegral],\n  ['nanoseconds', ToIntegerIfIntegral],\n  ['era', ToString],\n  ['eraYear', ToIntegerOrInfinity],\n  ['offset', ToString]\n]);\n\nconst BUILTIN_DEFAULTS = new Map([\n  ['hour', 0],\n  ['minute', 0],\n  ['second', 0],\n  ['millisecond', 0],\n  ['microsecond', 0],\n  ['nanosecond', 0]\n]);\n\n// each item is [plural, singular, category]\nconst SINGULAR_PLURAL_UNITS = [\n  ['years', 'year', 'date'],\n  ['months', 'month', 'date'],\n  ['weeks', 'week', 'date'],\n  ['days', 'day', 'date'],\n  ['hours', 'hour', 'time'],\n  ['minutes', 'minute', 'time'],\n  ['seconds', 'second', 'time'],\n  ['milliseconds', 'millisecond', 'time'],\n  ['microseconds', 'microsecond', 'time'],\n  ['nanoseconds', 'nanosecond', 'time']\n] as const;\nconst SINGULAR_FOR = new Map(SINGULAR_PLURAL_UNITS.map((e) => [e[0], e[1]] as const));\nconst PLURAL_FOR = new Map(SINGULAR_PLURAL_UNITS.map(([p, s]) => [s, p]));\nconst UNITS_DESCENDING = SINGULAR_PLURAL_UNITS.map(([, s]) => s);\n\nconst DURATION_FIELDS = Array.from(SINGULAR_FOR.keys()).sort();\n\nimport * as PARSE from './regex';\n\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\n\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\n  let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n  if (instance === undefined) {\n    instance = new IntlDateTimeFormat('en-us', {\n      timeZone: StringCtor(timeZoneIdentifier),\n      hour12: false,\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n  }\n  return instance;\n}\n\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : object {\n  if (typeof value === 'undefined' || value === null) {\n    throw new TypeError(`Expected object not ${value}`);\n  }\n  return Object(value);\n}\n\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\nexport function CopyDataProperties<K extends string | symbol, T extends Record<K, unknown>>(\n  target: T,\n  source: T | undefined,\n  excludedKeys: K[],\n  excludedValues?: unknown[]\n) {\n  if (typeof source === 'undefined' || source === null) return;\n\n  const keys = ReflectOwnKeys(source) as (keyof T)[];\n  for (const nextKey of keys) {\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\n      const propValue = source[nextKey];\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\n\n      target[nextKey] = propValue;\n    }\n  }\n}\n\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\n\nexport function IsTemporalTimeZone(item: unknown): item is Temporal.TimeZone {\n  return HasSlot(item, TIMEZONE_ID);\n}\nexport function IsTemporalCalendar(item: unknown): item is Temporal.Calendar {\n  return HasSlot(item, CALENDAR_ID);\n}\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\n  return HasSlot(item, DATE_BRAND);\n}\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\n  return (\n    HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n    !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY)\n  );\n}\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\n  return HasSlot(\n    item,\n    ISO_YEAR,\n    ISO_MONTH,\n    ISO_DAY,\n    ISO_HOUR,\n    ISO_MINUTE,\n    ISO_SECOND,\n    ISO_MILLISECOND,\n    ISO_MICROSECOND,\n    ISO_NANOSECOND\n  );\n}\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\n  return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\n  return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n    throw new TypeError('with() does not support a calendar or timeZone property');\n  }\n  if (IsTemporalTime(item)) {\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\n  }\n  if ((item as { calendar: unknown }).calendar !== undefined) {\n    throw new TypeError('with() does not support a calendar property');\n  }\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\n    throw new TypeError('with() does not support a timeZone property');\n  }\n}\nfunction ParseTemporalTimeZone(stringIdent: string) {\n  const { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n  if (ianaName) return GetCanonicalTimeZoneIdentifier(ianaName);\n  if (z) return 'UTC';\n  // if !ianaName && !z then offset must be present\n  assertExists(offset);\n  const offsetNs = ParseTimeZoneOffsetString(offset);\n  return FormatTimeZoneOffsetString(offsetNs);\n}\n\nfunction MaybeFormatCalendarAnnotation(\n  calendar: CalendarSlot,\n  showCalendar: Temporal.ShowCalendarOption['calendarName']\n): string {\n  if (showCalendar === 'never') return '';\n  return FormatCalendarAnnotation(ToTemporalCalendarIdentifier(calendar), showCalendar);\n}\n\nfunction FormatCalendarAnnotation(id: string, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\n  if (showCalendar === 'never') return '';\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\n  const flag = showCalendar === 'critical' ? '!' : '';\n  return `[${flag}u-ca=${id}]`;\n}\n\nfunction ParseISODateTime(isoString: string) {\n  // ZDT is the superset of fields for every other Temporal type\n  const match = PARSE.zoneddatetime.exec(isoString);\n  if (!match) throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  let yearString = match[1];\n  if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n  if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  const year = ToIntegerOrInfinity(yearString);\n  const month = ToIntegerOrInfinity(match[2] || match[4]);\n  const day = ToIntegerOrInfinity(match[3] || match[5]);\n  const hour = ToIntegerOrInfinity(match[6]);\n  const hasTime = match[6] !== undefined;\n  const minute = ToIntegerOrInfinity(match[7] || match[10]);\n  let second = ToIntegerOrInfinity(match[8] || match[11]);\n  if (second === 60) second = 59;\n  const fraction = (match[9] || match[12]) + '000000000';\n  const millisecond = ToIntegerOrInfinity(fraction.slice(0, 3));\n  const microsecond = ToIntegerOrInfinity(fraction.slice(3, 6));\n  const nanosecond = ToIntegerOrInfinity(fraction.slice(6, 9));\n  let offset;\n  let z = false;\n  if (match[13]) {\n    offset = undefined;\n    z = true;\n  } else if (match[14] && match[15]) {\n    const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n    const offsetHours = match[15] || '00';\n    const offsetMinutes = match[16] || '00';\n    const offsetSeconds = match[17] || '00';\n    let offsetFraction = match[18] || '0';\n    offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n    if (+offsetFraction) {\n      while (offsetFraction.endsWith('0')) offsetFraction = offsetFraction.slice(0, -1);\n      offset += `:${offsetSeconds}.${offsetFraction}`;\n    } else if (+offsetSeconds) {\n      offset += `:${offsetSeconds}`;\n    }\n    if (offset === '-00:00') offset = '+00:00';\n  }\n  const ianaName = match[19];\n  const annotations = match[20];\n  let calendar;\n  for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n    if (key === 'u-ca') {\n      if (calendar === undefined) calendar = value;\n    } else if (critical === '!') {\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n    }\n  }\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  return {\n    year,\n    month,\n    day,\n    hasTime,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    ianaName,\n    offset,\n    z,\n    calendar\n  };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstantString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.ianaName) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateTimeString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeString(isoString: string) {\n  const match = PARSE.time.exec(isoString);\n  let hour, minute, second, millisecond, microsecond, nanosecond, annotations;\n  if (match) {\n    hour = ToIntegerOrInfinity(match[1]);\n    minute = ToIntegerOrInfinity(match[2] || match[5]);\n    second = ToIntegerOrInfinity(match[3] || match[6]);\n    if (second === 60) second = 59;\n    const fraction = (match[4] || match[7]) + '000000000';\n    millisecond = ToIntegerOrInfinity(fraction.slice(0, 3));\n    microsecond = ToIntegerOrInfinity(fraction.slice(3, 6));\n    nanosecond = ToIntegerOrInfinity(fraction.slice(6, 9));\n    annotations = match[14];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key !== 'u-ca' && critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\n  } else {\n    let z, hasTime;\n    ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, z } = ParseISODateTime(isoString));\n    if (!hasTime) throw new RangeError(`time is missing in string: ${isoString}`);\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\n  }\n  // if it's a date-time string, OK\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n  }\n  try {\n    const { month, day } = ParseTemporalMonthDayString(isoString);\n    RejectISODate(1972, month, day);\n  } catch {\n    try {\n      const { year, month } = ParseTemporalYearMonthString(isoString);\n      RejectISODate(year, month, 1);\n    } catch {\n      return { hour, minute, second, millisecond, microsecond, nanosecond };\n    }\n  }\n  throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalYearMonthString(isoString: string) {\n  const match = PARSE.yearmonth.exec(isoString);\n  let year, month, calendar, referenceISODay;\n  if (match) {\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    year = ToIntegerOrInfinity(yearString);\n    month = ToIntegerOrInfinity(match[2]);\n    const annotations = match[3];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key === 'u-ca') {\n        if (calendar === undefined) calendar = value;\n      } else if (critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\n  }\n  return { year, month, calendar, referenceISODay };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalMonthDayString(isoString: string) {\n  const match = PARSE.monthday.exec(isoString);\n  let month, day, calendar, referenceISOYear;\n  if (match) {\n    month = ToIntegerOrInfinity(match[1]);\n    day = ToIntegerOrInfinity(match[2]);\n    const annotations = match[3];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key === 'u-ca') {\n        if (calendar === undefined) calendar = value;\n      } else if (critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\n  }\n  return { month, day, calendar, referenceISOYear };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeZoneString(stringIdent: string): Partial<{\n  ianaName: string | undefined;\n  offset: string | undefined;\n  z: boolean | undefined;\n}> {\n  const bareID = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\n  if (bareID.test(stringIdent)) return { ianaName: stringIdent };\n  try {\n    // Try parsing ISO string instead\n    const result = ParseISODateTime(stringIdent);\n    if (result.z || result.offset || result.ianaName) {\n      return result;\n    }\n  } catch {\n    // fall through\n  }\n  throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDurationString(isoString: string) {\n  const match = PARSE.duration.exec(isoString);\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\n  if (match.slice(2).every((element) => element === undefined)) {\n    throw new RangeError(`invalid duration: ${isoString}`);\n  }\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\n  const fHours = match[7];\n  const minutesStr = match[8];\n  const fMinutes = match[9];\n  const secondsStr = match[10];\n  const fSeconds = match[11];\n  let minutes = 0;\n  let seconds = 0;\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\n  let excessNanoseconds = 0;\n\n  if (fHours !== undefined) {\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\n      throw new RangeError('only the smallest unit can be fractional');\n    }\n    excessNanoseconds = ToIntegerOrInfinity((fHours + '000000000').slice(0, 9)) * 3600 * sign;\n  } else {\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\n    if (fMinutes !== undefined) {\n      if (secondsStr ?? fSeconds ?? false) {\n        throw new RangeError('only the smallest unit can be fractional');\n      }\n      excessNanoseconds = ToIntegerOrInfinity((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\n    } else {\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\n      if (fSeconds !== undefined) {\n        excessNanoseconds = ToIntegerOrInfinity((fSeconds + '000000000').slice(0, 9)) * sign;\n      }\n    }\n  }\n\n  const nanoseconds = excessNanoseconds % 1000;\n  const microseconds = MathTrunc(excessNanoseconds / 1000) % 1000;\n  const milliseconds = MathTrunc(excessNanoseconds / 1e6) % 1000;\n  seconds += MathTrunc(excessNanoseconds / 1e9) % 60;\n  minutes += MathTrunc(excessNanoseconds / 6e10);\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstant(isoString: string) {\n  let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } =\n    ParseTemporalInstantString(isoString);\n\n  if (!z && !offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  // At least one of z or offset is defined, but TS doesn't seem to understand\n  // that we only use offset if z is not defined (and thus offset must be defined).\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-type-assertion\n  const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset!);\n  ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond - offsetNs\n  ));\n\n  const epochNs = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n  return epochNs;\n}\n\nexport function RegulateISODate(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, day);\n      break;\n    case 'constrain':\n      ({ year, month, day } = ConstrainISODate(year, month, day));\n      break;\n  }\n  return { year, month, day };\n}\n\nexport function RegulateTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  switch (overflow) {\n    case 'reject':\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n      break;\n    case 'constrain':\n      ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n      ));\n      break;\n  }\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RegulateISOYearMonth(\n  yearParam: number,\n  monthParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  const referenceISODay = 1;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, referenceISODay);\n      break;\n    case 'constrain':\n      ({ year, month } = ConstrainISODate(year, month));\n      break;\n  }\n  return { year, month };\n}\n\nfunction ToTemporalDurationRecord(item: Temporal.DurationLike | string) {\n  if (!IsObject(item)) {\n    return ParseTemporalDurationString(ToString(item));\n  }\n  if (IsTemporalDuration(item)) {\n    return {\n      years: GetSlot(item, YEARS),\n      months: GetSlot(item, MONTHS),\n      weeks: GetSlot(item, WEEKS),\n      days: GetSlot(item, DAYS),\n      hours: GetSlot(item, HOURS),\n      minutes: GetSlot(item, MINUTES),\n      seconds: GetSlot(item, SECONDS),\n      milliseconds: GetSlot(item, MILLISECONDS),\n      microseconds: GetSlot(item, MICROSECONDS),\n      nanoseconds: GetSlot(item, NANOSECONDS)\n    };\n  }\n  const result = {\n    years: 0,\n    months: 0,\n    weeks: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n    microseconds: 0,\n    nanoseconds: 0\n  };\n  let partial = ToTemporalPartialDurationRecord(item);\n  for (const property of DURATION_FIELDS) {\n    const value = partial[property];\n    if (value !== undefined) {\n      result[property] = value;\n    }\n  }\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = result;\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\n  if (!IsObject(temporalDurationLike)) {\n    throw new TypeError('invalid duration-like');\n  }\n  const result: Record<typeof DURATION_FIELDS[number], number | undefined> = {\n    years: undefined,\n    months: undefined,\n    weeks: undefined,\n    days: undefined,\n    hours: undefined,\n    minutes: undefined,\n    seconds: undefined,\n    milliseconds: undefined,\n    microseconds: undefined,\n    nanoseconds: undefined\n  };\n  let any = false;\n  for (const property of DURATION_FIELDS) {\n    const value = temporalDurationLike[property];\n    if (value !== undefined) {\n      any = true;\n      result[property] = ToIntegerIfIntegral(value);\n    }\n  }\n  if (!any) {\n    throw new TypeError('invalid duration-like');\n  }\n  return result;\n}\n\nfunction ToLimitedTemporalDuration(\n  item: Temporal.DurationLike | string,\n  disallowedProperties: (keyof Temporal.DurationLike)[]\n) {\n  let record = ToTemporalDurationRecord(item);\n  for (const property of disallowedProperties) {\n    if (record[property] !== 0) {\n      throw new RangeError(\n        `Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\n      );\n    }\n  }\n  return record;\n}\n\nexport function ToTemporalOverflow(options: Temporal.AssignmentOptions | undefined) {\n  if (options === undefined) return 'constrain';\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\n\nexport function ToTemporalDisambiguation(options: Temporal.ToInstantOptions | undefined) {\n  if (options === undefined) return 'compatible';\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\n\nexport function ToTemporalRoundingMode(\n  options: { roundingMode?: Temporal.RoundingMode },\n  fallback: Temporal.RoundingMode\n) {\n  return GetOption(\n    options,\n    'roundingMode',\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\n    fallback\n  );\n}\n\nfunction NegateTemporalRoundingMode(roundingMode: Temporal.RoundingMode) {\n  switch (roundingMode) {\n    case 'ceil':\n      return 'floor';\n    case 'floor':\n      return 'ceil';\n    case 'halfCeil':\n      return 'halfFloor';\n    case 'halfFloor':\n      return 'halfCeil';\n    default:\n      return roundingMode;\n  }\n}\n\nexport function ToTemporalOffset(\n  options: Temporal.OffsetDisambiguationOptions | undefined,\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\n) {\n  if (options === undefined) return fallback;\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\n\nexport function ToCalendarNameOption(options: Temporal.ShowCalendarOption) {\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\n}\n\nexport function ToTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\n}\n\nexport function ToShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\n\nexport function ToTemporalRoundingIncrement(options: { roundingIncrement?: number }) {\n  let increment = options.roundingIncrement;\n  if (increment === undefined) return 1;\n  increment = ToNumber(increment);\n  if (!NumberIsFinite(increment)) {\n    throw new RangeError('roundingIncrement must be finite');\n  }\n  const integerIncrement = MathTrunc(increment);\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\n  }\n  return integerIncrement;\n}\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\n  const maximum = inclusive ? dividend : dividend - 1;\n  if (increment > maximum) {\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\n  }\n  if (dividend % increment !== 0) {\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n  }\n}\n\nexport function ToFractionalSecondDigits(\n  normalizedOptions: Temporal.ToStringPrecisionOptions\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\n  if (digitsValue === undefined) return 'auto';\n  if (typeof digitsValue !== 'number') {\n    if (ToString(digitsValue) !== 'auto') {\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n    }\n    return 'auto';\n  }\n  const digitCount = MathFloor(digitsValue);\n  if (!NumberIsFinite(digitCount) || digitCount < 0 || digitCount > 9) {\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n  }\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\n}\n\nexport function ToSecondsStringPrecisionRecord(\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\n): {\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\n  increment: number;\n} {\n  switch (smallestUnit) {\n    case 'minute':\n      return { precision: 'minute', unit: 'minute', increment: 1 };\n    case 'second':\n      return { precision: 0, unit: 'second', increment: 1 };\n    case 'millisecond':\n      return { precision: 3, unit: 'millisecond', increment: 1 };\n    case 'microsecond':\n      return { precision: 6, unit: 'microsecond', increment: 1 };\n    case 'nanosecond':\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\n    default: // fall through if option not given\n  }\n  switch (precision) {\n    case 'auto':\n      return { precision, unit: 'nanosecond', increment: 1 };\n    case 0:\n      return { precision, unit: 'second', increment: 1 };\n    case 1:\n    case 2:\n    case 3:\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n    case 4:\n    case 5:\n    case 6:\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n    case 7:\n    case 8:\n    case 9:\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n    default:\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\n  }\n}\n\nexport const REQUIRED = Symbol('~required~');\n\ninterface TemporalUnitOptionsBag {\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n}\ntype UnitTypeMapping = {\n  date: Temporal.DateUnit;\n  time: Temporal.TimeUnit;\n  datetime: Temporal.DateTimeUnit;\n};\n// This type specifies the allowed defaults for each unit key type.\ntype AllowedGetTemporalUnitDefaultValues = {\n  smallestUnit: undefined;\n  largestUnit: 'auto' | undefined;\n  unit: undefined;\n};\n\nexport function GetTemporalUnit<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\nexport function GetTemporalUnit<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\n// This signature of the function is NOT used in type-checking, so restricting\n// the default value via generic binding like the other overloads isn't\n// necessary.\nexport function GetTemporalUnit<\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(\n  options: TemporalUnitOptionsBag,\n  key: keyof typeof options,\n  unitGroup: T,\n  requiredOrDefault: D,\n  extraValues: ReadonlyArray<E> | never[] = []\n): R {\n  const allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\n  for (const [, singular, category] of SINGULAR_PLURAL_UNITS) {\n    if (unitGroup === 'datetime' || unitGroup === category) {\n      allowedSingular.push(singular);\n    }\n  }\n  allowedSingular.push(...extraValues);\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\n  if (defaultVal === REQUIRED) {\n    defaultVal = undefined;\n  } else if (defaultVal !== undefined) {\n    allowedSingular.push(defaultVal);\n  }\n  const allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [\n    ...allowedSingular\n  ];\n  for (const singular of allowedSingular) {\n    const plural = PLURAL_FOR.get(singular as Parameters<typeof PLURAL_FOR.get>[0]);\n    if (plural !== undefined) allowedValues.push(plural);\n  }\n  let retval = GetOption(options, key, allowedValues, defaultVal);\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\n    throw new RangeError(`${key} is required`);\n  }\n  // Coerce any plural units into their singular form\n  if (SINGULAR_FOR.has(retval as Temporal.PluralUnit<Temporal.DateTimeUnit>)) {\n    // We just has-checked this, but tsc doesn't understand that.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return SINGULAR_FOR.get(retval as Temporal.PluralUnit<Temporal.DateTimeUnit>)! as R;\n  }\n  return retval as R;\n}\n\nexport function ToRelativeTemporalObject(options: {\n  relativeTo?:\n    | Temporal.ZonedDateTime\n    | Temporal.PlainDateTime\n    | Temporal.ZonedDateTimeLike\n    | Temporal.PlainDateTimeLike\n    | string\n    | undefined;\n}): Temporal.ZonedDateTime | Temporal.PlainDate | undefined {\n  const relativeTo = options.relativeTo;\n  if (relativeTo === undefined) return relativeTo;\n\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  let matchMinutes = false;\n  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n  if (IsObject(relativeTo)) {\n    if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo)) return relativeTo;\n    if (IsTemporalDateTime(relativeTo)) return TemporalDateTimeToDate(relativeTo);\n    calendar = GetTemporalCalendarSlotValueWithISODefault(relativeTo);\n    const fieldNames = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    type FieldNamesWithTimeZoneAndOffset = ArrayWithNewKeys<typeof fieldNames, 'timeZone' | 'offset'>;\n    (fieldNames as FieldNamesWithTimeZoneAndOffset).push('timeZone', 'offset');\n    const fields = PrepareTemporalFields(relativeTo, fieldNames, []);\n    const dateOptions = ObjectCreate(null) as Temporal.AssignmentOptions;\n    dateOptions.overflow = 'constrain';\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      dateOptions\n    ));\n    offset = fields.offset;\n    if (offset === undefined) offsetBehaviour = 'wall';\n    timeZone = fields.timeZone;\n    if (timeZone !== undefined) timeZone = ToTemporalTimeZoneSlotValue(timeZone);\n  } else {\n    let ianaName, z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n      ParseISODateTime(ToString(relativeTo)));\n    if (ianaName) {\n      timeZone = ToTemporalTimeZoneSlotValue(ianaName);\n      if (z) {\n        offsetBehaviour = 'exact';\n      } else if (!offset) {\n        offsetBehaviour = 'wall';\n      }\n      matchMinutes = true;\n    } else if (z) {\n      throw new RangeError(\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\n      );\n    }\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n  }\n  if (timeZone === undefined) return CreateTemporalDate(year, month, day, calendar);\n  // If offset is missing here, then offsetBehavior will never be be 'option'.\n  assertExists(offset);\n  const offsetNs = offsetBehaviour === 'option' ? ParseTimeZoneOffsetString(offset) : 0;\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    'compatible',\n    'reject',\n    matchMinutes\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function DefaultTemporalLargestUnit(\n  years: number,\n  months: number,\n  weeks: number,\n  days: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number\n): Temporal.DateTimeUnit {\n  for (const [prop, v] of [\n    ['years', years],\n    ['months', months],\n    ['weeks', weeks],\n    ['days', days],\n    ['hours', hours],\n    ['minutes', minutes],\n    ['seconds', seconds],\n    ['milliseconds', milliseconds],\n    ['microseconds', microseconds],\n    ['nanoseconds', nanoseconds]\n  ] as const) {\n    if (v !== 0) {\n      // All the above keys are definitely in SINGULAR_FOR\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return SINGULAR_FOR.get(prop)!;\n    }\n  }\n  return 'nanosecond';\n}\n\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\n  unit1: T1,\n  unit2: T2\n) {\n  if (UNITS_DESCENDING.indexOf(unit1) > UNITS_DESCENDING.indexOf(unit2)) return unit2;\n  return unit1;\n}\n\ntype FieldCompleteness = 'complete' | 'partial';\ninterface FieldPrepareOptions {\n  emptySourceErrorMessage: string;\n}\n\n// Returns all potential owners from all Temporal Like-types for a given union\n// of keys in K.\n// e.g.\n// Owner<'nanosecond'> => PlainDateTimeLike | ZonedDateTimeLike | PlainDateTimeLike | ZonedDateTimeLike\n// Owner<'nanoseconds'> => Duration (the only type with plural keys)\ntype Owner<K extends AnyTemporalKey> =\n  // Conditional typing maps over all of the types given in AnyTemporalLikeType\n  // union\n  K extends unknown ? OwnerOf<K, AnyTemporalLikeType> : 'ThisShouldNeverHappen';\n\n// Returns T iff T has K as all of the key(s) (even if those keys are optional\n// in T), never otherwise. This is a private type for use only in the Owner type\n// above.\ntype OwnerOf<K extends AnyTemporalKey, T> =\n  // Distribute the union before passing to Required\n  // Without distributing, this is\n  // Required<ZonedDateTimeLike | DurationLike> extends Record\n  // vs (with distribution)\n  // Required<ZonedDateTimeLike> extends Record<....> | Required<DurationLike> extends Record<....>\n  T extends unknown\n    ? // All the keys in the Like-types are optional, so in order for them to\n      // 'extend Record<K,...>', where K indicates the required fields, we pass T\n      // through Required to make all the keys non-optional.\n      // Note this doesn't work the other way around: using Partial<Record<K, ..>>\n      // will always be extended by any object (as all the keys are optional).\n      Required<T> extends Record<K, unknown>\n      ? T\n      : // never is the 'identity' type for unions - nothing will be added or\n        // removed from the union.\n        never\n    : 'ThisShouldNeverHappen';\n\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\n\n// Resolve copies the keys and values of a given object type so that TS will\n// stop using type names in error messages / autocomplete. Generally, those\n// names can be more useful, but sometimes having the primitive object shape is\n// significantly easier to reason about (e.g. deeply-nested types).\n// Resolve is an identity function for function types.\ntype Resolve<T> =\n  // Re-mapping doesn't work very well for functions, so exclude them\n  T extends (...args: never[]) => unknown\n    ? T\n    : // Re-map all the keys in T to the same value. This forces TS into no longer\n      // using type aliases, etc.\n      { [K in keyof T]: T[K] };\n\ntype FieldObjectFromOwners<OwnerT, FieldKeys extends AnyTemporalKey> = Resolve<\n  // The resulting object type contains:\n  // - All keys in FieldKeys, which are required properties and their values\n  //   don't include undefined.\n  // - All the other keys in OwnerT that aren't in FieldKeys, which are optional\n  //   properties and their value types explicitly include undefined.\n  {\n    -readonly [k in FieldKeys]: Exclude<Prop<OwnerT, k>, undefined>;\n  } & {\n    -readonly [k in Exclude<Keys<OwnerT>, FieldKeys>]?: Prop<OwnerT, k> | undefined;\n  }\n>;\n\ntype PrepareTemporalFieldsReturn<\n  FieldKeys extends AnyTemporalKey,\n  RequiredFieldsOpt extends ReadonlyArray<FieldKeys> | FieldCompleteness,\n  OwnerT extends Owner<FieldKeys>\n> = RequiredFieldsOpt extends 'partial' ? Partial<OwnerT> : FieldObjectFromOwners<OwnerT, FieldKeys>;\nexport function PrepareTemporalFields<\n  FieldKeys extends AnyTemporalKey,\n  // Constrains the Required keys to be a subset of the given field keys\n  // This could have been written directly into the parameter type, but that\n  // causes an unintended effect where the required fields are added to the list\n  // of field keys, even if that key isn't present in 'fields'.\n  // RequiredFieldKeys extends FieldKeys,\n  RequiredFields extends ReadonlyArray<FieldKeys> | FieldCompleteness\n>(\n  bag: Partial<Record<FieldKeys, unknown>>,\n  fields: Array<FieldKeys>,\n  requiredFields: RequiredFields,\n  { emptySourceErrorMessage }: FieldPrepareOptions = { emptySourceErrorMessage: 'no supported properties found' }\n): PrepareTemporalFieldsReturn<FieldKeys, RequiredFields, Owner<FieldKeys>> {\n  const result: Partial<Record<AnyTemporalKey, unknown>> = ObjectCreate(null);\n  let any = false;\n  fields.sort();\n  for (const property of fields) {\n    let value = bag[property];\n    if (value !== undefined) {\n      any = true;\n      if (BUILTIN_CASTS.has(property)) {\n        // We just has-checked this map access, so there will definitely be a\n        // value.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        value = BUILTIN_CASTS.get(property)!(value);\n      }\n      result[property] = value;\n    } else if (requiredFields !== 'partial') {\n      // TODO: using .call in this way is not correctly type-checked by tsc.\n      // We might need a type-safe Call wrapper?\n      if (ArrayIncludes.call(requiredFields, property)) {\n        throw new TypeError(`required property '${property}' missing or undefined`);\n      }\n      value = BUILTIN_DEFAULTS.get(property);\n      result[property] = value;\n    }\n  }\n  if (requiredFields === 'partial' && !any) {\n    throw new TypeError(emptySourceErrorMessage);\n  }\n  return result as unknown as PrepareTemporalFieldsReturn<FieldKeys, RequiredFields, Owner<FieldKeys>>;\n}\n\ninterface TimeRecord {\n  hour?: number;\n  minute?: number;\n  second?: number;\n  microsecond?: number;\n  millisecond?: number;\n  nanosecond?: number;\n}\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): Required<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: 'partial'\n): Partial<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\n  completeness: 'complete'\n): Required<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: FieldCompleteness = 'complete'\n): Partial<TimeRecord> {\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\n  const partial = PrepareTemporalFields(bag, fields, 'partial', { emptySourceErrorMessage: 'invalid time-like' });\n  const result: Partial<TimeRecord> = {};\n  for (const field of fields) {\n    const valueDesc = ObjectGetOwnPropertyDescriptor(partial, field);\n    if (valueDesc !== undefined) {\n      result[field] = valueDesc.value;\n    } else if (completeness === 'complete') {\n      result[field] = 0;\n    }\n  }\n  return result;\n}\n\nexport function ToTemporalDate(\n  itemParam: PlainDateParams['from'][0],\n  options?: PlainDateParams['from'][1]\n): Temporal.PlainDate {\n  let item = itemParam;\n  if (IsObject(item)) {\n    if (IsTemporalDate(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      item = GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return CreateTemporalDate(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    const calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    return CalendarDateFromFields(calendar, fields, options);\n  }\n  ToTemporalOverflow(options); // validate and ignore\n  let { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\n  if (!calendar) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n  return CreateTemporalDate(year, month, day, calendar);\n}\n\nexport function InterpretTemporalDateTimeFields(\n  calendar: CalendarSlot,\n  fields: PrimitiveFieldsOf<Temporal.PlainDateTimeLike> & Parameters<typeof CalendarDateFromFields>[1],\n  options?: Temporal.AssignmentOptions\n) {\n  let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n  const overflow = ToTemporalOverflow(options);\n  const date = CalendarDateFromFields(calendar, fields, options);\n  const year = GetSlot(date, ISO_YEAR);\n  const month = GetSlot(date, ISO_MONTH);\n  const day = GetSlot(date, ISO_DAY);\n  ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    overflow\n  ));\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\n  let year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    millisecond: number,\n    microsecond: number,\n    nanosecond: number,\n    calendar;\n  if (IsObject(item)) {\n    if (IsTemporalDateTime(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDate(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return CreateTemporalDateTime(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        GetSlot(item, CALENDAR)\n      );\n    }\n\n    calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      options\n    ));\n  } else {\n    ToTemporalOverflow(options); // validate and ignore\n    let z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n      ParseTemporalDateTimeString(ToString(item)));\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\n    RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n  }\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\n  if (IsTemporalDuration(item)) return item;\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(item);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n}\n\nexport function ToTemporalInstant(item: InstantParams['from'][0]) {\n  if (IsTemporalInstant(item)) return item;\n  if (IsTemporalZonedDateTime(item)) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n  }\n  const ns = ParseTemporalInstant(ToString(item));\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  return new TemporalInstant(ns);\n}\n\nexport function ToTemporalMonthDay(\n  itemParam: PlainMonthDayParams['from'][0],\n  options?: PlainMonthDayParams['from'][1]\n) {\n  let item = itemParam;\n  if (IsObject(item)) {\n    if (IsTemporalMonthDay(item)) return item;\n    let calendar: CalendarSlot, calendarAbsent: boolean;\n    if (HasSlot(item, CALENDAR)) {\n      calendar = GetSlot(item, CALENDAR);\n      calendarAbsent = false;\n    } else {\n      let calendarFromItem = item.calendar;\n      calendarAbsent = calendarFromItem === undefined;\n      if (calendarFromItem === undefined) calendarFromItem = 'iso8601';\n      calendar = ToTemporalCalendarSlotValue(calendarFromItem);\n    }\n    // HasSlot above adjusts the type of 'item' to include\n    // TypesWithCalendarUnits, which causes type-inference failures below.\n    // This is probably indicative of problems with HasSlot's typing.\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    // Callers who omit the calendar are not writing calendar-independent\n    // code. In that case, `monthCode`/`year` can be omitted; `month` and\n    // `day` are sufficient. Add a `year` to satisfy calendar validation.\n    if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n      fields.year = 1972;\n    }\n    return CalendarMonthDayFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(ToString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n\n  if (referenceISOYear === undefined) {\n    RejectISODate(1972, month, day);\n    return CreateTemporalMonthDay(month, day, calendar);\n  }\n  const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n  return CalendarMonthDayFromFields(calendar, result);\n}\n\nexport function ToTemporalTime(\n  itemParam: PlainTimeParams['from'][0],\n  overflow: NonNullable<PlainTimeParams['from'][1]>['overflow'] = 'constrain'\n) {\n  let item = itemParam;\n  let hour, minute, second, millisecond, microsecond, nanosecond;\n  if (IsObject(item)) {\n    if (IsTemporalTime(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      item = GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n      return new TemporalPlainTime(\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND)\n      );\n    }\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n  } else {\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ParseTemporalTimeString(ToString(item)));\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function ToTemporalYearMonth(\n  item: PlainYearMonthParams['from'][0],\n  options?: PlainYearMonthParams['from'][1]\n): Temporal.PlainYearMonth {\n  if (IsObject(item)) {\n    if (IsTemporalYearMonth(item)) return item;\n    const calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    return CalendarYearMonthFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(ToString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n\n  if (referenceISODay === undefined) {\n    RejectISODate(year, month, 1);\n    return CreateTemporalYearMonth(year, month, calendar);\n  }\n  const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n  return CalendarYearMonthFromFields(calendar, result);\n}\n\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\n\nexport function InterpretISODateTimeOffset(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  offsetBehaviour: OffsetBehaviour,\n  offsetNs: number,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\n  matchMinute: boolean\n) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\n    // the offset), so just convert DateTime to Instant in the given time zone\n    const instant = GetInstantFor(timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n  }\n\n  // The caller wants the offset to always win ('use') OR the caller is OK\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\n  // for this timezone and date/time.\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n    // Calculate the instant for the input's date/time and offset\n    const epochNs = GetUTCEpochNanoseconds(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    );\n    if (epochNs === null) throw new RangeError('ZonedDateTime outside of supported range');\n    return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n  }\n\n  // \"prefer\" or \"reject\"\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n  for (const candidate of possibleInstants) {\n    const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n    const roundedCandidateOffset = JSBI.toNumber(\n      RoundNumberToIncrement(JSBI.BigInt(candidateOffset), MINUTE_NANOS, 'halfExpand')\n    );\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n      return GetSlot(candidate, EPOCHNANOSECONDS);\n    }\n  }\n\n  // the user-provided offset doesn't match any instants for this time\n  // zone and date/time.\n  if (offsetOpt === 'reject') {\n    const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n    const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n    // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n    // toString (which is invoked by Node when using template literals directly).\n    // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n  }\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\n  // so fall back to use the time zone instead.\n  const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n  return GetSlot(instant, EPOCHNANOSECONDS);\n}\n\nexport function ToTemporalZonedDateTime(\n  item: ZonedDateTimeParams['from'][0],\n  options?: ZonedDateTimeParams['from'][1]\n) {\n  let year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    millisecond: number,\n    microsecond: number,\n    nanosecond: number,\n    timeZone,\n    offset: string | undefined,\n    calendar: string | Temporal.CalendarProtocol | undefined;\n  let disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>;\n  let offsetOpt: NonNullable<Temporal.OffsetDisambiguationOptions['offset']>;\n  let matchMinute = false;\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  if (IsObject(item)) {\n    if (IsTemporalZonedDateTime(item)) return item;\n    calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames: (keyof Temporal.ZonedDateTimeLike)[] = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    fieldNames.push('timeZone', 'offset');\n    const fields = PrepareTemporalFields(item, fieldNames, ['timeZone']);\n    timeZone = ToTemporalTimeZoneSlotValue(fields.timeZone);\n    offset = fields.offset;\n    if (offset === undefined) {\n      offsetBehaviour = 'wall';\n    }\n    disambiguation = ToTemporalDisambiguation(options);\n    offsetOpt = ToTemporalOffset(options, 'reject');\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      options\n    ));\n  } else {\n    let ianaName, z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n      ParseTemporalZonedDateTimeString(ToString(item)));\n    timeZone = ToTemporalTimeZoneSlotValue(ianaName);\n    if (z) {\n      offsetBehaviour = 'exact';\n    } else if (!offset) {\n      offsetBehaviour = 'wall';\n    }\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n    matchMinute = true; // ISO strings may specify offset with less precision\n    disambiguation = ToTemporalDisambiguation(options);\n    offsetOpt = ToTemporalOffset(options, 'reject');\n    ToTemporalOverflow(options); // validate and ignore\n  }\n  let offsetNs = 0;\n  // The code above guarantees that if offsetBehaviour === 'option', then\n  // `offset` is not undefined.\n  if (offsetBehaviour === 'option') offsetNs = ParseTimeZoneOffsetString(offset as string);\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    disambiguation,\n    offsetOpt,\n    matchMinute\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function CreateTemporalDateSlots(\n  result: Temporal.PlainDate,\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot\n) {\n  RejectISODate(isoYear, isoMonth, isoDay);\n  RejectDateRange(isoYear, isoMonth, isoDay);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, DATE_BRAND, true);\n\n  if (DEBUG) {\n    ObjectDefineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDate(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n  const result = ObjectCreate(TemporalPlainDate.prototype);\n  CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n  return result;\n}\n\nexport function CreateTemporalDateTimeSlots(\n  result: Temporal.PlainDateTime,\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number,\n  calendar: CalendarSlot\n) {\n  RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n  RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_HOUR, h);\n  SetSlot(result, ISO_MINUTE, min);\n  SetSlot(result, ISO_SECOND, s);\n  SetSlot(result, ISO_MILLISECOND, ms);\n  SetSlot(result, ISO_MICROSECOND, µs);\n  SetSlot(result, ISO_NANOSECOND, ns);\n  SetSlot(result, CALENDAR, calendar);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDateTime(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const result = ObjectCreate(TemporalPlainDateTime.prototype);\n  CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar);\n  return result as Temporal.PlainDateTime;\n}\n\nexport function CreateTemporalMonthDaySlots(\n  result: Temporal.PlainMonthDay,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot,\n  referenceISOYear: number\n) {\n  RejectISODate(referenceISOYear, isoMonth, isoDay);\n  RejectDateRange(referenceISOYear, isoMonth, isoDay);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_YEAR, referenceISOYear);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, MONTH_DAY_BRAND, true);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalMonthDay(\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot = 'iso8601',\n  referenceISOYear = 1972\n) {\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n  const result = ObjectCreate(TemporalPlainMonthDay.prototype);\n  CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n  return result;\n}\n\nexport function CreateTemporalYearMonthSlots(\n  result: Temporal.PlainYearMonth,\n  isoYear: number,\n  isoMonth: number,\n  calendar: CalendarSlot,\n  referenceISODay: number\n) {\n  RejectISODate(isoYear, isoMonth, referenceISODay);\n  RejectYearMonthRange(isoYear, isoMonth);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, referenceISODay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, YEAR_MONTH_BRAND, true);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalYearMonth(\n  isoYear: number,\n  isoMonth: number,\n  calendar: CalendarSlot = 'iso8601',\n  referenceISODay = 1\n) {\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n  const result = ObjectCreate(TemporalPlainYearMonth.prototype);\n  CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n  return result;\n}\n\nexport function CreateTemporalZonedDateTimeSlots(\n  result: Temporal.ZonedDateTime,\n  epochNanoseconds: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot\n) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n  SetSlot(result, TIME_ZONE, timeZone);\n  SetSlot(result, CALENDAR, calendar);\n\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n  SetSlot(result, INSTANT, instant);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalZonedDateTime(\n  epochNanoseconds: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n  const result = ObjectCreate(TemporalZonedDateTime.prototype);\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n  return result;\n}\n\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nexport function CalendarFields<K extends AnyTemporalKey>(calendar: CalendarSlot, fieldNamesParam: ReadonlyArray<K>) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.fields%'), calendarObj, [fieldNamesParam]) as K[];\n  }\n  const fields = GetMethod(calendar, 'fields');\n  const fieldNames = Call(fields, calendar, [fieldNamesParam]);\n  const result: K[] = [];\n  for (const name of fieldNames) {\n    if (typeof name !== 'string') throw new TypeError('bad return from calendar.fields()');\n    ArrayPrototypePush.call(result, name);\n  }\n  return result;\n}\n\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\n  calendar: CalendarSlot,\n  fields: Base,\n  additionalFields: ToAdd\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.mergeFields%'), calendarObj, [\n      fields,\n      additionalFields\n    ]) as Base & ToAdd;\n  }\n  const mergeFields = GetMethod(calendar, 'mergeFields');\n  const result = Call(mergeFields, calendar, [fields, additionalFields]);\n  if (!IsObject(result)) throw new TypeError('bad return from calendar.mergeFields()');\n  return result as Base & ToAdd;\n}\n\nexport function CalendarDateAdd(\n  calendar: CalendarSlot,\n  date: CalendarProtocolParams['dateAdd'][0],\n  duration: CalendarProtocolParams['dateAdd'][1],\n  options: CalendarProtocolParams['dateAdd'][2],\n  dateAddParam?: Temporal.CalendarProtocol['dateAdd'] | undefined\n) {\n  let dateAdd = dateAddParam;\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateAdd%'), calendarObj, [date, duration, options]);\n  }\n  if (dateAdd === undefined) {\n    dateAdd = GetMethod(calendar, 'dateAdd');\n  }\n  const result = ReflectApply(dateAdd, calendar, [date, duration, options]);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction CalendarDateUntil(\n  calendar: CalendarSlot,\n  date: CalendarProtocolParams['dateUntil'][0],\n  otherDate: CalendarProtocolParams['dateUntil'][1],\n  options: CalendarProtocolParams['dateUntil'][2],\n  dateUntilParam?: Temporal.CalendarProtocol['dateUntil'] | undefined\n) {\n  let dateUntil = dateUntilParam;\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateUntil%'), calendarObj, [date, otherDate, options]);\n  }\n  if (dateUntil === undefined) {\n    dateUntil = GetMethod(calendar, 'dateUntil');\n  }\n  const result = ReflectApply(dateUntil, calendar, [date, otherDate, options]);\n  if (!IsTemporalDuration(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['year'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.year%'), calendarObj, [dateLike]);\n  }\n  const year = GetMethod(calendar, 'year');\n  let result = Call(year, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar year result must be an integer');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar year result must be an integer');\n  }\n  return result;\n}\n\nexport function CalendarMonth(calendar: CalendarSlot, dateLike: CalendarProtocolParams['month'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.month%'), calendarObj, [dateLike]);\n  }\n  const month = GetMethod(calendar, 'month');\n  let result = Call(month, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar month result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar month result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarMonthCode(calendar: CalendarSlot, dateLike: CalendarProtocolParams['monthCode'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthCode%'), calendarObj, [dateLike]);\n  }\n  const monthCode = GetMethod(calendar, 'monthCode');\n  let result = Call(monthCode, calendar, [dateLike]);\n  if (typeof result !== 'string') {\n    throw new TypeError('calendar monthCode result must be a string');\n  }\n  return result;\n}\n\nexport function CalendarDay(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.day%'), calendarObj, [dateLike]);\n  }\n  const day = GetMethod(calendar, 'day');\n  const result = Call(day, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar day result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar day result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarEra(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.era%'), calendarObj, [dateLike]);\n  }\n  const era = GetMethod(calendar, 'era');\n  let result = Call(era, calendar, [dateLike]);\n  if (result === undefined) {\n    return result;\n  }\n  if (typeof result !== 'string') {\n    throw new TypeError('calendar era result must be a string or undefined');\n  }\n  return result;\n}\n\nexport function CalendarEraYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.eraYear%'), calendarObj, [dateLike]);\n  }\n  const eraYear = GetMethod(calendar, 'eraYear');\n  let result = Call(eraYear, calendar, [dateLike]);\n  if (result === undefined) {\n    return result;\n  }\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar eraYear result must be an integer or undefined');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar eraYear result must be an integer or undefined');\n  }\n  return result;\n}\n\nexport function CalendarDayOfWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dayOfWeek%'), calendarObj, [dateLike]);\n  }\n  const dayOfWeek = GetMethod(calendar, 'dayOfWeek');\n  const result = Call(dayOfWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar dayOfWeek result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar dayOfWeek result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDayOfYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dayOfYear%'), calendarObj, [dateLike]);\n  }\n  const dayOfYear = GetMethod(calendar, 'dayOfYear');\n  const result = Call(dayOfYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar dayOfYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar dayOfYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarWeekOfYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.weekOfYear%'), calendarObj, [dateLike]);\n  }\n  const weekOfYear = GetMethod(calendar, 'weekOfYear');\n  const result = Call(weekOfYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar weekOfYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar weekOfYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarYearOfWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.yearOfWeek%'), calendarObj, [dateLike]);\n  }\n  const yearOfWeek = GetMethod(calendar, 'yearOfWeek');\n  const result = Call(yearOfWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar yearOfWeek result must be an integer');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar yearOfWeek result must be an integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInWeek%'), calendarObj, [dateLike]);\n  }\n  const daysInWeek = GetMethod(calendar, 'daysInWeek');\n  const result = Call(daysInWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInWeek result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInWeek result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInMonth(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInMonth%'), calendarObj, [dateLike]);\n  }\n  const daysInMonth = GetMethod(calendar, 'daysInMonth');\n  const result = Call(daysInMonth, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInMonth result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInMonth result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInYear%'), calendarObj, [dateLike]);\n  }\n  const daysInYear = GetMethod(calendar, 'daysInYear');\n  const result = Call(daysInYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarMonthsInYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthsInYear%'), calendarObj, [dateLike]);\n  }\n  const monthsInYear = GetMethod(calendar, 'monthsInYear');\n  const result = Call(monthsInYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar monthsInYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar monthsInYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarInLeapYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.inLeapYear%'), calendarObj, [dateLike]);\n  }\n  const inLeapYear = GetMethod(calendar, 'inLeapYear');\n  const result = Call(inLeapYear, calendar, [dateLike]);\n  if (typeof result !== 'boolean') {\n    throw new TypeError('calendar inLeapYear result must be a boolean');\n  }\n  return result;\n}\n\ntype MaybeCalendarProtocol = Partial<Omit<Temporal.CalendarProtocol, 'toString' | 'toJSON'>>;\nfunction ObjectImplementsTemporalCalendarProtocol(object: MaybeCalendarProtocol) {\n  if (IsTemporalCalendar(object)) return true;\n  return (\n    'dateAdd' in object &&\n    'dateFromFields' in object &&\n    'dateUntil' in object &&\n    'day' in object &&\n    'dayOfWeek' in object &&\n    'dayOfYear' in object &&\n    'daysInMonth' in object &&\n    'daysInWeek' in object &&\n    'daysInYear' in object &&\n    'fields' in object &&\n    'id' in object &&\n    'inLeapYear' in object &&\n    'mergeFields' in object &&\n    'month' in object &&\n    'monthCode' in object &&\n    'monthDayFromFields' in object &&\n    'monthsInYear' in object &&\n    'weekOfYear' in object &&\n    'year' in object &&\n    'yearMonthFromFields' in object &&\n    'yearOfWeek' in object\n  );\n}\n\nexport function ToTemporalCalendarSlotValue(calendarLike: string): string;\nexport function ToTemporalCalendarSlotValue(calendarLike: Temporal.CalendarProtocol): Temporal.CalendarProtocol;\nexport function ToTemporalCalendarSlotValue(calendarLike: Temporal.CalendarLike): string | Temporal.CalendarProtocol;\nexport function ToTemporalCalendarSlotValue(calendarLike: CalendarParams['from'][0]) {\n  if (IsObject(calendarLike)) {\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\n    if (!ObjectImplementsTemporalCalendarProtocol(calendarLike)) {\n      throw new TypeError('expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol');\n    }\n    return calendarLike;\n  }\n  const identifier = ToString(calendarLike);\n  if (IsBuiltinCalendar(identifier)) return ASCIILowercase(identifier);\n  let calendar;\n  try {\n    ({ calendar } = ParseISODateTime(identifier));\n  } catch {\n    try {\n      ({ calendar } = ParseTemporalYearMonthString(identifier));\n    } catch {\n      ({ calendar } = ParseTemporalMonthDayString(identifier));\n    }\n  }\n  if (!calendar) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  return ASCIILowercase(calendar);\n}\n\nfunction GetTemporalCalendarSlotValueWithISODefault(item: { calendar?: Temporal.CalendarLike }): CalendarSlot {\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\n  const { calendar } = item;\n  if (calendar === undefined) return 'iso8601';\n  return ToTemporalCalendarSlotValue(calendar);\n}\n\nexport function ToTemporalCalendarIdentifier(slotValue: CalendarSlot) {\n  if (typeof slotValue === 'string') return slotValue;\n  const result = slotValue.id;\n  if (typeof result !== 'string') throw new TypeError('calendar.id should be a string');\n  return result;\n}\n\nexport function ToTemporalCalendarObject(slotValue: CalendarSlot) {\n  if (IsObject(slotValue)) return slotValue;\n  const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n  return new TemporalCalendar(slotValue);\n}\n\nexport function CalendarEquals(one: CalendarSlot, two: CalendarSlot) {\n  if (one === two) return true;\n  const cal1 = ToTemporalCalendarIdentifier(one);\n  const cal2 = ToTemporalCalendarIdentifier(two);\n  return cal1 === cal2;\n}\n\n// This operation is not in the spec, it implements the following:\n// \"If ? CalendarEquals(one, two) is false, throw a RangeError exception.\"\n// This is so that we can build an informative error message without\n// re-getting the .id properties.\nfunction ThrowIfCalendarsNotEqual(one: CalendarSlot, two: CalendarSlot, errorMessageAction: string) {\n  if (one === two) return;\n  const cal1 = ToTemporalCalendarIdentifier(one);\n  const cal2 = ToTemporalCalendarIdentifier(two);\n  if (cal1 !== cal2) {\n    throw new RangeError(`cannot ${errorMessageAction} of ${cal1} and ${cal2} calendars`);\n  }\n}\n\nexport function ConsolidateCalendars(one: CalendarSlot, two: CalendarSlot) {\n  if (one === two) return two;\n  const sOne = ToTemporalCalendarIdentifier(one);\n  const sTwo = ToTemporalCalendarIdentifier(two);\n  if (sOne === sTwo || sOne === 'iso8601') {\n    return two;\n  } else if (sTwo === 'iso8601') {\n    return one;\n  } else {\n    throw new RangeError('irreconcilable calendars');\n  }\n}\n\nexport function CalendarDateFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['dateFromFields'][0],\n  options?: Partial<CalendarProtocolParams['dateFromFields'][1]>,\n  dateFromFieldsParam?: Temporal.CalendarProtocol['dateFromFields']\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateFromFields%'), calendarObj, [fields, options]);\n  }\n  const dateFromFields = dateFromFieldsParam ?? GetMethod(calendar, 'dateFromFields');\n  const result = Call(dateFromFields, calendar, [fields, options]);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarYearMonthFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['yearMonthFromFields'][0],\n  options?: CalendarProtocolParams['yearMonthFromFields'][1]\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.yearMonthFromFields%'), calendarObj, [fields, options]);\n  }\n  const yearMonthFromFields = GetMethod(calendar, 'yearMonthFromFields');\n  let result = Call(yearMonthFromFields, calendar, [fields, options]);\n  if (!IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarMonthDayFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['monthDayFromFields'][0],\n  options?: CalendarProtocolParams['monthDayFromFields'][1]\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthDayFromFields%'), calendarObj, [fields, options]);\n  }\n  const monthDayFromFields = GetMethod(calendar, 'monthDayFromFields');\n  let result = Call(monthDayFromFields, calendar, [fields, options]);\n  if (!IsTemporalMonthDay(result)) throw new TypeError('invalid result');\n  return result;\n}\n\ntype MaybeTimeZoneProtocol = Partial<\n  Pick<Temporal.TimeZoneProtocol, 'getOffsetNanosecondsFor' | 'getPossibleInstantsFor'>\n>;\nfunction ObjectImplementsTemporalTimeZoneProtocol(object: MaybeTimeZoneProtocol) {\n  if (IsTemporalTimeZone(object)) return true;\n  return 'getOffsetNanosecondsFor' in object && 'getPossibleInstantsFor' in object && 'id' in object;\n}\n\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: string): string;\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: Temporal.TimeZoneProtocol): Temporal.TimeZoneProtocol;\nexport function ToTemporalTimeZoneSlotValue(\n  temporalTimeZoneLike: Temporal.TimeZoneLike\n): string | Temporal.TimeZoneProtocol;\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: TimeZoneParams['from'][0]) {\n  if (IsObject(temporalTimeZoneLike)) {\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n    if (!ObjectImplementsTemporalTimeZoneProtocol(temporalTimeZoneLike)) {\n      throw new TypeError('expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol');\n    }\n    return temporalTimeZoneLike;\n  }\n  const identifier = ToString(temporalTimeZoneLike);\n  return ParseTemporalTimeZone(identifier);\n}\n\nexport function ToTemporalTimeZoneIdentifier(slotValue: TimeZoneSlot) {\n  if (typeof slotValue === 'string') return slotValue;\n  const result = slotValue.id;\n  if (typeof result !== 'string') throw new TypeError('timeZone.id should be a string');\n  return result;\n}\n\nexport function ToTemporalTimeZoneObject(slotValue: TimeZoneSlot) {\n  if (IsObject(slotValue)) return slotValue;\n  const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n  return new TemporalTimeZone(slotValue);\n}\n\nexport function TimeZoneEquals(one: string | Temporal.TimeZoneProtocol, two: string | Temporal.TimeZoneProtocol) {\n  if (one === two) return true;\n  const tz1 = ToTemporalTimeZoneIdentifier(one);\n  const tz2 = ToTemporalTimeZoneIdentifier(two);\n  return tz1 === tz2;\n}\n\nexport function TemporalDateTimeToDate(dateTime: Temporal.PlainDateTime) {\n  return CreateTemporalDate(\n    GetSlot(dateTime, ISO_YEAR),\n    GetSlot(dateTime, ISO_MONTH),\n    GetSlot(dateTime, ISO_DAY),\n    GetSlot(dateTime, CALENDAR)\n  );\n}\n\nexport function TemporalDateTimeToTime(dateTime: Temporal.PlainDateTime) {\n  const Time = GetIntrinsic('%Temporal.PlainTime%');\n  return new Time(\n    GetSlot(dateTime, ISO_HOUR),\n    GetSlot(dateTime, ISO_MINUTE),\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND)\n  );\n}\n\nexport function GetOffsetNanosecondsFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  instant: TimeZoneProtocolParams['getOffsetNanosecondsFor'][0],\n  getOffsetNanosecondsForParam?: Temporal.TimeZoneProtocol['getOffsetNanosecondsFor']\n) {\n  if (typeof timeZone === 'string') {\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    const timeZoneObject = new TemporalTimeZone(timeZone);\n    return Call(GetIntrinsic('%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%'), timeZoneObject, [instant]);\n  }\n  const getOffsetNanosecondsFor = getOffsetNanosecondsForParam ?? GetMethod(timeZone, 'getOffsetNanosecondsFor');\n  const offsetNs = Call(getOffsetNanosecondsFor, timeZone, [instant]);\n  if (typeof offsetNs !== 'number') {\n    throw new TypeError('bad return from getOffsetNanosecondsFor');\n  }\n  if (!IsIntegralNumber(offsetNs) || MathAbs(offsetNs) >= 86400e9) {\n    throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n  }\n  return offsetNs;\n}\n\nexport function GetOffsetStringFor(timeZone: string | Temporal.TimeZoneProtocol, instant: Temporal.Instant) {\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  return FormatTimeZoneOffsetString(offsetNs);\n}\n\nexport function GetPlainDateTimeFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  instant: Temporal.Instant,\n  calendar: CalendarSlot\n) {\n  const ns = GetSlot(instant, EPOCHNANOSECONDS);\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n  ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond + offsetNs\n  ));\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function GetInstantFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: Temporal.PlainDateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n  return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\n\nfunction DisambiguatePossibleInstants(\n  possibleInstants: Temporal.Instant[],\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: Temporal.PlainDateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  const numInstants = possibleInstants.length;\n\n  if (numInstants === 1) return possibleInstants[0];\n  if (numInstants) {\n    switch (disambiguation) {\n      case 'compatible':\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n      case 'earlier':\n        return possibleInstants[0];\n      case 'later':\n        return possibleInstants[numInstants - 1];\n      case 'reject': {\n        throw new RangeError('multiple instants found');\n      }\n    }\n  }\n\n  const year = GetSlot(dateTime, ISO_YEAR);\n  const month = GetSlot(dateTime, ISO_MONTH);\n  const day = GetSlot(dateTime, ISO_DAY);\n  const hour = GetSlot(dateTime, ISO_HOUR);\n  const minute = GetSlot(dateTime, ISO_MINUTE);\n  const second = GetSlot(dateTime, ISO_SECOND);\n  const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n  const utcns = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (utcns === null) throw new RangeError('DateTime outside of supported range');\n  const dayBefore = new Instant(JSBI.subtract(utcns, DAY_NANOS));\n  const dayAfter = new Instant(JSBI.add(utcns, DAY_NANOS));\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n  const nanoseconds = offsetAfter - offsetBefore;\n  switch (disambiguation) {\n    case 'earlier': {\n      const calendar = GetSlot(dateTime, CALENDAR);\n      const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n      const earlier = AddDateTime(\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        calendar,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -nanoseconds,\n        undefined\n      );\n      const earlierPlainDateTime = new PlainDateTime(\n        earlier.year,\n        earlier.month,\n        earlier.day,\n        earlier.hour,\n        earlier.minute,\n        earlier.second,\n        earlier.millisecond,\n        earlier.microsecond,\n        earlier.nanosecond,\n        calendar\n      );\n      return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n    }\n    case 'compatible':\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n    case 'later': {\n      const calendar = GetSlot(dateTime, CALENDAR);\n      const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n      const later = AddDateTime(\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        calendar,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        nanoseconds,\n        undefined\n      );\n      const laterPlainDateTime = new PlainDateTime(\n        later.year,\n        later.month,\n        later.day,\n        later.hour,\n        later.minute,\n        later.second,\n        later.millisecond,\n        later.microsecond,\n        later.nanosecond,\n        calendar\n      );\n      const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n      return possible[possible.length - 1];\n    }\n    case 'reject': {\n      throw new RangeError('no such instant found');\n    }\n  }\n}\n\nfunction GetPossibleInstantsFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: TimeZoneProtocolParams['getPossibleInstantsFor'][0],\n  getPossibleInstantsForParam?: Temporal.TimeZoneProtocol['getPossibleInstantsFor']\n) {\n  if (typeof timeZone === 'string') {\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    const timeZoneObject = new TemporalTimeZone(timeZone);\n    return Call(GetIntrinsic('%Temporal.TimeZone.prototype.getPossibleInstantsFor%'), timeZoneObject, [dateTime]);\n  }\n  const getPossibleInstantsFor = getPossibleInstantsForParam ?? GetMethod(timeZone, 'getPossibleInstantsFor');\n  const possibleInstants = Call(getPossibleInstantsFor, timeZone, [dateTime]);\n  const result: Temporal.Instant[] = [];\n  for (const instant of possibleInstants) {\n    if (!IsTemporalInstant(instant)) {\n      throw new TypeError('bad return from getPossibleInstantsFor');\n    }\n    ArrayPrototypePush.call(result, instant);\n  }\n  return result;\n}\n\nexport function ISOYearString(year: number) {\n  let yearString;\n  if (year < 0 || year > 9999) {\n    const sign = year < 0 ? '-' : '+';\n    const yearNumber = MathAbs(year);\n    yearString = sign + `000000${yearNumber}`.slice(-6);\n  } else {\n    yearString = `0000${year}`.slice(-4);\n  }\n  return yearString;\n}\n\nexport function ISODateTimePartString(part: number) {\n  return `00${part}`.slice(-2);\n}\nexport function FormatSecondsStringPart(\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision']\n) {\n  if (precision === 'minute') return '';\n\n  const secs = `:${ISODateTimePartString(second)}`;\n  let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  let fraction: string;\n\n  if (precision === 'auto') {\n    if (fractionNumber === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0');\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n  } else {\n    if (precision === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n  }\n  return `${secs}.${fraction}`;\n}\n\nexport function TemporalInstantToString(\n  instant: Temporal.Instant,\n  timeZone: string | Temporal.TimeZoneProtocol | undefined,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision']\n) {\n  let outputTimeZone = timeZone;\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\n  const dateTime = GetPlainDateTimeFor(outputTimeZone, instant, 'iso8601');\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    precision\n  );\n  let timeZoneString = 'Z';\n  if (timeZone !== undefined) {\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n    timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n  }\n  return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\n\ninterface ToStringOptions {\n  unit: ReturnType<typeof ToSecondsStringPrecisionRecord>['unit'];\n  increment: number;\n  roundingMode: ReturnType<typeof ToTemporalRoundingMode>;\n}\n\nexport function TemporalDurationToString(\n  duration: Temporal.Duration,\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  function formatNumber(num: number) {\n    if (num <= NumberMaxSafeInteger) return num.toString(10);\n    return JSBI.BigInt(num).toString(10);\n  }\n\n  const years = GetSlot(duration, YEARS);\n  const months = GetSlot(duration, MONTHS);\n  const weeks = GetSlot(duration, WEEKS);\n  const days = GetSlot(duration, DAYS);\n  const hours = GetSlot(duration, HOURS);\n  const minutes = GetSlot(duration, MINUTES);\n  let seconds = GetSlot(duration, SECONDS);\n  let ms = GetSlot(duration, MILLISECONDS);\n  let µs = GetSlot(duration, MICROSECONDS);\n  let ns = GetSlot(duration, NANOSECONDS);\n  const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, µs, ns);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({\n      seconds,\n      milliseconds: ms,\n      microseconds: µs,\n      nanoseconds: ns\n    } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, µs, ns, increment, unit, roundingMode));\n  }\n\n  const dateParts: string[] = [];\n  if (years) dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n  if (months) dateParts.push(`${formatNumber(MathAbs(months))}M`);\n  if (weeks) dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n  if (days) dateParts.push(`${formatNumber(MathAbs(days))}D`);\n\n  const timeParts: string[] = [];\n  if (hours) timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n  if (minutes) timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n\n  const secondParts: string[] = [];\n  let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, µs, ns, 0);\n  let nsBigInt: JSBI, µsBigInt: JSBI, msBigInt: JSBI, secondsBigInt: JSBI;\n  ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n  ({ quotient: total, remainder: µsBigInt } = divmod(total, THOUSAND));\n  ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n  const fraction =\n    MathAbs(JSBI.toNumber(msBigInt)) * 1e6 + MathAbs(JSBI.toNumber(µsBigInt)) * 1e3 + MathAbs(JSBI.toNumber(nsBigInt));\n  let decimalPart;\n  if (precision === 'auto') {\n    if (fraction !== 0) {\n      decimalPart = `${fraction}`.padStart(9, '0');\n      while (decimalPart[decimalPart.length - 1] === '0') {\n        decimalPart = decimalPart.slice(0, -1);\n      }\n    }\n  } else if (precision !== 0) {\n    decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n  }\n  if (decimalPart) secondParts.unshift('.', decimalPart);\n  if (!JSBI.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n    secondParts.unshift(abs(secondsBigInt).toString());\n  }\n  if (secondParts.length) timeParts.push(`${secondParts.join('')}S`);\n  if (timeParts.length) timeParts.unshift('T');\n  if (!dateParts.length && !timeParts.length) return 'PT0S';\n  return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\n\nexport function TemporalDateToString(\n  date: Temporal.PlainDate,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const year = ISOYearString(GetSlot(date, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n  const calendar = MaybeFormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\n  return `${year}-${month}-${day}${calendar}`;\n}\n\nexport function TemporalDateTimeToString(\n  dateTime: Temporal.PlainDateTime,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision'],\n  showCalendar: ReturnType<typeof ToCalendarNameOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let year = GetSlot(dateTime, ISO_YEAR);\n  let month = GetSlot(dateTime, ISO_MONTH);\n  let day = GetSlot(dateTime, ISO_DAY);\n  let hour = GetSlot(dateTime, ISO_HOUR);\n  let minute = GetSlot(dateTime, ISO_MINUTE);\n  let second = GetSlot(dateTime, ISO_SECOND);\n  let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      increment,\n      unit,\n      roundingMode\n    ));\n  }\n\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const hourString = ISODateTimePartString(hour);\n  const minuteString = ISODateTimePartString(minute);\n  const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  const calendar = MaybeFormatCalendarAnnotation(GetSlot(dateTime, CALENDAR), showCalendar);\n  return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\n\nexport function TemporalMonthDayToString(\n  monthDay: Temporal.PlainMonthDay,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n  let resultString = `${month}-${day}`;\n  const calendar = GetSlot(monthDay, CALENDAR);\n  const calendarID = ToTemporalCalendarIdentifier(calendar);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendarID !== 'iso8601') {\n    const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n    resultString = `${year}-${resultString}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalYearMonthToString(\n  yearMonth: Temporal.PlainYearMonth,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n  let resultString = `${year}-${month}`;\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const calendarID = ToTemporalCalendarIdentifier(calendar);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendarID !== 'iso8601') {\n    const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n    resultString += `-${day}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalZonedDateTimeToString(\n  zdt: Temporal.ZonedDateTime,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision'],\n  showCalendar: ReturnType<typeof ToCalendarNameOption> = 'auto',\n  showTimeZone: ReturnType<typeof ToTimeZoneNameOption> = 'auto',\n  showOffset: ReturnType<typeof ToShowOffsetOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let instant = GetSlot(zdt, INSTANT);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    instant = new TemporalInstant(ns);\n  }\n\n  const tz = GetSlot(zdt, TIME_ZONE);\n  const dateTime = GetPlainDateTimeFor(tz, instant, 'iso8601');\n\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    precision\n  );\n  let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n  if (showOffset !== 'never') {\n    const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n    result += FormatISOTimeZoneOffsetString(offsetNs);\n  }\n  if (showTimeZone !== 'never') {\n    const identifier = ToTemporalTimeZoneIdentifier(tz);\n    const flag = showTimeZone === 'critical' ? '!' : '';\n    result += `[${flag}${identifier}]`;\n  }\n  result += MaybeFormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\n  return result;\n}\n\nexport function IsTimeZoneOffsetString(string: string) {\n  return OFFSET.test(StringCtor(string));\n}\n\nexport function ParseTimeZoneOffsetString(string: string): number {\n  const match = OFFSET.exec(StringCtor(string));\n  if (!match) {\n    throw new RangeError(`invalid time zone offset: ${string}`);\n  }\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n  const hours = +match[2];\n  const minutes = +(match[3] || 0);\n  const seconds = +(match[4] || 0);\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n  return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\n\nexport function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier: string): string {\n  if (IsTimeZoneOffsetString(timeZoneIdentifier)) {\n    const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n    return FormatTimeZoneOffsetString(offsetNs);\n  }\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n  return formatter.resolvedOptions().timeZone;\n}\n\nexport function GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: JSBI) {\n  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n    GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. To avoid overflowing at the edges of the range, we reduce the year\n  // to the remainder after dividing by 400, and then add back all the\n  // nanoseconds from the multiples of 400 years at the end.\n  const reducedYear = year % 400;\n  const yearCycles = (year - reducedYear) / 400;\n  const nsIn400YearCycle = JSBI.multiply(JSBI.BigInt(400 * 365 + 97), DAY_NANOS);\n\n  const reducedUTC = GetUTCEpochNanoseconds(\n    reducedYear,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  );\n  assertExists(reducedUTC);\n  const utc = JSBI.add(reducedUTC, JSBI.multiply(nsIn400YearCycle, JSBI.BigInt(yearCycles)));\n  return JSBI.toNumber(JSBI.subtract(utc, epochNanoseconds));\n}\n\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam: number): string {\n  const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n  const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n  const nanoseconds = offsetNanoseconds % 1e9;\n  const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n  const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  const secondString = ISODateTimePartString(seconds);\n  let post = '';\n  if (nanoseconds) {\n    let fraction = `${nanoseconds}`.padStart(9, '0');\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n    post = `:${secondString}.${fraction}`;\n  } else if (seconds) {\n    post = `:${secondString}`;\n  }\n  return `${sign}${hourString}:${minuteString}${post}`;\n}\n\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam: number): string {\n  let offsetNanoseconds = JSBI.toNumber(\n    RoundNumberToIncrement(JSBI.BigInt(offsetNanosecondsParam), MINUTE_NANOS, 'halfExpand')\n  );\n  const sign = offsetNanoseconds < 0 ? '-' : '+';\n  offsetNanoseconds = MathAbs(offsetNanoseconds);\n  const minutes = (offsetNanoseconds / 60e9) % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  return `${sign}${hourString}:${minuteString}`;\n}\nexport function GetUTCEpochNanoseconds(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  // Note: Date.UTC() interprets one and two-digit years as being in the\n  // 20th century, so don't use it\n  const legacyDate = new Date();\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\n  legacyDate.setUTCFullYear(year, month - 1, day);\n  const ms = legacyDate.getTime();\n  if (NumberIsNaN(ms)) return null;\n  let ns = JSBI.multiply(JSBI.BigInt(ms), MILLION);\n  ns = JSBI.add(ns, JSBI.multiply(JSBI.BigInt(microsecond), THOUSAND));\n  ns = JSBI.add(ns, JSBI.BigInt(nanosecond));\n  if (JSBI.lessThan(ns, NS_MIN) || JSBI.greaterThan(ns, NS_MAX)) return null;\n  return ns;\n}\n\nfunction GetISOPartsFromEpoch(epochNanoseconds: JSBI) {\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n  let epochMilliseconds = JSBI.toNumber(quotient);\n  let nanos = JSBI.toNumber(remainder);\n  if (nanos < 0) {\n    nanos += 1e6;\n    epochMilliseconds -= 1;\n  }\n  const microsecond = MathFloor(nanos / 1e3) % 1e3;\n  const nanosecond = nanos % 1e3;\n\n  const item = new Date(epochMilliseconds);\n  const year = item.getUTCFullYear();\n  const month = item.getUTCMonth() + 1;\n  const day = item.getUTCDate();\n  const hour = item.getUTCHours();\n  const minute = item.getUTCMinutes();\n  const second = item.getUTCSeconds();\n  const millisecond = item.getUTCMilliseconds();\n\n  return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: JSBI) {\n  const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction maxJSBI(one: JSBI, two: JSBI) {\n  return JSBI.lessThan(one, two) ? two : one;\n}\n\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n  return JSBI.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\n\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  if (JSBI.lessThan(epochNanoseconds, BEFORE_FIRST_OFFSET_TRANSITION)) {\n    return GetNamedTimeZoneNextTransition(id, BEFORE_FIRST_OFFSET_TRANSITION);\n  }\n  // Decide how far in the future after `epochNanoseconds` we'll look for an\n  // offset change. There are two cases:\n  // 1. If it's a past date (or a date in the near future) then it's possible\n  //    that the time zone may have newly added DST in the next few years. So\n  //    we'll have to look from the provided time until a few years after the\n  //    current system time. (Changes to DST policy are usually announced a few\n  //    years in the future.) Note that the first DST anywhere started in 1847,\n  //    so we'll start checks in 1847 instead of wasting cycles on years where\n  //    there will never be transitions.\n  // 2. If it's a future date beyond the next few years, then we'll just assume\n  //    that the latest DST policy in TZDB will still be in effect.  In this\n  //    case, we only need to look one year in the future to see if there are\n  //    any DST transitions.  We actually only need to look 9-10 months because\n  //    DST has two transitions per year, but we'll use a year just to be safe.\n  const oneYearLater = JSBI.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n  const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n  // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n  // start there if an earlier date is supplied.\n  let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n  const leftOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, leftNanos);\n  let rightNanos = leftNanos;\n  let rightOffsetNs = leftOffsetNs;\n  while (leftOffsetNs === rightOffsetNs && JSBI.lessThan(JSBI.BigInt(leftNanos), uppercap)) {\n    rightNanos = JSBI.add(leftNanos, TWO_WEEKS_NANOS);\n    if (JSBI.greaterThan(rightNanos, NS_MAX)) return null;\n    rightOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, rightNanos);\n    if (leftOffsetNs === rightOffsetNs) {\n      leftNanos = rightNanos;\n    }\n  }\n  if (leftOffsetNs === rightOffsetNs) return null;\n  const result = bisect(\n    (epochNs: JSBI) => GetNamedTimeZoneOffsetNanoseconds(id, epochNs),\n    leftNanos,\n    rightNanos,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return result;\n}\n\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n  // have to look back one year to find a transition. But if it doesn't use DST,\n  // then we need to look all the way back to 1847 (the earliest rule in the\n  // TZDB) to see if it had other offset transitions in the past. Looping back\n  // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n  // also unnecessary because DST rules aren't put into the TZDB more than a few\n  // years in the future because the political changes in time zones happen with\n  // only a few years' warning. Therefore, if a far-future date is provided,\n  // then we'll run the check in two parts:\n  // 1. First, we'll look back for up to one year to see if the latest TZDB\n  //    rules have DST.\n  // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n  //    current system time, and then look back to 1847. This reduces the\n  //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n  //    in worst-case perf.\n  const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n  const isFarFuture = JSBI.greaterThan(epochNanoseconds, afterLatestRule);\n  const lowercap = isFarFuture ? JSBI.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n\n  // TODO: proposal-temporal polyfill has different code for very similar\n  // optimizations as above, as well as in GetNamedTimeZonePreviousTransition.\n  // We should figure out if we should change one polyfill to match the other.\n\n  // We assume most time zones either have regular DST rules that extend\n  // indefinitely into the future, or they have no DST transitions between now\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\n  // that fit neither of these. Their irregular DST transitions are\n  // precomputed until 2087 in the current time zone database, so requesting\n  // the previous transition for an instant far in the future may take an\n  // extremely long time as it loops backward 2 weeks at a time.\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\n    const lastPrecomputed = GetSlot(ToTemporalInstant('2088-01-01T00Z'), EPOCHNANOSECONDS);\n    if (JSBI.lessThan(lastPrecomputed, epochNanoseconds)) {\n      return GetNamedTimeZonePreviousTransition(id, lastPrecomputed);\n    }\n  }\n\n  let rightNanos = JSBI.subtract(epochNanoseconds, ONE);\n  if (JSBI.lessThan(rightNanos, BEFORE_FIRST_OFFSET_TRANSITION)) return null;\n  const rightOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, rightNanos);\n  let leftNanos = rightNanos;\n  let leftOffsetNs = rightOffsetNs;\n  while (rightOffsetNs === leftOffsetNs && JSBI.greaterThan(rightNanos, lowercap)) {\n    leftNanos = JSBI.subtract(rightNanos, TWO_WEEKS_NANOS);\n    if (JSBI.lessThan(leftNanos, BEFORE_FIRST_OFFSET_TRANSITION)) return null;\n    leftOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, leftNanos);\n    if (rightOffsetNs === leftOffsetNs) {\n      rightNanos = leftNanos;\n    }\n  }\n  if (rightOffsetNs === leftOffsetNs) {\n    if (isFarFuture) {\n      // There was no DST after looking back one year, which means that the most\n      // recent TZDB rules don't have any recurring transitions. To check for\n      // transitions in older rules, back up to a few years after the current\n      // date and then look all the way back to 1847. Note that we move back one\n      // day from the latest possible rule so that when the recursion runs it\n      // won't consider the new time to be \"far future\" because the system clock\n      // has advanced in the meantime.\n      const newTimeToCheck = JSBI.subtract(afterLatestRule, DAY_NANOS);\n      return GetNamedTimeZonePreviousTransition(id, newTimeToCheck);\n    }\n    return null;\n  }\n  const result = bisect(\n    (epochNs: JSBI) => GetNamedTimeZoneOffsetNanoseconds(id, epochNs),\n    leftNanos,\n    rightNanos,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime: string) {\n  const parts = datetime.split(/[^\\w]+/);\n\n  if (parts.length !== 7) {\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\n  }\n\n  const month = +parts[0];\n  const day = +parts[1];\n  let year = +parts[2];\n  const era = parts[3].toUpperCase();\n  if (era === 'B' || era === 'BC') {\n    year = -year + 1;\n  } else if (era !== 'A' && era !== 'AD') {\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n  }\n  let hour = +parts[4];\n  if (hour === 24) {\n    // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n    hour = 0;\n  }\n  const minute = +parts[5];\n  const second = +parts[6];\n\n  if (\n    !NumberIsFinite(year) ||\n    !NumberIsFinite(month) ||\n    !NumberIsFinite(day) ||\n    !NumberIsFinite(hour) ||\n    !NumberIsFinite(minute) ||\n    !NumberIsFinite(second)\n  ) {\n    throw new RangeError(`Invalid number in \"${datetime}`);\n  }\n\n  return { year, month, day, hour, minute, second };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n  // Using `format` instead of `formatToParts` for compatibility with older clients\n  const datetime = formatter.format(new Date(epochMilliseconds));\n  return parseFromEnUsFormat(datetime);\n}\n\nexport function GetNamedTimeZoneEpochNanoseconds(\n  id: string,\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  const ns = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (ns === null) throw new RangeError('DateTime outside of supported range');\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS);\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\n  let nsLater = JSBI.add(ns, DAY_NANOS);\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\n  const earliest = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\n  const latest = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\n  const found = earliest === latest ? [earliest] : [earliest, latest];\n  return found\n    .map((offsetNanoseconds) => {\n      const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n      const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n      if (\n        year !== parts.year ||\n        month !== parts.month ||\n        day !== parts.day ||\n        hour !== parts.hour ||\n        minute !== parts.minute ||\n        second !== parts.second ||\n        millisecond !== parts.millisecond ||\n        microsecond !== parts.microsecond ||\n        nanosecond !== parts.nanosecond\n      ) {\n        return undefined;\n      }\n      return epochNanoseconds;\n    })\n    .filter((x) => x !== undefined) as JSBI[];\n}\n\nexport function LeapYear(year: number) {\n  if (undefined === year) return false;\n  const isDiv4 = year % 4 === 0;\n  const isDiv100 = year % 100 === 0;\n  const isDiv400 = year % 400 === 0;\n  return isDiv4 && (!isDiv100 || isDiv400);\n}\n\nexport function ISODaysInMonth(year: number, month: number) {\n  const DoM = {\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  };\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\n\nexport function DayOfWeek(year: number, month: number, day: number) {\n  const m = month + (month < 3 ? 10 : -2);\n  const Y = year - (month < 3 ? 1 : 0);\n\n  const c = MathFloor(Y / 100);\n  const y = Y - c * 100;\n  const d = day;\n\n  const pD = d;\n  const pM = MathFloor(2.6 * m - 0.2);\n  const pY = y + MathFloor(y / 4);\n  const pC = MathFloor(c / 4) - 2 * c;\n\n  const dow = (pD + pM + pY + pC) % 7;\n\n  return dow + (dow <= 0 ? 7 : 0);\n}\n\nexport function DayOfYear(year: number, month: number, day: number) {\n  let days = day;\n  for (let m = month - 1; m > 0; m--) {\n    days += ISODaysInMonth(year, m);\n  }\n  return days;\n}\n\nexport function WeekOfYear(year: number, month: number, day: number) {\n  const doy = DayOfYear(year, month, day);\n  const dow = DayOfWeek(year, month, day) || 7;\n  const doj = DayOfWeek(year, 1, 1);\n\n  const week = MathFloor((doy - dow + 10) / 7);\n\n  if (week < 1) {\n    if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n      return { week: 53, year: year - 1 };\n    } else {\n      return { week: 52, year: year - 1 };\n    }\n  }\n  if (week === 53) {\n    if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n      return { week: 1, year: year + 1 };\n    }\n  }\n\n  return { week, year };\n}\n\nexport function DurationSign(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n  return 0;\n}\n\nfunction BalanceISOYearMonth(yearParam: number, monthParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  if (!NumberIsFinite(year) || !NumberIsFinite(month)) throw new RangeError('infinity is out of range');\n  month -= 1;\n  year += MathFloor(month / 12);\n  month %= 12;\n  if (month < 0) month += 12;\n  month += 1;\n  return { year, month };\n}\n\nfunction BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  if (!NumberIsFinite(day)) throw new RangeError('infinity is out of range');\n  ({ year, month } = BalanceISOYearMonth(year, month));\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. So if we have more than 400 years in days, there's no need to\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\n  // once.\n  const daysIn400YearCycle = 400 * 365 + 97;\n  if (MathAbs(day) > daysIn400YearCycle) {\n    const nCycles = MathTrunc(day / daysIn400YearCycle);\n    year += 400 * nCycles;\n    day -= nCycles * daysIn400YearCycle;\n  }\n\n  let daysInYear = 0;\n  let testYear = month > 2 ? year : year - 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n    year -= 1;\n    testYear -= 1;\n    day += daysInYear;\n  }\n  testYear += 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n    year += 1;\n    testYear += 1;\n    day -= daysInYear;\n  }\n\n  while (day < 1) {\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\n    day += ISODaysInMonth(year, month);\n  }\n  while (day > ISODaysInMonth(year, month)) {\n    day -= ISODaysInMonth(year, month);\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\n  }\n\n  return { year, month, day };\n}\n\nfunction BalanceISODateTime(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam\n  );\n  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nfunction BalanceTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  let hour = JSBI.BigInt(hourParam);\n  let minute = JSBI.BigInt(minuteParam);\n  let second = JSBI.BigInt(secondParam);\n  let millisecond = JSBI.BigInt(millisecondParam);\n  let microsecond = JSBI.BigInt(microsecondParam);\n  let nanosecond = JSBI.BigInt(nanosecondParam);\n  let quotient;\n\n  ({ quotient, remainder: nanosecond } = NonNegativeBigIntDivmod(nanosecond, THOUSAND));\n  microsecond = JSBI.add(microsecond, quotient);\n\n  ({ quotient, remainder: microsecond } = NonNegativeBigIntDivmod(microsecond, THOUSAND));\n  millisecond = JSBI.add(millisecond, quotient);\n\n  ({ quotient, remainder: millisecond } = NonNegativeBigIntDivmod(millisecond, THOUSAND));\n  second = JSBI.add(second, quotient);\n\n  ({ quotient, remainder: second } = NonNegativeBigIntDivmod(second, SIXTY));\n  minute = JSBI.add(minute, quotient);\n\n  ({ quotient, remainder: minute } = NonNegativeBigIntDivmod(minute, SIXTY));\n  hour = JSBI.add(hour, quotient);\n\n  ({ quotient, remainder: hour } = NonNegativeBigIntDivmod(hour, TWENTY_FOUR));\n\n  return {\n    deltaDays: JSBI.toNumber(quotient),\n    hour: JSBI.toNumber(hour),\n    minute: JSBI.toNumber(minute),\n    second: JSBI.toNumber(second),\n    millisecond: JSBI.toNumber(millisecond),\n    microsecond: JSBI.toNumber(microsecond),\n    nanosecond: JSBI.toNumber(nanosecond)\n  };\n}\n\nexport function TotalDurationNanoseconds(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  offsetShift: number\n) {\n  const days: JSBI = JSBI.BigInt(daysParam);\n  let nanoseconds: JSBI = JSBI.BigInt(nanosecondsParam);\n  if (daysParam !== 0) nanoseconds = JSBI.subtract(JSBI.BigInt(nanosecondsParam), JSBI.BigInt(offsetShift));\n  const hours = JSBI.add(JSBI.BigInt(hoursParam), JSBI.multiply(days, JSBI.BigInt(24)));\n  const minutes = JSBI.add(JSBI.BigInt(minutesParam), JSBI.multiply(hours, SIXTY));\n  const seconds = JSBI.add(JSBI.BigInt(secondsParam), JSBI.multiply(minutes, SIXTY));\n  const milliseconds = JSBI.add(JSBI.BigInt(millisecondsParam), JSBI.multiply(seconds, THOUSAND));\n  const microseconds = JSBI.add(JSBI.BigInt(microsecondsParam), JSBI.multiply(milliseconds, THOUSAND));\n  return JSBI.add(JSBI.BigInt(nanoseconds), JSBI.multiply(microseconds, THOUSAND));\n}\n\nfunction NanosecondsToDays(nanosecondsParam: JSBI, relativeTo: ReturnType<typeof ToRelativeTemporalObject>) {\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const sign = MathSign(JSBI.toNumber(nanosecondsParam));\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  let dayLengthNs = 86400e9;\n  if (sign === 0) return { days: 0, nanoseconds: ZERO, dayLengthNs };\n  if (!IsTemporalZonedDateTime(relativeTo)) {\n    let days: JSBI;\n    ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, JSBI.BigInt(dayLengthNs)));\n    return { days: JSBI.toNumber(days), nanoseconds, dayLengthNs };\n  }\n\n  const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n  const start = GetSlot(relativeTo, INSTANT);\n  const endNs = JSBI.add(startNs, nanoseconds);\n  const end = new TemporalInstant(endNs);\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n\n  // Find the difference in days only.\n  const dtStart = GetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = GetPlainDateTimeFor(timeZone, end, calendar);\n  let { days: daysNumber } = DifferenceISODateTime(\n    GetSlot(dtStart, ISO_YEAR),\n    GetSlot(dtStart, ISO_MONTH),\n    GetSlot(dtStart, ISO_DAY),\n    GetSlot(dtStart, ISO_HOUR),\n    GetSlot(dtStart, ISO_MINUTE),\n    GetSlot(dtStart, ISO_SECOND),\n    GetSlot(dtStart, ISO_MILLISECOND),\n    GetSlot(dtStart, ISO_MICROSECOND),\n    GetSlot(dtStart, ISO_NANOSECOND),\n    GetSlot(dtEnd, ISO_YEAR),\n    GetSlot(dtEnd, ISO_MONTH),\n    GetSlot(dtEnd, ISO_DAY),\n    GetSlot(dtEnd, ISO_HOUR),\n    GetSlot(dtEnd, ISO_MINUTE),\n    GetSlot(dtEnd, ISO_SECOND),\n    GetSlot(dtEnd, ISO_MILLISECOND),\n    GetSlot(dtEnd, ISO_MICROSECOND),\n    GetSlot(dtEnd, ISO_NANOSECOND),\n    calendar,\n    'day',\n    ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n  );\n  let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, daysNumber, 0, 0, 0, 0, 0, 0);\n  // may disambiguate\n\n  // If clock time after addition was in the middle of a skipped period, the\n  // endpoint was disambiguated to a later clock time. So it's possible that\n  // the resulting disambiguated result is later than endNs. If so, then back\n  // up one day and try again. Repeat if necessary (some transitions are\n  // > 24 hours) until either there's zero days left or the date duration is\n  // back inside the period where it belongs. Note that this case only can\n  // happen for positive durations because the only direction that\n  // `disambiguation: 'compatible'` can change clock time is forwards.\n  let daysBigInt = JSBI.BigInt(daysNumber);\n  if (sign === 1) {\n    while (JSBI.greaterThan(daysBigInt, ZERO) && JSBI.greaterThan(intermediateNs, endNs)) {\n      daysBigInt = JSBI.subtract(daysBigInt, ONE);\n      intermediateNs = AddZonedDateTime(\n        start,\n        timeZone,\n        calendar,\n        0,\n        0,\n        0,\n        JSBI.toNumber(daysBigInt),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      );\n      // may do disambiguation\n    }\n  }\n  nanoseconds = JSBI.subtract(endNs, intermediateNs);\n\n  let isOverflow = false;\n  let relativeInstant = new TemporalInstant(intermediateNs);\n  do {\n    // calculate length of the next day (day that contains the time remainder)\n    const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n    const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n    dayLengthNs = JSBI.toNumber(JSBI.subtract(oneDayFartherNs, relativeNs));\n    isOverflow = JSBI.greaterThanOrEqual(\n      JSBI.multiply(JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs)), JSBI.BigInt(sign)),\n      ZERO\n    );\n    if (isOverflow) {\n      nanoseconds = JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs));\n      relativeInstant = new TemporalInstant(oneDayFartherNs);\n      daysBigInt = JSBI.add(daysBigInt, JSBI.BigInt(sign));\n    }\n  } while (isOverflow);\n  if (!isZero(daysBigInt) && signJSBI(daysBigInt) !== sign) {\n    throw new RangeError('Time zone or calendar converted nanoseconds into a number of days with the opposite sign');\n  }\n  if (!isZero(nanoseconds) && signJSBI(nanoseconds) !== sign) {\n    if (isNegativeJSBI(nanoseconds) && sign === 1) {\n      throw new Error('assert not reached');\n    }\n    throw new RangeError('Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign');\n  }\n  if (JSBI.greaterThanOrEqual(abs(nanoseconds), abs(JSBI.BigInt(dayLengthNs)))) {\n    throw new Error('assert not reached');\n  }\n  return { days: JSBI.toNumber(daysBigInt), nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\n\nexport function BalanceDuration(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let result = BalancePossiblyInfiniteDuration(\n    daysParam,\n    hoursParam,\n    minutesParam,\n    secondsParam,\n    millisecondsParam,\n    microsecondsParam,\n    nanosecondsParam,\n    largestUnit,\n    relativeTo\n  );\n  if (result === 'positive overflow' || result === 'negative overflow') {\n    throw new RangeError('Duration out of range');\n  } else {\n    return result;\n  }\n}\n\nexport function BalancePossiblyInfiniteDuration(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let days = daysParam;\n  let nanosecondsBigInt: JSBI,\n    microsecondsBigInt: JSBI,\n    millisecondsBigInt: JSBI,\n    secondsBigInt: JSBI,\n    minutesBigInt: JSBI,\n    hoursBigInt: JSBI;\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const endNs = AddZonedDateTime(\n      GetSlot(relativeTo, INSTANT),\n      GetSlot(relativeTo, TIME_ZONE),\n      GetSlot(relativeTo, CALENDAR),\n      0,\n      0,\n      0,\n      days,\n      hoursParam,\n      minutesParam,\n      secondsParam,\n      millisecondsParam,\n      microsecondsParam,\n      nanosecondsParam\n    );\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    nanosecondsBigInt = JSBI.subtract(endNs, startNs);\n  } else {\n    nanosecondsBigInt = TotalDurationNanoseconds(\n      days,\n      hoursParam,\n      minutesParam,\n      secondsParam,\n      millisecondsParam,\n      microsecondsParam,\n      nanosecondsParam,\n      0\n    );\n  }\n  if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n    ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n  } else {\n    days = 0;\n  }\n\n  const sign = JSBI.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n  nanosecondsBigInt = abs(nanosecondsBigInt);\n  microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n\n  switch (largestUnit) {\n    case 'year':\n    case 'month':\n    case 'week':\n    case 'day':\n    case 'hour':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n      ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n      break;\n    case 'minute':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n      break;\n    case 'second':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      break;\n    case 'millisecond':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      break;\n    case 'microsecond':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      break;\n    case 'nanosecond':\n      break;\n    default:\n      throw new Error('assert not reached');\n  }\n\n  const hours = JSBI.toNumber(hoursBigInt) * sign;\n  const minutes = JSBI.toNumber(minutesBigInt) * sign;\n  const seconds = JSBI.toNumber(secondsBigInt) * sign;\n  const milliseconds = JSBI.toNumber(millisecondsBigInt) * sign;\n  const microseconds = JSBI.toNumber(microsecondsBigInt) * sign;\n  const nanoseconds = JSBI.toNumber(nanosecondsBigInt) * sign;\n\n  for (const prop of [days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n    if (!NumberIsFinite(prop)) {\n      if (sign === 1) {\n        return 'positive overflow' as const;\n      } else {\n        return 'negative overflow' as const;\n      }\n    }\n  }\n\n  return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nexport function UnbalanceDurationRelative(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject>\n): {\n  years: number;\n  months: number;\n  weeks: number;\n  days: number;\n} {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(yearsParam, monthsParam, weeksParam, daysParam, 0, 0, 0, 0, 0, 0);\n  if (sign === 0) return { years: yearsParam, months: monthsParam, weeks: weeksParam, days: daysParam };\n  const signBI = JSBI.BigInt(sign);\n\n  let years = JSBI.BigInt(yearsParam);\n  let months = JSBI.BigInt(monthsParam);\n  let weeks = JSBI.BigInt(weeksParam);\n  let days = JSBI.BigInt(daysParam);\n\n  let calendar;\n  let relativeTo: Temporal.PlainDate | undefined;\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year':\n      // no-op\n      break;\n    case 'month':\n      {\n        if (!calendar) throw new RangeError('a starting point is required for months balancing');\n        assertExists(relativeTo);\n        // balance years down to months\n        let dateAdd, dateUntil;\n        if (typeof calendar !== 'string') {\n          dateAdd = GetMethod(calendar, 'dateAdd');\n          dateUntil = GetMethod(calendar, 'dateUntil');\n        }\n        while (!isZero(years)) {\n          const newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n          const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<typeof largestUnit>;\n          untilOptions.largestUnit = 'month';\n          const untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n          const oneYearMonths = JSBI.BigInt(GetSlot(untilResult, MONTHS));\n          relativeTo = newRelativeTo;\n          months = JSBI.add(months, oneYearMonths);\n          years = JSBI.subtract(years, signBI);\n        }\n      }\n      break;\n    case 'week': {\n      if (!calendar) throw new RangeError('a starting point is required for weeks balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance years down to days\n      while (!isZero(years)) {\n        let oneYearDays;\n        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.subtract(years, signBI);\n      }\n\n      // balance months down to days\n      while (!isZero(months)) {\n        let oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.subtract(months, signBI);\n      }\n      break;\n    }\n    default: {\n      // balance years down to days\n      if (isZero(years) && isZero(months) && isZero(weeks)) break;\n      if (!calendar) throw new RangeError('a starting point is required for balancing calendar units');\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      while (!isZero(years)) {\n        assertExists(relativeTo);\n        let oneYearDays;\n        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.subtract(years, signBI);\n      }\n\n      // balance months down to days\n      while (!isZero(months)) {\n        assertExists(relativeTo);\n        let oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.subtract(months, signBI);\n      }\n\n      // balance weeks down to days\n      while (!isZero(weeks)) {\n        assertExists(relativeTo);\n        let oneWeekDays;\n        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneWeekDays));\n        weeks = JSBI.subtract(weeks, signBI);\n      }\n      break;\n    }\n  }\n\n  return {\n    years: JSBI.toNumber(years),\n    months: JSBI.toNumber(months),\n    weeks: JSBI.toNumber(weeks),\n    days: JSBI.toNumber(days)\n  };\n}\n\nexport function BalanceDurationRelative(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject>\n): {\n  years: number;\n  months: number;\n  weeks: number;\n  days: number;\n} {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(yearsParam, monthsParam, weeksParam, daysParam, 0, 0, 0, 0, 0, 0);\n  if (sign === 0) return { years: yearsParam, months: monthsParam, weeks: weeksParam, days: daysParam };\n  const signBI = JSBI.BigInt(sign);\n\n  let years = JSBI.BigInt(yearsParam);\n  let months = JSBI.BigInt(monthsParam);\n  let weeks = JSBI.BigInt(weeksParam);\n  let days = JSBI.BigInt(daysParam);\n\n  let calendar;\n  let relativeTo: Temporal.PlainDate | undefined;\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year': {\n      if (!calendar) throw new RangeError('a starting point is required for years balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to years\n      let newRelativeTo, oneYearDays;\n      ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneYearDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.add(years, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n      }\n\n      // balance days up to months\n      let oneMonthDays;\n      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneMonthDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.add(months, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n\n      // balance months up to years\n      newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n      const dateUntil = typeof calendar !== 'string' ? GetMethod(calendar, 'dateUntil') : undefined;\n      const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<'month'>;\n      untilOptions.largestUnit = 'month';\n      let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n      let oneYearMonths = GetSlot(untilResult, MONTHS);\n      while (JSBI.greaterThanOrEqual(abs(months), JSBI.BigInt(MathAbs(oneYearMonths)))) {\n        months = JSBI.subtract(months, JSBI.BigInt(oneYearMonths));\n        years = JSBI.add(years, signBI);\n        relativeTo = newRelativeTo;\n        newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n        const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<'month'>;\n        untilOptions.largestUnit = 'month';\n        untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n        oneYearMonths = GetSlot(untilResult, MONTHS);\n      }\n      break;\n    }\n    case 'month': {\n      if (!calendar) throw new RangeError('a starting point is required for months balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to months\n      let newRelativeTo, oneMonthDays;\n      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneMonthDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.add(months, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n      break;\n    }\n    case 'week': {\n      if (!calendar) throw new RangeError('a starting point is required for weeks balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to weeks\n      let newRelativeTo, oneWeekDays;\n      ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneWeekDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneWeekDays));\n        weeks = JSBI.add(weeks, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      }\n      break;\n    }\n    default:\n      // no-op\n      break;\n  }\n\n  return {\n    years: JSBI.toNumber(years),\n    months: JSBI.toNumber(months),\n    weeks: JSBI.toNumber(weeks),\n    days: JSBI.toNumber(days)\n  };\n}\n\nexport function CalculateOffsetShift(\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>,\n  y: number,\n  mon: number,\n  w: number,\n  d: number\n) {\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const instant = GetSlot(relativeTo, INSTANT);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n    const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instantAfter = new TemporalInstant(after);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n    return offsetAfter - offsetBefore;\n  }\n  return 0;\n}\n\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    -GetSlot(duration, YEARS),\n    -GetSlot(duration, MONTHS),\n    -GetSlot(duration, WEEKS),\n    -GetSlot(duration, DAYS),\n    -GetSlot(duration, HOURS),\n    -GetSlot(duration, MINUTES),\n    -GetSlot(duration, SECONDS),\n    -GetSlot(duration, MILLISECONDS),\n    -GetSlot(duration, MICROSECONDS),\n    -GetSlot(duration, NANOSECONDS)\n  );\n}\n\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\n  // used for optional params in the method below.\n  return MathMin(max, MathMax(min, value as number));\n}\nfunction ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\n  const month = ConstrainToRange(monthParam, 1, 12);\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n  return { year, month, day };\n}\n\nfunction ConstrainTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  const hour = ConstrainToRange(hourParam, 0, 23);\n  const minute = ConstrainToRange(minuteParam, 0, 59);\n  const second = ConstrainToRange(secondParam, 0, 59);\n  const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n  const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n  const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RejectToRange(value: number, min: number, max: number) {\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\n\nfunction RejectISODate(year: number, month: number, day: number) {\n  RejectToRange(month, 1, 12);\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\n\nfunction RejectDateRange(year: number, month: number, day: number) {\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\n  RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\n\nexport function RejectTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(hour, 0, 23);\n  RejectToRange(minute, 0, 59);\n  RejectToRange(second, 0, 59);\n  RejectToRange(millisecond, 0, 999);\n  RejectToRange(microsecond, 0, 999);\n  RejectToRange(nanosecond, 0, 999);\n}\n\nfunction RejectDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectISODate(year, month, day);\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction RejectDateTimeRange(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  // Reject any DateTime 24 hours or more outside the Instant range\n  if (\n    (year === YEAR_MIN &&\n      null ==\n        GetUTCEpochNanoseconds(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n    (year === YEAR_MAX &&\n      null ==\n        GetUTCEpochNanoseconds(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))\n  ) {\n    throw new RangeError('DateTime outside of supported range');\n  }\n}\n\nexport function ValidateEpochNanoseconds(epochNanoseconds: JSBI) {\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n    throw new RangeError('Instant outside of supported range');\n  }\n}\n\nfunction RejectYearMonthRange(year: number, month: number) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  if (year === YEAR_MIN) {\n    RejectToRange(month, 4, 12);\n  } else if (year === YEAR_MAX) {\n    RejectToRange(month, 1, 9);\n  }\n}\n\nexport function RejectDuration(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  const sign = DurationSign(y, mon, w, d, h, min, s, ms, µs, ns);\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (!NumberIsFinite(prop)) throw new RangeError('infinite values not allowed as duration fields');\n    const propSign = MathSign(prop);\n    if (propSign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\n  }\n}\n\nexport function DifferenceISODate<Allowed extends Temporal.DateTimeUnit>(\n  y1: number,\n  m1: number,\n  d1: number,\n  y2: number,\n  m2: number,\n  d2: number,\n  largestUnit: Allowed\n) {\n  switch (largestUnit) {\n    case 'year':\n    case 'month': {\n      const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n      if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\n\n      const start = { year: y1, month: m1, day: d1 };\n      const end = { year: y2, month: m2, day: d2 };\n\n      let years = end.year - start.year;\n      let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n      let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n      if (midSign === 0) {\n        return largestUnit === 'year'\n          ? { years, months: 0, weeks: 0, days: 0 }\n          : { years: 0, months: years * 12, weeks: 0, days: 0 };\n      }\n      let months = end.month - start.month;\n      if (midSign !== sign) {\n        years -= sign;\n        months += sign * 12;\n      }\n      mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n      midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n      if (midSign === 0) {\n        return largestUnit === 'year'\n          ? { years, months, weeks: 0, days: 0 }\n          : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n      }\n      if (midSign !== sign) {\n        // The end date is later in the month than mid date (or earlier for\n        // negative durations). Back up one month.\n        months -= sign;\n        if (months === -sign) {\n          years -= sign;\n          months = 11 * sign;\n        }\n        mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n      }\n\n      let days = 0;\n      // If we get here, months and years are correct (no overflow), and `mid`\n      // is within the range from `start` to `end`. To count the days between\n      // `mid` and `end`, there are 3 cases:\n      // 1) same month: use simple subtraction\n      // 2) end is previous month from intermediate (negative duration)\n      // 3) end is next month from intermediate (positive duration)\n      if (mid.month === end.month) {\n        // 1) same month: use simple subtraction\n        days = end.day - mid.day;\n      } else if (sign < 0) {\n        // 2) end is previous month from intermediate (negative duration)\n        // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n        days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n      } else {\n        // 3) end is next month from intermediate (positive duration)\n        // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n        days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n      }\n\n      if (largestUnit === 'month') {\n        months += years * 12;\n        years = 0;\n      }\n      return { years, months, weeks: 0, days };\n    }\n    case 'week':\n    case 'day': {\n      let larger, smaller, sign;\n      if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n        smaller = { year: y1, month: m1, day: d1 };\n        larger = { year: y2, month: m2, day: d2 };\n        sign = 1;\n      } else {\n        smaller = { year: y2, month: m2, day: d2 };\n        larger = { year: y1, month: m1, day: d1 };\n        sign = -1;\n      }\n      let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n      for (let year = smaller.year; year < larger.year; ++year) {\n        days += LeapYear(year) ? 366 : 365;\n      }\n      let weeks = 0;\n      if (largestUnit === 'week') {\n        weeks = MathFloor(days / 7);\n        days %= 7;\n      }\n      weeks *= sign;\n      days *= sign;\n      return { years: 0, months: 0, weeks, days };\n    }\n    default:\n      throw new Error('assert not reached');\n  }\n}\n\nfunction DifferenceTime(\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number\n) {\n  let hours = h2 - h1;\n  let minutes = min2 - min1;\n  let seconds = s2 - s1;\n  let milliseconds = ms2 - ms1;\n  let microseconds = µs2 - µs1;\n  let nanoseconds = ns2 - ns1;\n\n  const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n\n  let deltaDays = 0;\n  ({\n    deltaDays,\n    hour: hours,\n    minute: minutes,\n    second: seconds,\n    millisecond: milliseconds,\n    microsecond: microseconds,\n    nanosecond: nanoseconds\n  } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n\n  if (deltaDays != 0) throw new Error('assertion failure in DifferenceTime: _bt_.[[Days]] should be 0');\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n\n  return { hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction DifferenceInstant(\n  ns1: JSBI,\n  ns2: JSBI,\n  increment: number,\n  smallestUnit: keyof typeof nsPerTimeUnit,\n  largestUnit: keyof typeof nsPerTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  const diff = JSBI.subtract(ns2, ns1);\n\n  let hours = 0;\n  let minutes = 0;\n  let nanoseconds = JSBI.toNumber(JSBI.remainder(diff, THOUSAND));\n  let microseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(diff, THOUSAND), THOUSAND));\n  let milliseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(diff, MILLION), THOUSAND));\n  let seconds = JSBI.toNumber(JSBI.divide(diff, BILLION));\n\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    increment,\n    smallestUnit,\n    roundingMode\n  ));\n  return BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit);\n}\n\nfunction DifferenceISODateTime(\n  y1Param: number,\n  mon1Param: number,\n  d1Param: number,\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  y2: number,\n  mon2: number,\n  d2: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number,\n  calendar: CalendarSlot,\n  largestUnit: Temporal.DateTimeUnit,\n  options: Temporal.DifferenceOptions<Temporal.DateTimeUnit> | undefined\n) {\n  let y1 = y1Param;\n  let mon1 = mon1Param;\n  let d1 = d1Param;\n\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(\n    h1,\n    min1,\n    s1,\n    ms1,\n    µs1,\n    ns1,\n    h2,\n    min2,\n    s2,\n    ms2,\n    µs2,\n    ns2\n  );\n\n  const timeSign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n  if (dateSign === -timeSign) {\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      -timeSign,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      largestUnit\n    ));\n  }\n\n  const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n  const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n  const untilOptions = CopyOptions(options);\n  untilOptions.largestUnit = dateLargestUnit;\n  // TODO untilOptions doesn't want to compile as it seems that smallestUnit is not clamped?\n  // Type 'SmallestUnit<DateTimeUnit> | undefined' is not assignable to type\n  //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.\n  // Type '\"hour\"' is not assignable to type\n  //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.ts(2345)\n  let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions as any);\n  // Signs of date part and time part may not agree; balance them together\n  ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    largestUnit\n  ));\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction DifferenceZonedDateTime(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot,\n  largestUnit: Temporal.DateTimeUnit,\n  options: Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n) {\n  const nsDiff = JSBI.subtract(ns2, ns1);\n  if (JSBI.equal(nsDiff, ZERO)) {\n    return {\n      years: 0,\n      months: 0,\n      weeks: 0,\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0,\n      microseconds: 0,\n      nanoseconds: 0\n    };\n  }\n\n  // Find the difference in dates only.\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const start = new TemporalInstant(ns1);\n  const end = new TemporalInstant(ns2);\n  const dtStart = GetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = GetPlainDateTimeFor(timeZone, end, calendar);\n  let { years, months, weeks, days } = DifferenceISODateTime(\n    GetSlot(dtStart, ISO_YEAR),\n    GetSlot(dtStart, ISO_MONTH),\n    GetSlot(dtStart, ISO_DAY),\n    GetSlot(dtStart, ISO_HOUR),\n    GetSlot(dtStart, ISO_MINUTE),\n    GetSlot(dtStart, ISO_SECOND),\n    GetSlot(dtStart, ISO_MILLISECOND),\n    GetSlot(dtStart, ISO_MICROSECOND),\n    GetSlot(dtStart, ISO_NANOSECOND),\n    GetSlot(dtEnd, ISO_YEAR),\n    GetSlot(dtEnd, ISO_MONTH),\n    GetSlot(dtEnd, ISO_DAY),\n    GetSlot(dtEnd, ISO_HOUR),\n    GetSlot(dtEnd, ISO_MINUTE),\n    GetSlot(dtEnd, ISO_SECOND),\n    GetSlot(dtEnd, ISO_MILLISECOND),\n    GetSlot(dtEnd, ISO_MICROSECOND),\n    GetSlot(dtEnd, ISO_NANOSECOND),\n    calendar,\n    largestUnit,\n    options\n  );\n  const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n  // may disambiguate\n  let timeRemainderNs = JSBI.subtract(ns2, intermediateNs);\n  const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n  ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n\n  // Finally, merge the date and time durations and return the merged result.\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    JSBI.toNumber(timeRemainderNs),\n    'hour'\n  );\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\ntype DifferenceOperation = 'since' | 'until';\n\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\n  op: DifferenceOperation,\n  options: Temporal.DifferenceOptions<T>,\n  group: 'datetime' | 'date' | 'time',\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\n  fallbackSmallest: T,\n  smallestLargestDefaultUnit: T\n) {\n  const ALLOWED_UNITS = SINGULAR_PLURAL_UNITS.reduce((allowed, unitInfo) => {\n    const p = unitInfo[0];\n    const s = unitInfo[1];\n    const c = unitInfo[2];\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\n      allowed.push(s, p);\n    }\n    return allowed;\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\n\n  let largestUnit = GetTemporalUnit(options, 'largestUnit', group, 'auto');\n  if (disallowed.includes(largestUnit)) {\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\n  }\n\n  const roundingIncrement = ToTemporalRoundingIncrement(options);\n\n  let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n  if (op === 'since') roundingMode = NegateTemporalRoundingMode(roundingMode);\n\n  const smallestUnit = GetTemporalUnit(options, 'smallestUnit', group, fallbackSmallest);\n  if (disallowed.includes(smallestUnit)) {\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\n  }\n\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n  }\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n  };\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\n}\n\nexport function DifferenceTemporalInstant(\n  operation: DifferenceOperation,\n  instant: Temporal.Instant,\n  otherParam: InstantParams['until'][0],\n  options: InstantParams['until'][1] | undefined\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalInstant(otherParam);\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\n\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n    onens,\n    twons,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.largestUnit,\n    settings.roundingMode\n  );\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    0,\n    0,\n    0,\n    0,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainDate(\n  operation: DifferenceOperation,\n  plainDate: Temporal.PlainDate,\n  otherParam: PlainDateParams['until'][0],\n  options: PlainDateParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalDate(otherParam);\n  const calendar = GetSlot(plainDate, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  let { years, months, weeks, days } = CalendarDateUntil(calendar, plainDate, other, resolvedOptions);\n\n  if (settings.smallestUnit !== 'day' || settings.roundingIncrement !== 1) {\n    ({ years, months, weeks, days } = RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      plainDate\n    ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(sign * years, sign * months, sign * weeks, sign * days, 0, 0, 0, 0, 0, 0);\n}\n\nexport function DifferenceTemporalPlainDateTime(\n  operation: DifferenceOperation,\n  plainDateTime: Temporal.PlainDateTime,\n  otherParam: PlainDateTimeParams['until'][0],\n  options: PlainDateTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalDateTime(otherParam);\n  const calendar = GetSlot(plainDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\n\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    DifferenceISODateTime(\n      GetSlot(plainDateTime, ISO_YEAR),\n      GetSlot(plainDateTime, ISO_MONTH),\n      GetSlot(plainDateTime, ISO_DAY),\n      GetSlot(plainDateTime, ISO_HOUR),\n      GetSlot(plainDateTime, ISO_MINUTE),\n      GetSlot(plainDateTime, ISO_SECOND),\n      GetSlot(plainDateTime, ISO_MILLISECOND),\n      GetSlot(plainDateTime, ISO_MICROSECOND),\n      GetSlot(plainDateTime, ISO_NANOSECOND),\n      GetSlot(other, ISO_YEAR),\n      GetSlot(other, ISO_MONTH),\n      GetSlot(other, ISO_DAY),\n      GetSlot(other, ISO_HOUR),\n      GetSlot(other, ISO_MINUTE),\n      GetSlot(other, ISO_SECOND),\n      GetSlot(other, ISO_MILLISECOND),\n      GetSlot(other, ISO_MICROSECOND),\n      GetSlot(other, ISO_NANOSECOND),\n      calendar,\n      settings.largestUnit,\n      resolvedOptions\n    );\n\n  const relativeTo = TemporalDateTimeToDate(plainDateTime);\n  ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode,\n    relativeTo\n  ));\n  ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.largestUnit\n  ));\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainTime(\n  operation: DifferenceOperation,\n  plainTime: Temporal.PlainTime,\n  otherParam: PlainTimeParams['until'][0],\n  options: PlainTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalTime(otherParam);\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\n\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(\n    GetSlot(plainTime, ISO_HOUR),\n    GetSlot(plainTime, ISO_MINUTE),\n    GetSlot(plainTime, ISO_SECOND),\n    GetSlot(plainTime, ISO_MILLISECOND),\n    GetSlot(plainTime, ISO_MICROSECOND),\n    GetSlot(plainTime, ISO_NANOSECOND),\n    GetSlot(other, ISO_HOUR),\n    GetSlot(other, ISO_MINUTE),\n    GetSlot(other, ISO_SECOND),\n    GetSlot(other, ISO_MILLISECOND),\n    GetSlot(other, ISO_MICROSECOND),\n    GetSlot(other, ISO_NANOSECOND)\n  );\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    0,\n    0,\n    0,\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  ));\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.largestUnit\n  ));\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    0,\n    0,\n    0,\n    0,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainYearMonth(\n  operation: DifferenceOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  otherParam: PlainYearMonthParams['until'][0],\n  options: PlainYearMonthParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalYearMonth(otherParam);\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between months');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  const fieldNames = CalendarFields(calendar, ['monthCode', 'year']) as AnyTemporalKey[];\n  const thisFields = PrepareTemporalFields(yearMonth, fieldNames, []);\n  thisFields.day = 1;\n  const thisDate = CalendarDateFromFields(calendar, thisFields);\n  const otherFields = PrepareTemporalFields(other, fieldNames, []);\n  otherFields.day = 1;\n  const otherDate = CalendarDateFromFields(calendar, otherFields);\n\n  let { years, months } = CalendarDateUntil(calendar, thisDate, otherDate, resolvedOptions);\n\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\n    ({ years, months } = RoundDuration(\n      years,\n      months,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      thisDate\n    ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(sign * years, sign * months, 0, 0, 0, 0, 0, 0, 0, 0);\n}\n\nexport function DifferenceTemporalZonedDateTime(\n  operation: DifferenceOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  otherParam: ZonedDateTimeParams['until'][0],\n  options: ZonedDateTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalZonedDateTime(otherParam);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n  if (\n    settings.largestUnit !== 'year' &&\n    settings.largestUnit !== 'month' &&\n    settings.largestUnit !== 'week' &&\n    settings.largestUnit !== 'day'\n  ) {\n    // The user is only asking for a time difference, so return difference of instants.\n    years = 0;\n    months = 0;\n    weeks = 0;\n    days = 0;\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n      ns1,\n      ns2,\n      settings.roundingIncrement,\n      settings.smallestUnit as Temporal.TimeUnit,\n      settings.largestUnit as Temporal.TimeUnit,\n      settings.roundingMode\n    ));\n  } else {\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n      throw new RangeError(\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\n      );\n    }\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, settings.largestUnit, resolvedOptions));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      zonedDateTime\n    ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      AdjustRoundedDurationDays(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        settings.roundingIncrement,\n        settings.smallestUnit,\n        settings.roundingMode,\n        zonedDateTime\n      ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function AddISODate(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n\n  year += years;\n  month += months;\n  ({ year, month } = BalanceISOYearMonth(year, month));\n  ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n  days += 7 * weeks;\n  day += days;\n  ({ year, month, day } = BalanceISODate(year, month, day));\n  return { year, month, day };\n}\n\nfunction AddTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  hour += hours;\n  minute += minutes;\n  second += seconds;\n  millisecond += milliseconds;\n  microsecond += microseconds;\n  nanosecond += nanoseconds;\n  let deltaDays = 0;\n  ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  ));\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nfunction AddDuration(\n  y1: number,\n  mon1: number,\n  w1: number,\n  d1: number,\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  y2: number,\n  mon2: number,\n  w2: number,\n  d2: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>\n) {\n  const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n  const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n  if (!relativeTo) {\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n      throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n    }\n    years = months = weeks = 0;\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      d1 + d2,\n      JSBI.add(JSBI.BigInt(h1), JSBI.BigInt(h2)),\n      JSBI.add(JSBI.BigInt(min1), JSBI.BigInt(min2)),\n      JSBI.add(JSBI.BigInt(s1), JSBI.BigInt(s2)),\n      JSBI.add(JSBI.BigInt(ms1), JSBI.BigInt(ms2)),\n      JSBI.add(JSBI.BigInt(µs1), JSBI.BigInt(µs2)),\n      JSBI.add(JSBI.BigInt(ns1), JSBI.BigInt(ns2)),\n      largestUnit\n    ));\n  } else if (IsTemporalDate(relativeTo)) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const calendar = GetSlot(relativeTo, CALENDAR);\n\n    const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n    const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n    const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n    const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, undefined, dateAdd);\n    const end = CalendarDateAdd(calendar, intermediate, dateDuration2, undefined, dateAdd);\n\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\n    const differenceOptions = ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateUnit>;\n    differenceOptions.largestUnit = dateLargestUnit;\n    ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      days,\n      JSBI.add(JSBI.BigInt(h1), JSBI.BigInt(h2)),\n      JSBI.add(JSBI.BigInt(min1), JSBI.BigInt(min2)),\n      JSBI.add(JSBI.BigInt(s1), JSBI.BigInt(s2)),\n      JSBI.add(JSBI.BigInt(ms1), JSBI.BigInt(ms2)),\n      JSBI.add(JSBI.BigInt(µs1), JSBI.BigInt(µs2)),\n      JSBI.add(JSBI.BigInt(ns1), JSBI.BigInt(ns2)),\n      largestUnit\n    ));\n  } else {\n    // relativeTo is a ZonedDateTime\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(\n      GetSlot(relativeTo, INSTANT),\n      timeZone,\n      calendar,\n      y1,\n      mon1,\n      w1,\n      d1,\n      h1,\n      min1,\n      s1,\n      ms1,\n      µs1,\n      ns1\n    );\n    const endNs = AddZonedDateTime(\n      new TemporalInstant(intermediateNs),\n      timeZone,\n      calendar,\n      y2,\n      mon2,\n      w2,\n      d2,\n      h2,\n      min2,\n      s2,\n      ms2,\n      µs2,\n      ns2\n    );\n    if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n      // The user is only asking for a time difference, so return difference of instants.\n      years = 0;\n      months = 0;\n      weeks = 0;\n      days = 0;\n      ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n        GetSlot(relativeTo, EPOCHNANOSECONDS),\n        endNs,\n        1,\n        'nanosecond',\n        largestUnit,\n        'halfExpand'\n      ));\n    } else {\n      ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n        DifferenceZonedDateTime(\n          GetSlot(relativeTo, EPOCHNANOSECONDS),\n          endNs,\n          timeZone,\n          calendar,\n          largestUnit,\n          ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n        ));\n    }\n  }\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction AddInstant(\n  epochNanoseconds: JSBI,\n  h: number | JSBI,\n  min: number | JSBI,\n  s: number | JSBI,\n  ms: number | JSBI,\n  µs: number | JSBI,\n  ns: number | JSBI\n) {\n  let sum = ZERO;\n  sum = JSBI.add(sum, JSBI.BigInt(ns));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(µs), THOUSAND));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(ms), MILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(s), BILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(min), JSBI.BigInt(60 * 1e9)));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(60 * 60 * 1e9)));\n\n  const result = JSBI.add(epochNanoseconds, sum);\n  ValidateEpochNanoseconds(result);\n  return result;\n}\n\nfunction AddDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  calendar: CalendarSlot,\n  years: number,\n  months: number,\n  weeks: number,\n  daysParam: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number,\n  options?: Temporal.ArithmeticOptions\n) {\n  let days = daysParam;\n  // Add the time part\n  let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n  days += deltaDays;\n\n  // Delegate the date part addition to the calendar\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const datePart = CreateTemporalDate(year, month, day, calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n\n  return {\n    year: GetSlot(addedDate, ISO_YEAR),\n    month: GetSlot(addedDate, ISO_MONTH),\n    day: GetSlot(addedDate, ISO_DAY),\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nexport function AddZonedDateTime(\n  instant: Temporal.Instant,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot,\n  years: number,\n  months: number,\n  weeks: number,\n  days: number,\n  h: number | JSBI,\n  min: number | JSBI,\n  s: number | JSBI,\n  ms: number | JSBI,\n  µs: number | JSBI,\n  ns: number | JSBI,\n  options?: Temporal.ArithmeticOptions\n) {\n  // If only time is to be added, then use Instant math. It's not OK to fall\n  // through to the date/time code below because compatible disambiguation in\n  // the PlainDateTime=>Instant conversion will change the offset of any\n  // ZonedDateTime in the repeated clock time after a backwards transition.\n  // When adding/subtracting time units and not dates, this disambiguation is\n  // not expected and so is avoided below via a fast path for time-only\n  // arithmetic.\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n    return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n  }\n\n  // RFC 5545 requires the date portion to be added in calendar days and the\n  // time portion to be added in exact time.\n  const dt = GetPlainDateTimeFor(timeZone, instant, calendar);\n  const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n  const dtIntermediate = CreateTemporalDateTime(\n    GetSlot(addedDate, ISO_YEAR),\n    GetSlot(addedDate, ISO_MONTH),\n    GetSlot(addedDate, ISO_DAY),\n    GetSlot(dt, ISO_HOUR),\n    GetSlot(dt, ISO_MINUTE),\n    GetSlot(dt, ISO_SECOND),\n    GetSlot(dt, ISO_MILLISECOND),\n    GetSlot(dt, ISO_MICROSECOND),\n    GetSlot(dt, ISO_NANOSECOND),\n    calendar\n  );\n\n  // Note that 'compatible' is used below because this disambiguation behavior\n  // is required by RFC 5545.\n  const instantIntermediate = GetInstantFor(timeZone, dtIntermediate, 'compatible');\n  return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n}\n\ntype AddSubtractOperation = 'add' | 'subtract';\n\nexport function AddDurationToOrSubtractDurationFromDuration(\n  operation: AddSubtractOperation,\n  duration: Temporal.Duration,\n  other: DurationParams['add'][0],\n  optionsParam: DurationParams['add'][1]\n): Temporal.Duration {\n  const sign = operation === 'subtract' ? -1 : 1;\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(other);\n  const options = GetOptionsObject(optionsParam);\n  const relativeTo = ToRelativeTemporalObject(options);\n  ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(\n    GetSlot(duration, YEARS),\n    GetSlot(duration, MONTHS),\n    GetSlot(duration, WEEKS),\n    GetSlot(duration, DAYS),\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS),\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    relativeTo\n  ));\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\n\nexport function AddDurationToOrSubtractDurationFromInstant(\n  operation: AddSubtractOperation,\n  instant: Temporal.Instant,\n  durationLike: InstantParams['add'][0]\n): Temporal.Instant {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(durationLike, [\n    'years',\n    'months',\n    'weeks',\n    'days'\n  ]);\n  const ns = AddInstant(\n    GetSlot(instant, EPOCHNANOSECONDS),\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  return new Instant(ns);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainDateTime(\n  operation: AddSubtractOperation,\n  dateTime: Temporal.PlainDateTime,\n  durationLike: PlainDateTimeParams['add'][0],\n  optionsParam: PlainDateTimeParams['add'][1]\n): Temporal.PlainDateTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(durationLike);\n  const options = GetOptionsObject(optionsParam);\n  const calendar = GetSlot(dateTime, CALENDAR);\n  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(\n    GetSlot(dateTime, ISO_YEAR),\n    GetSlot(dateTime, ISO_MONTH),\n    GetSlot(dateTime, ISO_DAY),\n    GetSlot(dateTime, ISO_HOUR),\n    GetSlot(dateTime, ISO_MINUTE),\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    calendar,\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    options\n  );\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainTime(\n  operation: AddSubtractOperation,\n  temporalTime: Temporal.PlainTime,\n  durationLike: PlainTimeParams['add'][0]\n): Temporal.PlainTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(durationLike);\n  let { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    GetSlot(temporalTime, ISO_HOUR),\n    GetSlot(temporalTime, ISO_MINUTE),\n    GetSlot(temporalTime, ISO_SECOND),\n    GetSlot(temporalTime, ISO_MILLISECOND),\n    GetSlot(temporalTime, ISO_MICROSECOND),\n    GetSlot(temporalTime, ISO_NANOSECOND),\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n  ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    'reject'\n  ));\n  const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainYearMonth(\n  operation: AddSubtractOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  durationLike: PlainYearMonthParams['add'][0],\n  optionsParam: PlainYearMonthParams['add'][1]\n): Temporal.PlainYearMonth {\n  let duration = ToTemporalDurationRecord(durationLike);\n  if (operation === 'subtract') {\n    duration = {\n      years: -duration.years,\n      months: -duration.months,\n      weeks: -duration.weeks,\n      days: -duration.days,\n      hours: -duration.hours,\n      minutes: -duration.minutes,\n      seconds: -duration.seconds,\n      milliseconds: -duration.milliseconds,\n      microseconds: -duration.microseconds,\n      nanoseconds: -duration.nanoseconds\n    };\n  }\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n  ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n\n  const options = GetOptionsObject(optionsParam);\n\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const fieldNames = CalendarFields(calendar, ['monthCode', 'year'] as const);\n  const fields = PrepareTemporalFields(yearMonth, fieldNames, []);\n  const fieldsCopy = ObjectCreate(null);\n  CopyDataProperties(fieldsCopy, fields, []);\n  fields.day = 1;\n  // PrepareTemporalFields returns a type where 'day' is potentially undefined,\n  // but TS doesn't narrow the type as a result of the assignment above.\n  uncheckedAssertNarrowedType<typeof fields & { day: number }>(fields, '`day` is guaranteed to be non-undefined');\n  let startDate = CalendarDateFromFields(calendar, fields);\n  const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const dateAdd = GetMethod(calendar, 'dateAdd');\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  if (sign < 0) {\n    const oneMonthDuration = new Duration(0, 1, 0, 0, 0, 0, 0, 0, 0, 0);\n    const nextMonth = CalendarDateAdd(calendar, startDate, oneMonthDuration, undefined, dateAdd);\n    const minusDayDuration = new Duration(0, 0, 0, -1, 0, 0, 0, 0, 0, 0);\n    const endOfMonth = CalendarDateAdd(calendar, nextMonth, minusDayDuration, undefined, dateAdd);\n    fieldsCopy.day = CalendarDay(calendar, endOfMonth);\n    startDate = CalendarDateFromFields(calendar, fieldsCopy);\n  }\n  const durationToAdd = new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const optionsCopy = CopyOptions(options);\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, options, dateAdd);\n  const addedDateFields = PrepareTemporalFields(addedDate, fieldNames, []);\n\n  return CalendarYearMonthFromFields(calendar, addedDateFields, optionsCopy);\n}\n\nexport function AddDurationToOrSubtractDurationFromZonedDateTime(\n  operation: AddSubtractOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  durationLike: ZonedDateTimeParams['add'][0],\n  optionsParam: ZonedDateTimeParams['add'][1]\n): Temporal.ZonedDateTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(durationLike);\n  const options = GetOptionsObject(optionsParam);\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const epochNanoseconds = AddZonedDateTime(\n    GetSlot(zonedDateTime, INSTANT),\n    timeZone,\n    calendar,\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    options\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nfunction RoundNumberToIncrement(quantity: JSBI, increment: JSBI, mode: Temporal.RoundingMode) {\n  if (JSBI.equal(increment, ONE)) return quantity;\n  let { quotient, remainder } = divmod(quantity, increment);\n  if (JSBI.equal(remainder, ZERO)) return quantity;\n  const sign = JSBI.lessThan(remainder, ZERO) ? -1 : 1;\n  const tiebreaker = abs(JSBI.multiply(remainder, JSBI.BigInt(2)));\n  const tie = JSBI.equal(tiebreaker, increment);\n  const expandIsNearer = JSBI.greaterThan(tiebreaker, increment);\n  switch (mode) {\n    case 'ceil':\n      if (sign > 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'floor':\n      if (sign < 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'expand':\n      // always expand if there is a remainder\n      quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'trunc':\n      // no change needed, because divmod is a truncation\n      break;\n    case 'halfCeil':\n      if (expandIsNearer || (tie && sign > 0)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfFloor':\n      if (expandIsNearer || (tie && sign < 0)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfExpand':\n      // \"half up away from zero\"\n      if (expandIsNearer || tie) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfTrunc':\n      if (expandIsNearer) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfEven':\n      if (expandIsNearer || (tie && JSBI.toNumber(JSBI.remainder(abs(quotient), JSBI.BigInt(2))) === 1)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n  }\n  return JSBI.multiply(quotient, increment);\n}\n\nexport function RoundInstant(\n  epochNs: JSBI,\n  increment: number,\n  unit: keyof typeof nsPerTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  let { remainder } = NonNegativeBigIntDivmod(epochNs, DAY_NANOS);\n  const wholeDays = JSBI.subtract(epochNs, remainder);\n  const roundedRemainder = RoundNumberToIncrement(\n    remainder,\n    JSBI.BigInt(nsPerTimeUnit[unit] * increment),\n    roundingMode\n  );\n  return JSBI.add(wholeDays, roundedRemainder);\n}\n\nexport function RoundISODateTime(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  increment: number,\n  unit: UnitSmallerThanOrEqualTo<'day'>,\n  roundingMode: Temporal.RoundingMode,\n  dayLengthNs = 86400e9\n) {\n  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam,\n    increment,\n    unit,\n    roundingMode,\n    dayLengthNs\n  );\n  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RoundTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  increment: number,\n  unit: keyof typeof nsPerTimeUnit | 'day',\n  roundingMode: Temporal.RoundingMode,\n  dayLengthNs = 86400e9\n) {\n  let quantity = ZERO;\n  switch (unit) {\n    case 'day':\n    case 'hour':\n      quantity = JSBI.BigInt(hour);\n    // fall through\n    case 'minute':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(minute));\n    // fall through\n    case 'second':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(second));\n    // fall through\n    case 'millisecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(millisecond));\n    // fall through\n    case 'microsecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(microsecond));\n    // fall through\n    case 'nanosecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(nanosecond));\n  }\n  const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n  const rounded = RoundNumberToIncrement(quantity, JSBI.BigInt(nsPerUnit * increment), roundingMode);\n  const result = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(nsPerUnit)));\n  switch (unit) {\n    case 'day':\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n    case 'hour':\n      return BalanceTime(result, 0, 0, 0, 0, 0);\n    case 'minute':\n      return BalanceTime(hour, result, 0, 0, 0, 0);\n    case 'second':\n      return BalanceTime(hour, minute, result, 0, 0, 0);\n    case 'millisecond':\n      return BalanceTime(hour, minute, second, result, 0, 0);\n    case 'microsecond':\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\n    case 'nanosecond':\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n    default:\n      throw new Error(`Invalid unit ${unit}`);\n  }\n}\n\nfunction DaysUntil(\n  earlier: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.ZonedDateTime,\n  later: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.ZonedDateTime\n) {\n  return DifferenceISODate(\n    GetSlot(earlier, ISO_YEAR),\n    GetSlot(earlier, ISO_MONTH),\n    GetSlot(earlier, ISO_DAY),\n    GetSlot(later, ISO_YEAR),\n    GetSlot(later, ISO_MONTH),\n    GetSlot(later, ISO_DAY),\n    'day'\n  ).days;\n}\n\nfunction MoveRelativeDate(\n  calendar: CalendarSlot,\n  relativeToParam: NonNullable<ReturnType<typeof ToRelativeTemporalObject>>,\n  duration: Temporal.Duration,\n  dateAdd: Temporal.CalendarProtocol['dateAdd'] | undefined\n) {\n  const later = CalendarDateAdd(calendar, relativeToParam, duration, undefined, dateAdd);\n  const days = DaysUntil(relativeToParam, later);\n  return { relativeTo: later, days };\n}\n\nexport function MoveRelativeZonedDateTime(\n  relativeTo: Temporal.ZonedDateTime,\n  years: number,\n  months: number,\n  weeks: number,\n  days: number\n) {\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const intermediateNs = AddZonedDateTime(\n    GetSlot(relativeTo, INSTANT),\n    timeZone,\n    calendar,\n    years,\n    months,\n    weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\n\nexport function AdjustRoundedDurationDays(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  hoursParam: number,\n  minutesParam: number,\n  secondsParam: number,\n  millisecondsParam: number,\n  microsecondsParam: number,\n  nanosecondsParam: number,\n  increment: number,\n  unit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>\n) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = nanosecondsParam;\n  if (\n    !IsTemporalZonedDateTime(relativeTo) ||\n    unit === 'year' ||\n    unit === 'month' ||\n    unit === 'week' ||\n    unit === 'day' ||\n    (unit === 'nanosecond' && increment === 1)\n  ) {\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n  }\n\n  // There's one more round of rounding possible: if relativeTo is a\n  // ZonedDateTime, the time units could have rounded up into enough hours\n  // to exceed the day length. If this happens, grow the date part by a\n  // single day and re-run exact time rounding on the smaller remainder. DO\n  // NOT RECURSE, because once the extra hours are sucked up into the date\n  // duration, there's no way for another full day to come from the next\n  // round of rounding. And if it were possible (e.g. contrived calendar\n  // with 30-minute-long \"days\") then it'd risk an infinite loop.\n  let timeRemainderNs = TotalDurationNanoseconds(\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    0\n  );\n  const direction = MathSign(JSBI.toNumber(timeRemainderNs));\n\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const dayStart = AddZonedDateTime(\n    GetSlot(relativeTo, INSTANT),\n    timeZone,\n    calendar,\n    years,\n    months,\n    weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const dayEnd = AddZonedDateTime(\n    new TemporalInstant(dayStart),\n    timeZone,\n    calendar,\n    0,\n    0,\n    0,\n    direction,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  const dayLengthNs = JSBI.subtract(dayEnd, dayStart);\n\n  if (\n    JSBI.greaterThanOrEqual(JSBI.multiply(JSBI.subtract(timeRemainderNs, dayLengthNs), JSBI.BigInt(direction)), ZERO)\n  ) {\n    ({ years, months, weeks, days } = AddDuration(\n      years,\n      months,\n      weeks,\n      days,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      direction,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      relativeTo\n    ));\n    timeRemainderNs = RoundInstant(JSBI.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      JSBI.toNumber(timeRemainderNs),\n      'hour'\n    ));\n  }\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nexport function RoundDuration(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  hoursParam: number,\n  minutesParam: number,\n  secondsParam: number,\n  millisecondsParam: number,\n  microsecondsParam: number,\n  nanosecondsParam: number,\n  increment: number,\n  unit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  let calendar, zdtRelative;\n  // A cast is used below because relativeTo will be either PlainDate or\n  // undefined for the rest of this long method (after any ZDT=>PlainDate\n  // conversion below), and TS isn't smart enough to know that the type has\n  // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n  let relativeTo = relativeToParam as Temporal.PlainDate | undefined;\n  if (relativeTo) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      zdtRelative = relativeTo;\n      relativeTo = ToTemporalDate(relativeTo);\n    } else if (!IsTemporalDate(relativeTo)) {\n      throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n    }\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  // First convert time units up to days, if rounding to days or higher units.\n  // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n  // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n  // larger. We'll cast away `undefined` when it's used lower down below.\n  let dayLengthNs: JSBI | undefined;\n  if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n    nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n    let intermediate;\n    if (zdtRelative) {\n      intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n    }\n    let deltaDays;\n    let dayLength: number;\n    ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n    dayLengthNs = JSBI.BigInt(dayLength);\n    days += deltaDays;\n    hours = minutes = seconds = milliseconds = microseconds = 0;\n  }\n\n  let total: number;\n  switch (unit) {\n    case 'year': {\n      if (!calendar) throw new RangeError('A starting point is required for years rounding');\n      assertExists(relativeTo);\n\n      // convert months and weeks to days by calculating difference(\n      // relativeTo + years, relativeTo + { years, months, weeks })\n      const yearsDuration = new TemporalDuration(years);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, undefined, dateAdd);\n      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n      const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n      const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n      relativeTo = yearsLater;\n      days += monthsWeeksInDays;\n\n      const wholeDays = new TemporalDuration(0, 0, 0, days);\n      const wholeDaysLater = CalendarDateAdd(calendar, relativeTo, wholeDays, undefined, dateAdd);\n      const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<typeof unit>;\n      untilOptions.largestUnit = 'year';\n      const yearsPassed = CalendarDateUntil(calendar, relativeTo, wholeDaysLater, untilOptions).years;\n      years += yearsPassed;\n      const oldRelativeTo = relativeTo;\n      const yearsPassedDuration = new TemporalDuration(yearsPassed);\n      relativeTo = CalendarDateAdd(calendar, relativeTo, yearsPassedDuration, undefined, dateAdd);\n      const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n      days -= daysPassed;\n      const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n      let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd);\n\n      // Note that `nanoseconds` below (here and in similar code for months,\n      // weeks, and days further below) isn't actually nanoseconds for the\n      // full date range.  Instead, it's a BigInt representation of total\n      // days multiplied by the number of nanoseconds in the last day of\n      // the duration. This lets us do days-or-larger rounding using BigInt\n      // math which reduces precision loss.\n      oneYearDays = MathAbs(oneYearDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneYearDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(years)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      years = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      months = weeks = days = 0;\n      break;\n    }\n    case 'month': {\n      if (!calendar) throw new RangeError('A starting point is required for months rounding');\n      assertExists(relativeTo);\n\n      // convert weeks to days by calculating difference(relativeTo +\n      //   { years, months }, relativeTo + { years, months, weeks })\n      const yearsMonths = new TemporalDuration(years, months);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, undefined, dateAdd);\n      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n      const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n      const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n      relativeTo = yearsMonthsLater;\n      days += weeksInDays;\n\n      // Months may be different lengths of days depending on the calendar,\n      // convert days to months in a loop as described above under 'years'.\n      const sign = MathSign(days);\n      const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n      let oneMonthDays: number;\n      ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n        months += sign;\n        days -= oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n      oneMonthDays = MathAbs(oneMonthDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneMonthDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(months)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      months = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      weeks = days = 0;\n      break;\n    }\n    case 'week': {\n      if (!calendar) throw new RangeError('A starting point is required for weeks rounding');\n      assertExists(relativeTo);\n\n      // Weeks may be different lengths of days depending on the calendar,\n      // convert days to weeks in a loop as described above under 'years'.\n      const sign = MathSign(days);\n      const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      let oneWeekDays;\n      ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n        weeks += sign;\n        days -= oneWeekDays;\n        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      }\n      oneWeekDays = MathAbs(oneWeekDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneWeekDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(weeks)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      weeks = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      days = 0;\n      break;\n    }\n    case 'day': {\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = dayLengthNs;\n      nanoseconds = JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(days)), nanoseconds);\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      days = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      break;\n    }\n    case 'hour': {\n      const divisor = 3600e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(hours), JSBI.BigInt(3600e9));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9)));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      hours = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      minutes = seconds = milliseconds = microseconds = 0;\n      break;\n    }\n    case 'minute': {\n      const divisor = 60e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      minutes = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      seconds = milliseconds = microseconds = 0;\n      break;\n    }\n    case 'second': {\n      const divisor = 1e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(seconds), BILLION);\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      seconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      milliseconds = microseconds = 0;\n      break;\n    }\n    case 'millisecond': {\n      const divisor = 1e6;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(milliseconds), MILLION);\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      milliseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      microseconds = 0;\n      break;\n    }\n    case 'microsecond': {\n      const divisor = 1e3;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND);\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      microseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      break;\n    }\n    case 'nanosecond': {\n      total = JSBI.toNumber(nanoseconds);\n      nanoseconds = RoundNumberToIncrement(JSBI.BigInt(nanoseconds), JSBI.BigInt(increment), roundingMode);\n      break;\n    }\n  }\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds: JSBI.toNumber(nanoseconds),\n    total\n  };\n}\n\nexport function CompareISODate(y1: number, m1: number, d1: number, y2: number, m2: number, d2: number) {\n  for (const [x, y] of [\n    [y1, y2],\n    [m1, m2],\n    [d1, d2]\n  ]) {\n    if (x !== y) return ComparisonResult(x - y);\n  }\n  return 0;\n}\n\n// Not abstract operations from the spec\n\nfunction NonNegativeBigIntDivmod(x: JSBI, y: JSBI) {\n  let { quotient, remainder } = divmod(x, y);\n  if (JSBI.lessThan(remainder, ZERO)) {\n    quotient = JSBI.subtract(quotient, ONE);\n    remainder = JSBI.add(remainder, y);\n  }\n  return { quotient, remainder };\n}\n\nexport function BigIntFloorDiv(left: JSBI, right: JSBI) {\n  const { quotient, remainder } = divmod(left, right);\n  if (!isZero(remainder) && !isNegativeJSBI(left) != !isNegativeJSBI(right)) {\n    return JSBI.subtract(quotient, ONE);\n  }\n  return quotient;\n}\n\n/** Divide two JSBIs, and return the result as a Number, including the remainder. */\nexport function BigIntDivideToNumber(dividend: JSBI, divisor: JSBI) {\n  const { quotient, remainder } = divmod(dividend, divisor);\n  const result = JSBI.toNumber(quotient) + JSBI.toNumber(remainder) / JSBI.toNumber(divisor);\n  return result;\n}\n\n// Defaults to native bigint, or something \"native bigint-like\".\n// For users of Temporal that are running in environments without native BigInt,\n// the only guarantee we should give is that the returned object's toString will\n// return a string containing an accurate base 10 value of this bigint. This\n// form factor should correctly interop with other bigint compat libraries\n// easily.\ntype ExternalBigInt = bigint;\n\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\n  const jsbiBI = ToBigInt(arg);\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\n  return jsbiBI as unknown as ExternalBigInt;\n}\n\nexport function ToBigInt(arg: unknown): JSBI {\n  let prim = arg;\n  if (typeof arg === 'object') {\n    const toPrimFn = (arg as { [Symbol.toPrimitive]: unknown })[Symbol.toPrimitive];\n    if (toPrimFn && typeof toPrimFn === 'function') {\n      prim = ReflectApply(toPrimFn, arg, ['number']);\n    }\n  }\n\n  // The AO ToBigInt throws on numbers because it does not allow implicit\n  // conversion between number and bigint (unlike the bigint constructor).\n  if (typeof prim === 'number') {\n    throw new TypeError('cannot convert number to bigint');\n  }\n  if (typeof prim === 'bigint') {\n    // JSBI doesn't know anything about the bigint type, and intentionally\n    // assumes it doesn't exist. Passing one to the BigInt function will throw\n    // an error.\n    return JSBI.BigInt(prim.toString(10));\n  }\n  // JSBI will properly coerce types into a BigInt the same as the native BigInt\n  // constructor will, with the exception of native bigint which is handled\n  // above.\n  // As of 2023-04-07, the only runtime type that neither of those can handle is\n  // 'symbol', and both native bigint and the JSBI.BigInt function will throw an\n  // error if they are given a Symbol.\n  return JSBI.BigInt(prim as string | boolean | object);\n}\n\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds: () => JSBI = (() => {\n  let ns = JSBI.BigInt(Date.now() % 1e6);\n  return () => {\n    const ms = JSBI.BigInt(Date.now());\n    const result = JSBI.add(JSBI.multiply(ms, MILLION), ns);\n    ns = JSBI.remainder(ms, MILLION);\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\n    return result;\n  };\n})();\n\nexport function DefaultTimeZone() {\n  return new IntlDateTimeFormat().resolvedOptions().timeZone;\n}\n\nexport function ComparisonResult(value: number) {\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\n}\n\nexport function GetOptionsObject<T>(options: T) {\n  if (options === undefined) return ObjectCreate(null) as NonNullable<T>;\n  if (IsObject(options) && options !== null) return options;\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\n\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\n  const o = ObjectCreate(null);\n  o[propName] = propValue;\n  return o;\n}\n\nfunction CopyOptions<T extends { [s in K]?: unknown }, K extends string & keyof T>(options: T | undefined) {\n  const optionsCopy = ObjectCreate(null) as T;\n  CopyDataProperties(optionsCopy, GetOptionsObject(options), []);\n  return optionsCopy;\n}\n\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: undefined\n): O[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: Fallback\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: O[P]\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\n  let value = options[property];\n  if (value !== undefined) {\n    value = ToString(value) as O[P];\n    if (!allowedValues.includes(value)) {\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n    }\n    return value;\n  }\n  return fallback;\n}\n\nexport function IsBuiltinCalendar(id: string): id is BuiltinCalendarId {\n  return BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id));\n}\n\nexport function ASCIILowercase<T extends string>(str: T): T {\n  // The spec defines this operation distinct from String.prototype.lowercase,\n  // so we'll follow the spec here. Note that nasty security issues that can\n  // happen for some use cases if you're comparing case-modified non-ASCII\n  // values. For example, Turkish's \"I\" character was the source of a security\n  // issue involving \"file://\" URLs. See\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\n  return str.replace(/[A-Z]/g, (l) => {\n    const code = l.charCodeAt(0);\n    return String.fromCharCode(code + 0x20);\n  }) as T;\n}\n\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\n\nfunction bisect(\n  getState: (epochNs: JSBI) => number,\n  leftParam: JSBI,\n  rightParam: JSBI,\n  lstateParam: number = getState(leftParam),\n  rstateParam: number = getState(rightParam)\n) {\n  // This doesn't make much sense - why do these get converted unnecessarily?\n  let left = JSBI.BigInt(leftParam);\n  let right = JSBI.BigInt(rightParam);\n  let lstate = lstateParam;\n  let rstate = rstateParam;\n  while (JSBI.greaterThan(JSBI.subtract(right, left), ONE)) {\n    const middle = JSBI.divide(JSBI.add(left, right), JSBI.BigInt(2));\n    const mstate = getState(middle);\n    if (mstate === lstate) {\n      left = middle;\n      lstate = mstate;\n    } else if (mstate === rstate) {\n      right = middle;\n      rstate = mstate;\n    } else {\n      throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n    }\n  }\n  return right;\n}\n\nconst nsPerTimeUnit = {\n  hour: 3600e9,\n  minute: 60e9,\n  second: 1e9,\n  millisecond: 1e6,\n  microsecond: 1e3,\n  nanosecond: 1\n};\n","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport {\n  GetSlot,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR\n} from './slots';\nimport type { Temporal, Intl } from '..';\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\n\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\n\nconst descriptor = <T extends (...args: any[]) => any>(value: T) => {\n  return {\n    value,\n    enumerable: true,\n    writable: false,\n    configurable: true\n  };\n};\n\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n\ninterface CustomFormatters {\n  [DATE]: typeof dateAmend | globalThis.Intl.DateTimeFormat;\n  [YM]: typeof yearMonthAmend | typeof globalThis.Intl.DateTimeFormat;\n  [MD]: typeof monthDayAmend | typeof globalThis.Intl.DateTimeFormat;\n  [TIME]: typeof timeAmend | typeof globalThis.Intl.DateTimeFormat;\n  [DATETIME]: typeof datetimeAmend | typeof globalThis.Intl.DateTimeFormat;\n  [INST]: typeof instantAmend | typeof globalThis.Intl.DateTimeFormat;\n}\n\ninterface PrivateProps extends CustomFormatters {\n  [ORIGINAL]: globalThis.Intl.DateTimeFormat;\n  [TZ_RESOLVED]: string | Temporal.TimeZoneProtocol;\n  [CAL_ID]: globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'];\n  [LOCALE]: globalThis.Intl.ResolvedDateTimeFormatOptions['locale'];\n  [OPTIONS]: Intl.DateTimeFormatOptions;\n}\n\ntype OptionsAmenderFunction = (options: Intl.DateTimeFormatOptions) => globalThis.Intl.DateTimeFormatOptions;\ntype FormatterOrAmender = globalThis.Intl.DateTimeFormat | OptionsAmenderFunction;\n\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy<T extends PrivateProps, P extends keyof CustomFormatters>(\n  obj: T,\n  prop: P\n): globalThis.Intl.DateTimeFormat {\n  let val = obj[prop] as FormatterOrAmender;\n  if (typeof val === 'function') {\n    // If we get here, `val` is an \"amender function\". It will take the user's\n    // options and transform them into suitable options to be passed into the\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n    // will vary depending on the Temporal type, so that's why we store separate\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\n    // The efficiency happens because we don't create an (expensive) formatter\n    // until the user calls toLocaleString for that Temporal type.\n    val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n    // TODO: can this be typed more cleanly?\n    (obj[prop] as globalThis.Intl.DateTimeFormat) = val;\n  }\n  return val;\n}\n\ntype DateTimeFormatImpl = Intl.DateTimeFormat & PrivateProps;\n\nfunction DateTimeFormatImpl(\n  this: Intl.DateTimeFormat & PrivateProps,\n  locale: Params['constructor'][0] = undefined,\n  optionsParam: Params['constructor'][1] = {}\n) {\n  if (!(this instanceof DateTimeFormatImpl)) {\n    type Construct = new (\n      locale: Params['constructor'][0],\n      optionsParam: Params['constructor'][1]\n    ) => Intl.DateTimeFormat;\n    return new (DateTimeFormatImpl as unknown as Construct)(locale, optionsParam);\n  }\n  const hasOptions = typeof optionsParam !== 'undefined';\n  const options = hasOptions ? ObjectAssign({}, optionsParam) : {};\n  // TODO: remove type assertion after Temporal types land in TS lib types\n  const original = new IntlDateTimeFormat(locale, options as globalThis.Intl.DateTimeFormatOptions);\n  const ro = original.resolvedOptions();\n\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\n  // be lazily created only when needed, using the locale and options provided.\n  // But it's possible for callers to mutate those inputs before lazy creation\n  // happens. For this reason, we clone the inputs instead of caching the\n  // original objects. To avoid the complexity of deep cloning any inputs that\n  // are themselves objects (e.g. the locales array, or options property values\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\n  // options as-is because our options-amending logic adds additional fields if\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\n  // Therefore, we limit the properties in the clone to properties that were\n  // present in the original input.\n  if (hasOptions) {\n    const clonedResolved = ObjectAssign({}, ro);\n    for (const prop in clonedResolved) {\n      if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n        delete clonedResolved[prop as keyof typeof clonedResolved];\n      }\n    }\n    this[OPTIONS] = clonedResolved as Intl.DateTimeFormatOptions;\n  } else {\n    this[OPTIONS] = options;\n  }\n\n  this[LOCALE] = ro.locale;\n  this[ORIGINAL] = original;\n  this[TZ_RESOLVED] = ro.timeZone;\n  this[CAL_ID] = ro.calendar;\n  this[DATE] = dateAmend;\n  this[YM] = yearMonthAmend;\n  this[MD] = monthDayAmend;\n  this[TIME] = timeAmend;\n  this[DATETIME] = datetimeAmend;\n  this[INST] = instantAmend;\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\n\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n  writable: true,\n  value: 'DateTimeFormat'\n});\n\nDateTimeFormatImpl.supportedLocalesOf = function (\n  locales: Params['supportedLocalesOf'][0],\n  options: Params['supportedLocalesOf'][1]\n) {\n  return IntlDateTimeFormat.supportedLocalesOf(locales, options as globalThis.Intl.DateTimeFormatOptions);\n};\n\nconst propertyDescriptors: Partial<Record<keyof Intl.DateTimeFormat, PropertyDescriptor>> = {\n  resolvedOptions: descriptor(resolvedOptions),\n  format: descriptor(format),\n  formatRange: descriptor(formatRange)\n};\n\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n  propertyDescriptors.formatToParts = descriptor(formatToParts);\n}\n\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n  propertyDescriptors.formatRangeToParts = descriptor(formatRangeToParts);\n}\n\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, propertyDescriptors);\n\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nexport const DateTimeFormat = DateTimeFormatImpl as unknown as typeof Intl.DateTimeFormat;\n\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\n  return this[ORIGINAL].resolvedOptions();\n}\n\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['format'][0],\n  ...rest: P\n): Return['format'] {\n  let { instant, formatter } = extractOverrides(datetime, this);\n  if (instant && formatter) {\n    return formatter.format(instant.epochMilliseconds);\n  }\n  // Support spreading additional args for future expansion of this Intl method\n  type AllowExtraParams = (datetime: Parameters<Intl.DateTimeFormat['format']>[0], ...rest: P) => Return['format'];\n  return (this[ORIGINAL].format as unknown as AllowExtraParams)(datetime, ...rest);\n}\n\nfunction formatToParts<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['formatToParts'][0],\n  ...rest: P\n): Return['formatToParts'] {\n  let { instant, formatter } = extractOverrides(datetime, this);\n  if (instant && formatter) {\n    return formatter.formatToParts(instant.epochMilliseconds);\n  }\n  // Support spreading additional args for future expansion of this Intl method\n  type AllowExtraParams = (\n    datetime: Parameters<Intl.DateTimeFormat['formatToParts']>[0],\n    ...rest: P\n  ) => Return['formatToParts'];\n  return (this[ORIGINAL].formatToParts as unknown as AllowExtraParams)(datetime, ...rest);\n}\n\nfunction formatRange(this: DateTimeFormatImpl, a: Params['formatRange'][0], b: Params['formatRange'][1]) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n    }\n    const { instant: aa, formatter: aformatter } = extractOverrides(a as unknown as TypesWithToLocaleString, this);\n    const { instant: bb, formatter: bformatter } = extractOverrides(b as unknown as TypesWithToLocaleString, this);\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      // TODO: Remove type assertion after this method lands in TS lib types\n      return (aformatter as Intl.DateTimeFormat).formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  }\n  // TODO: Remove type assertion after this method lands in TS lib types\n  return (this[ORIGINAL] as Intl.DateTimeFormat).formatRange(a, b);\n}\n\nfunction formatRangeToParts(\n  this: DateTimeFormatImpl,\n  a: Params['formatRangeToParts'][0],\n  b: Params['formatRangeToParts'][1]\n) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n    }\n    const { instant: aa, formatter: aformatter } = extractOverrides(a, this);\n    const { instant: bb, formatter: bformatter } = extractOverrides(b, this);\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      // TODO: Remove type assertion after this method lands in TS lib types\n      return (aformatter as Intl.DateTimeFormat).formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  }\n  // TODO: Remove type assertion after this method lands in TS lib types\n  return (this[ORIGINAL] as Intl.DateTimeFormat).formatRangeToParts(a, b);\n}\n\n// \"false\" is a signal to delete this option\ntype MaybeFalseOptions = {\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\n};\n\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\n  const options = ObjectAssign({}, optionsParam);\n  for (const opt of [\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'weekday',\n    'dayPeriod',\n    'timeZoneName',\n    'dateStyle',\n    'timeStyle'\n  ] as const) {\n    // TODO: can this be typed more cleanly?\n    type OptionMaybeFalse = typeof options[typeof opt] | false;\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\n  }\n  return options as globalThis.Intl.DateTimeFormatOptions;\n}\n\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\n\nfunction timeAmend(optionsParam: OptionsType<Temporal.PlainTime>) {\n  let options = amend(optionsParam, {\n    year: false,\n    month: false,\n    day: false,\n    weekday: false,\n    timeZoneName: false,\n    dateStyle: false\n  });\n  if (!hasTimeOptions(options)) {\n    options = ObjectAssign({}, options, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction yearMonthAmend(optionsParam: OptionsType<Temporal.PlainYearMonth>) {\n  let options = amend(optionsParam, {\n    day: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n  if (!('year' in options || 'month' in options)) {\n    options = ObjectAssign(options, { year: 'numeric', month: 'numeric' });\n  }\n  return options;\n}\n\nfunction monthDayAmend(optionsParam: OptionsType<Temporal.PlainMonthDay>) {\n  let options = amend(optionsParam, {\n    year: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n  if (!('month' in options || 'day' in options)) {\n    options = ObjectAssign({}, options, { month: 'numeric', day: 'numeric' });\n  }\n  return options;\n}\n\nfunction dateAmend(optionsParam: OptionsType<Temporal.PlainDate>) {\n  let options = amend(optionsParam, {\n    hour: false,\n    minute: false,\n    second: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if (!hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction datetimeAmend(optionsParam: OptionsType<Temporal.PlainDateTime>) {\n  let options = amend(optionsParam, { timeZoneName: false });\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\n  let options = optionsParam;\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\n\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return (\n    'hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options\n  );\n}\n\nfunction isTemporalObject(\n  obj: unknown\n): obj is\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainDateTime\n  | Temporal.ZonedDateTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.Instant {\n  return (\n    ES.IsTemporalDate(obj) ||\n    ES.IsTemporalTime(obj) ||\n    ES.IsTemporalDateTime(obj) ||\n    ES.IsTemporalZonedDateTime(obj) ||\n    ES.IsTemporalYearMonth(obj) ||\n    ES.IsTemporalMonthDay(obj) ||\n    ES.IsTemporalInstant(obj)\n  );\n}\n\nfunction sameTemporalType(x: unknown, y: unknown) {\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\n  return true;\n}\n\ntype TypesWithToLocaleString =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime\n  | Temporal.Instant;\n\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n\n  if (ES.IsTemporalTime(temporalObj)) {\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, TIME)\n    };\n  }\n\n  if (ES.IsTemporalYearMonth(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, YM)\n    };\n  }\n\n  if (ES.IsTemporalMonthDay(temporalObj)) {\n    const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, MD)\n    };\n  }\n\n  if (ES.IsTemporalDate(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n    const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, DATE)\n    };\n  }\n\n  if (ES.IsTemporalDateTime(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    let datetime = temporalObj;\n    if (calendar === 'iso8601') {\n      datetime = new DateTime(\n        isoYear,\n        isoMonth,\n        isoDay,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        main[CAL_ID]\n      );\n    }\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, DATETIME)\n    };\n  }\n\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\n    throw new TypeError(\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\n    );\n  }\n\n  if (ES.IsTemporalInstant(temporalObj)) {\n    return {\n      instant: temporalObj,\n      formatter: getPropLazy(main, INST)\n    };\n  }\n\n  return {};\n}\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND } from './ecmascript';\n\nexport class Instant implements Temporal.Instant {\n  constructor(epochNanoseconds: bigint | JSBI) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n\n    const ns = ES.ToBigInt(epochNanoseconds);\n    ES.ValidateEpochNanoseconds(ns);\n    CreateSlots(this);\n    SetSlot(this, EPOCHNANOSECONDS, ns);\n\n    if (DEBUG) {\n      const repr = ES.TemporalInstantToString(this, undefined, 'auto');\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${repr}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get epochSeconds(): Return['epochSeconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, BILLION));\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, MILLION));\n  }\n  get epochMicroseconds(): Return['epochMicroseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return ES.ToBigIntExternal(ES.BigIntFloorDiv(value, THOUSAND));\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromInstant('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromInstant('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalInstant('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalInstant('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const maximumIncrements = {\n      hour: 24,\n      minute: 1440,\n      second: 86400,\n      millisecond: 86400e3,\n      microsecond: 86400e6,\n      nanosecond: 86400e9\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n    return new Instant(roundedNs);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalInstant(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    let timeZone = options.timeZone;\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneSlotValue(timeZone);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundInstant(ns, increment, unit, roundingMode);\n    const roundedInstant = new Instant(roundedNs);\n    return ES.TemporalInstantToString(roundedInstant, timeZone as Temporal.TimeZoneProtocol, precision);\n  }\n  toJSON(): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalInstantToString(this, undefined, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) {\n      throw new TypeError('invalid argument in toZonedDateTime');\n    }\n    const calendarLike = item.calendar;\n    if (calendarLike === undefined) {\n      throw new TypeError('missing calendar property in toZonedDateTime');\n    }\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n    const temporalTimeZoneLike = item.timeZone;\n    if (temporalTimeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property in toZonedDateTime');\n    }\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\n  }\n\n  static fromEpochSeconds(epochSecondsParam: Params['fromEpochSeconds'][0]): Return['fromEpochSeconds'] {\n    const epochSeconds = ES.ToNumber(epochSecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochSeconds), BILLION);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochMilliseconds(\n    epochMillisecondsParam: Params['fromEpochMilliseconds'][0]\n  ): Return['fromEpochMilliseconds'] {\n    const epochMilliseconds = ES.ToNumber(epochMillisecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochMicroseconds(\n    epochMicrosecondsParam: Params['fromEpochMicroseconds'][0]\n  ): Return['fromEpochMicroseconds'] {\n    const epochMicroseconds = ES.ToBigInt(epochMicrosecondsParam);\n    const epochNanoseconds = JSBI.multiply(epochMicroseconds, THOUSAND);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochNanoseconds(\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\n  ): Return['fromEpochNanoseconds'] {\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    if (ES.IsTemporalInstant(item)) {\n      return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    return ES.ToTemporalInstant(item);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalInstant(oneParam);\n    const two = ES.ToTemporalInstant(twoParam);\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.Instant';\n}\n\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass, DefineIntrinsic } from './intrinsicclass';\nimport {\n  CALENDAR_ID,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport type {\n  BuiltinCalendarId,\n  CalendarParams as Params,\n  CalendarReturn as Return,\n  AnyTemporalKey,\n  CalendarSlot\n} from './internaltypes';\n\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst ObjectCreate = Object.create;\nconst ObjectEntries = Object.entries;\nconst OriginalSet = Set;\nconst ReflectOwnKeys = Reflect.ownKeys;\nconst SetPrototypeAdd = Set.prototype.add;\nconst SetPrototypeValues = Set.prototype.values;\n\n/**\n * Shape of internal implementation of each built-in calendar. Note that\n * parameter types are simpler than CalendarProtocol because the `Calendar`\n * class performs validation and parameter normalization before handing control\n * over to CalendarImpl.\n *\n * There are two instances of this interface: one for the ISO calendar and\n * another that handles logic that's the same across all non-ISO calendars. The\n * latter is cloned for each non-ISO calendar at the end of this file.\n */\ninterface CalendarImpl {\n  year(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  month(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): number;\n  monthCode(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): string;\n  day(date: Temporal.PlainDate | Temporal.PlainMonthDay): number;\n  era(date: Temporal.PlainDate | Temporal.PlainYearMonth): string | undefined;\n  eraYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number | undefined;\n  dayOfWeek(date: Temporal.PlainDate): number;\n  dayOfYear(date: Temporal.PlainDate): number;\n  weekOfYear(date: Temporal.PlainDate): number;\n  yearOfWeek(date: Temporal.PlainDate): number;\n  daysInWeek(date: Temporal.PlainDate): number;\n  daysInMonth(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  daysInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  monthsInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  inLeapYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): boolean;\n  dateFromFields(\n    fields: Params['dateFromFields'][0],\n    options: NonNullable<Params['dateFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainDate;\n  yearMonthFromFields(\n    fields: Params['yearMonthFromFields'][0],\n    options: NonNullable<Params['yearMonthFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainYearMonth;\n  monthDayFromFields(\n    fields: Params['monthDayFromFields'][0],\n    options: NonNullable<Params['monthDayFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainMonthDay;\n  dateAdd(\n    date: Temporal.PlainDate,\n    years: number,\n    months: number,\n    weeks: number,\n    days: number,\n    overflow: Overflow,\n    calendar: string\n  ): Temporal.PlainDate;\n  dateUntil(\n    one: Temporal.PlainDate,\n    two: Temporal.PlainDate,\n    largestUnit: 'year' | 'month' | 'week' | 'day'\n  ): { years: number; months: number; weeks: number; days: number };\n  fields(fields: string[]): string[];\n  fieldKeysToIgnore(keys: string[]): string[];\n}\n\ntype CalendarImplementations = {\n  [k in BuiltinCalendarId]: CalendarImpl;\n};\n\n/**\n * Implementations for each calendar.\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\n * at the bottom of the file.\n */\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\n\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nexport class Calendar implements Temporal.Calendar {\n  constructor(idParam: Params['constructor'][0]) {\n    // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n    //       exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: id is required');\n    }\n\n    const id = ES.ToString(idParam);\n    if (!ES.IsBuiltinCalendar(id)) throw new RangeError(`invalid calendar identifier ${id}`);\n    CreateSlots(this);\n    SetSlot(this, CALENDAR_ID, ES.ASCIILowercase(id));\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${id}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get id(): Return['id'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  dateFromFields(\n    fields: Params['dateFromFields'][0],\n    optionsParam: Params['dateFromFields'][1] = undefined\n  ): Return['dateFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].dateFromFields(fields, options, id);\n  }\n  yearMonthFromFields(\n    fields: Params['yearMonthFromFields'][0],\n    optionsParam: Params['yearMonthFromFields'][1] = undefined\n  ): Return['yearMonthFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].yearMonthFromFields(fields, options, id);\n  }\n  monthDayFromFields(\n    fields: Params['monthDayFromFields'][0],\n    optionsParam: Params['monthDayFromFields'][1] = undefined\n  ): Return['monthDayFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].monthDayFromFields(fields, options, id);\n  }\n  fields(fields: Params['fields'][0]): Return['fields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const fieldsArray = [] as string[];\n    const allowed = new Set([\n      'year',\n      'month',\n      'monthCode',\n      'day',\n      'hour',\n      'minute',\n      'second',\n      'millisecond',\n      'microsecond',\n      'nanosecond'\n    ]);\n    for (const name of fields) {\n      if (typeof name !== 'string') throw new TypeError('invalid fields');\n      if (!allowed.has(name)) throw new RangeError(`invalid field name ${name}`);\n      allowed.delete(name);\n      ArrayPrototypePush.call(fieldsArray, name);\n    }\n    return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n  }\n  mergeFields(\n    fieldsParam: Params['mergeFields'][0],\n    additionalFieldsParam: Params['mergeFields'][1]\n  ): Return['mergeFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const fields = ES.ToObject(fieldsParam);\n    const fieldsCopy = ObjectCreate(null);\n    ES.CopyDataProperties(fieldsCopy, fields, [], [undefined]);\n    const additionalFields = ES.ToObject(additionalFieldsParam);\n    const additionalFieldsCopy = ObjectCreate(null);\n    ES.CopyDataProperties(additionalFieldsCopy, additionalFields, [], [undefined]);\n    const additionalKeys = ReflectOwnKeys(additionalFieldsCopy) as (keyof typeof additionalFields)[];\n    const overriddenKeys = impl[GetSlot(this, CALENDAR_ID)].fieldKeysToIgnore(additionalKeys);\n    const merged = ObjectCreate(null);\n    const fieldsKeys = ReflectOwnKeys(fieldsCopy);\n    for (const key of fieldsKeys) {\n      let propValue = undefined;\n      if (ES.Call(ArrayIncludes, overriddenKeys, [key])) propValue = additionalFieldsCopy[key];\n      else propValue = fieldsCopy[key];\n      if (propValue !== undefined) merged[key] = propValue;\n    }\n    ES.CopyDataProperties(merged, additionalFieldsCopy, []);\n    return merged;\n  }\n  dateAdd(\n    dateParam: Params['dateAdd'][0],\n    durationParam: Params['dateAdd'][1],\n    optionsParam: Params['dateAdd'][2] = undefined\n  ): Return['dateAdd'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    const duration = ES.ToTemporalDuration(durationParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { days } = ES.BalanceDuration(\n      GetSlot(duration, DAYS),\n      GetSlot(duration, HOURS),\n      GetSlot(duration, MINUTES),\n      GetSlot(duration, SECONDS),\n      GetSlot(duration, MILLISECONDS),\n      GetSlot(duration, MICROSECONDS),\n      GetSlot(duration, NANOSECONDS),\n      'day'\n    );\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].dateAdd(\n      date,\n      GetSlot(duration, YEARS),\n      GetSlot(duration, MONTHS),\n      GetSlot(duration, WEEKS),\n      days,\n      overflow,\n      id\n    );\n  }\n  dateUntil(\n    oneParam: Params['dateUntil'][0],\n    twoParam: Params['dateUntil'][1],\n    optionsParam: Params['dateUntil'][2] = undefined\n  ): Return['dateUntil'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    let largestUnit = ES.GetTemporalUnit(options, 'largestUnit', 'date', 'auto');\n    if (largestUnit === 'auto') largestUnit = 'day';\n    const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  }\n  year(dateParam: Params['year'][0]): Return['year'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].year(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  month(dateParam: Params['month'][0]): Return['month'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (ES.IsTemporalMonthDay(date)) throw new TypeError('use monthCode on PlainMonthDay instead');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].month(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  monthCode(dateParam: Params['monthCode'][0]): Return['monthCode'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date) && !ES.IsTemporalMonthDay(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthCode(\n      date as Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth\n    );\n  }\n  day(dateParam: Params['day'][0]): Return['day'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalMonthDay(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].day(date as Temporal.PlainDate | Temporal.PlainMonthDay);\n  }\n  era(dateParam: Params['era'][0]): Return['era'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].era(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  eraYear(dateParam: Params['eraYear'][0]): Return['eraYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].eraYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  dayOfWeek(dateParam: Params['dayOfWeek'][0]): Return['dayOfWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n  }\n  dayOfYear(dateParam: Params['dayOfYear'][0]): Return['dayOfYear'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n  }\n  weekOfYear(dateParam: Params['weekOfYear'][0]): Return['weekOfYear'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n  }\n  yearOfWeek(dateParam: Params['yearOfWeek'][0]): Return['yearOfWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].yearOfWeek(date);\n  }\n  daysInWeek(dateParam: Params['daysInWeek'][0]): Return['daysInWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n  }\n  daysInMonth(dateParam: Params['daysInMonth'][0]): Return['daysInMonth'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  daysInYear(dateParam: Params['daysInYear'][0]): Return['daysInYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  monthsInYear(dateParam: Params['monthsInYear'][0]): Return['monthsInYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  inLeapYear(dateParam: Params['inLeapYear'][0]): Return['inLeapYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  toString(): string {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    const calendarSlotValue = ES.ToTemporalCalendarSlotValue(item);\n    return ES.ToTemporalCalendarObject(calendarSlotValue);\n  }\n  [Symbol.toStringTag]!: 'Temporal.Calendar';\n}\n\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\nDefineIntrinsic('Temporal.Calendar.prototype.dateAdd', Calendar.prototype.dateAdd);\nDefineIntrinsic('Temporal.Calendar.prototype.dateFromFields', Calendar.prototype.dateFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.dateUntil', Calendar.prototype.dateUntil);\nDefineIntrinsic('Temporal.Calendar.prototype.day', Calendar.prototype.day);\nDefineIntrinsic('Temporal.Calendar.prototype.dayOfWeek', Calendar.prototype.dayOfWeek);\nDefineIntrinsic('Temporal.Calendar.prototype.dayOfYear', Calendar.prototype.dayOfYear);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInMonth', Calendar.prototype.daysInMonth);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInWeek', Calendar.prototype.daysInWeek);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInYear', Calendar.prototype.daysInYear);\nDefineIntrinsic('Temporal.Calendar.prototype.era', Calendar.prototype.era);\nDefineIntrinsic('Temporal.Calendar.prototype.eraYear', Calendar.prototype.eraYear);\nDefineIntrinsic('Temporal.Calendar.prototype.fields', Calendar.prototype.fields);\nDefineIntrinsic('Temporal.Calendar.prototype.inLeapYear', Calendar.prototype.inLeapYear);\nDefineIntrinsic('Temporal.Calendar.prototype.mergeFields', Calendar.prototype.mergeFields);\nDefineIntrinsic('Temporal.Calendar.prototype.month', Calendar.prototype.month);\nDefineIntrinsic('Temporal.Calendar.prototype.monthCode', Calendar.prototype.monthCode);\nDefineIntrinsic('Temporal.Calendar.prototype.monthDayFromFields', Calendar.prototype.monthDayFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.monthsInYear', Calendar.prototype.monthsInYear);\nDefineIntrinsic('Temporal.Calendar.prototype.weekOfYear', Calendar.prototype.weekOfYear);\nDefineIntrinsic('Temporal.Calendar.prototype.year', Calendar.prototype.year);\nDefineIntrinsic('Temporal.Calendar.prototype.yearMonthFromFields', Calendar.prototype.yearMonthFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.yearOfWeek', Calendar.prototype.yearOfWeek);\n\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n  dateFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['year', 'day']);\n    const overflow = ES.ToTemporalOverflow(options);\n    fields = resolveNonLunisolarMonth(fields);\n    let { year, month, day } = fields;\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n    return ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n  },\n  yearMonthFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['month', 'monthCode', 'year'], ['year']);\n    const overflow = ES.ToTemporalOverflow(options);\n    fields = resolveNonLunisolarMonth(fields);\n    let { year, month } = fields;\n    ({ year, month } = ES.RegulateISOYearMonth(year, month, overflow));\n    return ES.CreateTemporalYearMonth(year, month, calendarSlotValue, /* referenceISODay = */ 1);\n  },\n  monthDayFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['day']);\n    const overflow = ES.ToTemporalOverflow(options);\n    if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n      throw new TypeError('either year or monthCode required with month');\n    }\n    const useYear = fields.monthCode === undefined;\n    const referenceISOYear = 1972;\n    fields = resolveNonLunisolarMonth(fields);\n    let { month, day, year } = fields;\n    ({ month, day } = ES.RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n    return ES.CreateTemporalMonthDay(month, day, calendarSlotValue, referenceISOYear);\n  },\n  fields(fields) {\n    return fields;\n  },\n  fieldKeysToIgnore(keys) {\n    const result = new OriginalSet();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      ES.Call(SetPrototypeAdd, result, [key]);\n      if (key === 'month') {\n        ES.Call(SetPrototypeAdd, result, ['monthCode']);\n      } else if (key === 'monthCode') {\n        ES.Call(SetPrototypeAdd, result, ['month']);\n      }\n    }\n    return [...ES.Call(SetPrototypeValues, result, [])];\n  },\n  dateAdd(date, years, months, weeks, days, overflow, calendarSlotValue) {\n    let year = GetSlot(date, ISO_YEAR);\n    let month = GetSlot(date, ISO_MONTH);\n    let day = GetSlot(date, ISO_DAY);\n    ({ year, month, day } = ES.AddISODate(year, month, day, years, months, weeks, days, overflow));\n    return ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n  },\n  dateUntil(one, two, largestUnit) {\n    return ES.DifferenceISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY),\n      largestUnit\n    );\n  },\n  year(date) {\n    return GetSlot(date, ISO_YEAR);\n  },\n  era() {\n    return undefined;\n  },\n  eraYear() {\n    return undefined;\n  },\n  month(date) {\n    return GetSlot(date, ISO_MONTH);\n  },\n  monthCode(date) {\n    return buildMonthCode(GetSlot(date, ISO_MONTH));\n  },\n  day(date) {\n    return GetSlot(date, ISO_DAY);\n  },\n  dayOfWeek(date) {\n    return ES.DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n  dayOfYear(date) {\n    return ES.DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n  weekOfYear(date) {\n    return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY)).week;\n  },\n  yearOfWeek(date) {\n    return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY)).year;\n  },\n  daysInWeek() {\n    return 7;\n  },\n  daysInMonth(date) {\n    return ES.ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n  },\n  daysInYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    return ES.LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n  },\n  monthsInYear() {\n    return 12;\n  },\n  inLeapYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    return ES.LeapYear(GetSlot(date, ISO_YEAR));\n  }\n};\n\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\n// proposal for ECMA-262. These calendars will be standardized as part of\n// ECMA-402. Code below here includes an implementation of these calendars to\n// validate the Temporal API and to get feedback. However, native non-ISO\n// calendar behavior is at least somewhat implementation-defined, so may not\n// match this polyfill's output exactly.\n//\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\n// to ensure a clean separation between the ISO calendar implementation which is\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\n// ECMA-402.\n//\n// To ensure this separation, the implementation is split. A `CalendarImpl`\n// interface defines the common operations between both ISO and non-ISO\n// calendars.\n\n/**\n * This type is passed through from Calendar#dateFromFields().\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\n */\ntype CalendarDateFields = Params['dateFromFields'][0] & { monthExtra?: string };\n\n/**\n * This is a \"fully populated\" calendar date record. It's only lacking\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\n * which is only used in some cases.\n */\ntype FullCalendarDate = {\n  era?: string;\n  eraYear?: number;\n  year: number;\n  month: number;\n  monthCode: string;\n  day: number;\n  monthExtra?: string;\n};\n\n// The types below are various subsets of calendar dates\ntype CalendarYMD = { year: number; month: number; day: number };\ntype CalendarYM = { year: number; month: number };\ntype CalendarYearOnly = { year: number };\ntype EraAndEraYear = { era: string; eraYear: number };\n\n/** Record representing YMD of an ISO calendar date */\ntype IsoYMD = { year: number; month: number; day: number };\n\ntype Overflow = NonNullable<Temporal.AssignmentOptions['overflow']>;\n\nfunction monthCodeNumberPart(monthCode: string) {\n  if (!monthCode.startsWith('M')) {\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n  }\n  const month = +monthCode.slice(1);\n  if (isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\n  return month;\n}\n\nfunction buildMonthCode(month: number | string, leap = false) {\n  return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\n  calendarDate: T,\n  overflow: Overflow | undefined = undefined,\n  monthsPerYear = 12\n) {\n  let { month, monthCode } = calendarDate;\n  if (monthCode === undefined) {\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\n    // The ISO calendar uses the default (undefined) value because it does\n    // constrain/reject after this method returns. Non-ISO calendars, however,\n    // rely on this function to constrain/reject out-of-range `month` values.\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\n    monthCode = buildMonthCode(month);\n  } else {\n    const numberPart = monthCodeNumberPart(monthCode);\n    if (month !== undefined && month !== numberPart) {\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n    }\n    if (monthCode !== buildMonthCode(numberPart)) {\n      throw new RangeError(`Invalid month code: ${monthCode}`);\n    }\n    month = numberPart;\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n  }\n  return { ...calendarDate, month, monthCode };\n}\n\ntype CachedTypes = Temporal.PlainYearMonth | Temporal.PlainDate | Temporal.PlainMonthDay;\n\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n  map = new Map();\n  calls = 0;\n  now: number;\n  hits = 0;\n  misses = 0;\n  constructor(cacheToClone?: OneObjectCache) {\n    this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n    if (cacheToClone !== undefined) {\n      let i = 0;\n      for (const entry of cacheToClone.map.entries()) {\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\n        this.map.set(...entry);\n      }\n    }\n  }\n  get(key: string) {\n    const result = this.map.get(key);\n    if (result) {\n      this.hits++;\n      this.report();\n    }\n    this.calls++;\n    return result;\n  }\n  set(key: string, value: unknown) {\n    this.map.set(key, value);\n    this.misses++;\n    this.report();\n  }\n  report() {\n    /*\n    if (this.calls === 0) return;\n    const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n    const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n    console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n    */\n  }\n  setObject(obj: CachedTypes) {\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\n    OneObjectCache.objectMap.set(obj, this);\n    this.report();\n  }\n\n  static objectMap = new WeakMap();\n  static MAX_CACHE_ENTRIES = 1000;\n\n  /**\n   * Returns a WeakMap-backed cache that's used to store expensive results\n   * that are associated with a particular Temporal object instance.\n   *\n   * @param obj - object to associate with the cache\n   */\n  static getCacheForObject(obj: CachedTypes) {\n    let cache = OneObjectCache.objectMap.get(obj);\n    if (!cache) {\n      cache = new OneObjectCache();\n      OneObjectCache.objectMap.set(obj, cache);\n    }\n    return cache;\n  }\n}\n\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\n  const yearString = ES.ISOYearString(isoYear);\n  const monthString = ES.ISODateTimePartString(isoMonth);\n  const dayString = ES.ISODateTimePartString(isoDay);\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\n\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\n  return {\n    years: one.year - two.year,\n    months: one.month - two.month,\n    days: one.day - two.day\n  };\n}\n\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nabstract class HelperBase {\n  abstract id: BuiltinCalendarId;\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\n  abstract estimateIsoDate(calendarDate: CalendarYMD): IsoYMD;\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: IsoYMD): T;\n  constantEra?: string;\n  checkIcuBugs?(isoDate: IsoYMD): void;\n  private formatter?: globalThis.Intl.DateTimeFormat;\n  getFormatter() {\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n    // calendars that are used. Note that the nonIsoHelperBase object is spread\n    // into each each calendar's implementation before any cache is created, so\n    // each calendar gets its own separate cached formatter.\n    if (typeof this.formatter === 'undefined') {\n      this.formatter = new IntlDateTimeFormat(`en-US-u-ca-${this.id}`, {\n        day: 'numeric',\n        month: 'numeric',\n        year: 'numeric',\n        era: this.eraLength,\n        timeZone: 'UTC'\n      });\n    }\n    return this.formatter;\n  }\n  isoToCalendarDate(isoDate: IsoYMD, cache: OneObjectCache): FullCalendarDate {\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n\n    const dateTimeFormat = this.getFormatter();\n    let parts, isoString;\n    try {\n      isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n      parts = dateTimeFormat.formatToParts(new Date(isoString));\n    } catch (e: unknown) {\n      throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n    }\n    const result: Partial<FullCalendarDate> = {};\n    for (let { type, value } of parts) {\n      if (type === 'year') result.eraYear = +value;\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n      if (type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) result.eraYear = +value;\n      if (type === 'month') {\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n          throw new RangeError(`Unexpected month: ${value}`);\n        }\n        // If the month has no numeric part (should only see this for the Hebrew\n        // calendar with newer FF / Chromium versions; see\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n        // placeholder month index of `1` and rely on the derived class to\n        // calculate the correct month index from the month name stored in\n        // `monthExtra`.\n        result.month = matches[1] ? +matches[1] : 1;\n        if (result.month < 1) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\n          );\n        }\n        if (result.month > 13) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n          );\n        }\n\n        // The ICU formats for the Hebrew calendar no longer support a numeric\n        // month format. So we'll rely on the derived class to interpret it.\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\n        // \"bis\" indicating a leap month.\n        if (matches[2]) result.monthExtra = matches[2];\n      }\n      if (type === 'day') result.day = +value;\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\n        // The convention for Temporal era values is lowercase, so following\n        // that convention in this prototype. Punctuation is removed, accented\n        // letters are normalized, and spaces are replaced with dashes.\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n        // The call to normalize() and the replacement regex deals with era\n        // names that contain non-ASCII characters like Japanese eras. Also\n        // ignore extra content in parentheses like JPN era date ranges.\n        value = value.split(' (')[0];\n        result.era = value\n          .normalize('NFD')\n          .replace(/[^-0-9 \\p{L}]/gu, '')\n          .replace(' ', '-')\n          .toLowerCase();\n      }\n    }\n    if (result.eraYear === undefined) {\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n      // output of Intl.DateTimeFormat.formatToParts.\n      throw new RangeError(\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n      );\n    }\n    // Translate eras that may be handled differently by Temporal vs. by Intl\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n    if (this.reviseIntlEra) {\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n      result.era = era;\n      result.eraYear = eraYear;\n    }\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\n\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.month === undefined) throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n    cache.set(key, calendarDate);\n    // Also cache the reverse mapping\n    ['constrain', 'reject'].forEach((overflow) => {\n      const keyReverse = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: calendarDate.year,\n        month: calendarDate.month,\n        day: calendarDate.day,\n        overflow,\n        id: this.id\n      });\n      cache.set(keyReverse, isoDate);\n    });\n    return calendarDate;\n  }\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\n    const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n    // the derived class must deal with it.\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\n    if (day === undefined) throw new RangeError('Missing day');\n    if (monthCode !== undefined) {\n      if (typeof monthCode !== 'string') {\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n      }\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    if (this.constantEra) {\n      if (era !== undefined && era !== this.constantEra) {\n        throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n      }\n      if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n        throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n      }\n    }\n    if (this.hasEra) {\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n      }\n    }\n  }\n  /**\n   * Allows derived calendars to add additional fields and/or to make\n   * adjustments e.g. to set the era based on the date or to revise the month\n   * number in lunisolar calendars per\n   * https://github.com/tc39/proposal-temporal/issues/1203.\n   *\n   * The base implementation fills in missing values by assuming the simplest\n   * possible calendar:\n   * - no eras or a constant era defined in `.constantEra`\n   * - non-lunisolar calendar (no leap months)\n   * */\n  adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache: OneObjectCache | undefined = undefined,\n    overflow: Overflow = 'constrain',\n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\n    let calendarDate = calendarDateParam;\n    this.validateCalendarDate(calendarDate);\n    // For calendars that always use the same era, set it here so that derived\n    // calendars won't need to implement this method simply to set the era.\n    if (this.constantEra) {\n      // year and eraYear always match when there's only one possible era\n      const { year, eraYear } = calendarDate;\n      calendarDate = {\n        ...calendarDate,\n        era: this.constantEra,\n        year: year !== undefined ? year : eraYear,\n        eraYear: eraYear !== undefined ? eraYear : year\n      };\n    }\n\n    const largestMonth = this.monthsInYear(calendarDate as CalendarYearOnly, cache);\n    let { month, monthCode } = calendarDate;\n\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\n  }\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let { month, day } = calendarDate;\n    if (overflow === 'reject') {\n      ES.RejectToRange(month, 1, largestMonth);\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n    } else {\n      month = ES.ConstrainToRange(month, 1, largestMonth);\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n    }\n    return { ...calendarDate, month, day };\n  }\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): IsoYMD {\n    const originalDate = dateParam as Partial<FullCalendarDate>;\n    // First, normalize the calendar date to ensure that (year, month, day)\n    // are all present, converting monthCode and eraYear if needed.\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\n    // not in this particular year, may not be caught here for some calendars.\n    // If so, these will be handled lower below.\n    date = this.regulateMonthDayNaive(date, overflow, cache);\n\n    const { year, month, day } = date;\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n    let cached = cache.get(key);\n    if (cached) return cached;\n    // If YMD are present in the input but the input has been constrained\n    // already, then cache both the original value and the constrained value.\n    let keyOriginal;\n    if (\n      originalDate.year !== undefined &&\n      originalDate.month !== undefined &&\n      originalDate.day !== undefined &&\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\n    ) {\n      keyOriginal = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: originalDate.year,\n        month: originalDate.month,\n        day: originalDate.day,\n        overflow,\n        id: this.id\n      });\n      cached = cache.get(keyOriginal);\n      if (cached) return cached;\n    }\n\n    // First, try to roughly guess the result\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\n    const calculateSameMonthResult = (diffDays: number) => {\n      // If the estimate is in the same year & month as the target, then we can\n      // calculate the result exactly and short-circuit any additional logic.\n      // This optimization assumes that months are continuous. It would break if\n      // a calendar skipped days, like the Julian->Gregorian switchover. But the\n      // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n      // that's currently detected by `checkIcuBugs()` which will throw. So\n      // this optimization should be safe for all ICU calendars.\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n      if (date.day > this.minimumMonthLength(date)) {\n        // There's a chance that the calendar date is out of range. Throw or\n        // constrain if so.\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n          if (overflow === 'reject') {\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n          }\n          // Back up a day at a time until we're not hanging over the month end\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        }\n      }\n      return testIsoEstimate;\n    };\n    let sign = 0;\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n    let diff = simpleDateDiff(date, roundtripEstimate);\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      diff = simpleDateDiff(date, roundtripEstimate);\n      if (diff.years === 0 && diff.months === 0) {\n        isoEstimate = calculateSameMonthResult(diff.days);\n      } else {\n        sign = this.compareCalendarDates(date, roundtripEstimate);\n      }\n    }\n    // If the initial guess is not in the same month, then then bisect the\n    // distance to the target, starting with 8 days per step.\n    let increment = 8;\n    while (sign) {\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n      const oldRoundtripEstimate = roundtripEstimate;\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      const oldSign = sign;\n      sign = this.compareCalendarDates(date, roundtripEstimate);\n      if (sign) {\n        diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years === 0 && diff.months === 0) {\n          isoEstimate = calculateSameMonthResult(diff.days);\n          // Signal the loop condition that there's a match.\n          sign = 0;\n        } else if (oldSign && sign !== oldSign) {\n          if (increment > 1) {\n            // If the estimate overshot the target, try again with a smaller increment\n            // in the reverse direction.\n            increment /= 2;\n          } else {\n            // Increment is 1, and neither the previous estimate nor the new\n            // estimate is correct. The only way that can happen is if the\n            // original date was an invalid value that will be constrained or\n            // rejected here.\n            if (overflow === 'reject') {\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n            } else {\n              // To constrain, pick the earliest value\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n              // If current value is larger, then back up to the previous value.\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\n              sign = 0;\n            }\n          }\n        }\n      }\n    }\n    cache.set(key, isoEstimate);\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\n    if (\n      date.year === undefined ||\n      date.month === undefined ||\n      date.day === undefined ||\n      date.monthCode === undefined ||\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\n    ) {\n      throw new RangeError('Unexpected missing property');\n    }\n    return isoEstimate;\n  }\n  temporalToCalendarDate(\n    date: Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n    const result = this.isoToCalendarDate(isoDate, cache);\n    return result;\n  }\n  compareCalendarDates(date1Param: Partial<CalendarYMD>, date2Param: Partial<CalendarYMD>): 0 | 1 | -1 {\n    // `date1` and `date2` are already records. The calls below simply validate\n    // that all three required fields are present.\n    const date1 = ES.PrepareTemporalFields(date1Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n    const date2 = ES.PrepareTemporalFields(date2Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\n    return 0;\n  }\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n    return this.isoToCalendarDate(isoDate, cache);\n  }\n  addDaysIso(isoDate: IsoYMD, days: number): IsoYMD {\n    const added = ES.AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n    return added;\n  }\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIso = this.addDaysIso(isoDate, days);\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n    return addedCalendar;\n  }\n  addMonthsCalendar(\n    calendarDateParam: CalendarYMD,\n    months: number,\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): CalendarYMD {\n    let calendarDate = calendarDateParam;\n    const { day } = calendarDate;\n    for (let i = 0, absMonths = MathAbs(months); i < absMonths; i++) {\n      const { month } = calendarDate;\n      const oldCalendarDate = calendarDate;\n      const days =\n        months < 0\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n          : this.daysInMonth(calendarDate, cache);\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n      let addedIso = this.addDaysIso(isoDate, days);\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\n\n      // Normally, we can advance one month by adding the number of days in the\n      // current month. However, if we're at the end of the current month and\n      // the next month has fewer days, then we rolled over to the after-next\n      // month. Below we detect this condition and back up until we're back in\n      // the desired month.\n      if (months > 0) {\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\n          addedIso = this.addDaysIso(addedIso, -1);\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\n        }\n      }\n\n      if (calendarDate.day !== day) {\n        // try to retain the original day-of-month, if possible\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n      }\n    }\n    if (overflow === 'reject' && calendarDate.day !== day) {\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n    }\n    return calendarDate;\n  }\n  addCalendar(\n    calendarDate: CalendarYMD & { monthCode: string },\n    { years = 0, months = 0, weeks = 0, days = 0 },\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const { year, day, monthCode } = calendarDate;\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\n    const initialDays = days + weeks * 7;\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n    return addedDays;\n  }\n  untilCalendar(\n    calendarOne: FullCalendarDate,\n    calendarTwo: FullCalendarDate,\n    largestUnit: Temporal.DateUnit,\n    cache: OneObjectCache\n  ): { years: number; months: number; weeks: number; days: number } {\n    let days = 0;\n    let weeks = 0;\n    let months = 0;\n    let years = 0;\n    switch (largestUnit) {\n      case 'day':\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        break;\n      case 'week': {\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        days = totalDays % 7;\n        weeks = (totalDays - days) / 7;\n        break;\n      }\n      case 'month':\n      case 'year': {\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n        if (!sign) {\n          return { years: 0, months: 0, weeks: 0, days: 0 };\n        }\n        const diffYears = calendarTwo.year - calendarOne.year;\n        const diffDays = calendarTwo.day - calendarOne.day;\n        if (largestUnit === 'year' && diffYears) {\n          let diffInYearSign = 0;\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\n        }\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n        // Now we have less than one year remaining. Add one month at a time\n        // until we go over the target, then back up one month and calculate\n        // remaining days and weeks.\n        let current;\n        let next: CalendarYMD = yearsAdded;\n        do {\n          months += sign;\n          current = next;\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n          if (next.day !== calendarOne.day) {\n            // In case the day was constrained down, try to un-constrain it\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n          }\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n        months -= sign; // correct for loop above which overshoots by 1\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n        days = remainingDays;\n        break;\n      }\n    }\n    return { years, months, weeks, days };\n  }\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    // Add enough days to roll over to the next month. One we're in the next\n    // month, we can calculate the length of the current month. NOTE: This\n    // algorithm assumes that months are continuous. It would break if a\n    // calendar skipped days, like the Julian->Gregorian switchover. But the\n    // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n    // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n    // that's currently detected by `checkIcuBugs()` which will throw. So this\n    // code should be safe for all ICU calendars.\n    const { day } = calendarDate;\n    const max = this.maximumMonthLength(calendarDate);\n    const min = this.minimumMonthLength(calendarDate);\n    // easiest case: we already know the month length if min and max are the same.\n    if (min === max) return min;\n\n    // Add enough days to get into the next month, without skipping it\n    const increment = day <= max - min ? max : min;\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n\n    // Now back up to the last day of the original month\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n    return endOfMonthCalendar.day;\n  }\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    const { day, month, year } = calendarDate;\n\n    // Check to see if we already know the month length, and return it if so\n    const previousMonthYear = month > 1 ? year : year - 1;\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\n    const min = this.minimumMonthLength(previousMonthDate);\n    const max = this.maximumMonthLength(previousMonthDate);\n    if (min === max) return max;\n\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n    return lastDayOfPreviousMonthCalendar.day;\n  }\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n  }\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n  }\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n    return this.isoDaysUntil(oneIso, twoIso);\n  }\n  isoDaysUntil(oneIso: IsoYMD, twoIso: IsoYMD): number {\n    const duration = ES.DifferenceISODate(\n      oneIso.year,\n      oneIso.month,\n      oneIso.day,\n      twoIso.year,\n      twoIso.month,\n      twoIso.day,\n      'day'\n    );\n    return duration.days;\n  }\n  // The short era format works for all calendars except Japanese, which will\n  // override.\n  eraLength: Intl.DateTimeFormatOptions['era'] = 'short';\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  hasEra = true;\n  // See https://github.com/tc39/proposal-temporal/issues/1784\n  erasBeginMidYear = false;\n  monthDayFromFields(fields: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): IsoYMD {\n    let { monthCode, day } = fields;\n    if (monthCode === undefined) {\n      let { year, era, eraYear } = fields;\n      if (year === undefined && (era === undefined || eraYear === undefined)) {\n        throw new TypeError('when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required');\n      }\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\n    }\n\n    let isoYear, isoMonth, isoDay;\n    let closestCalendar, closestIso;\n    // Look backwards starting from one of the calendar years spanning ISO year\n    // 1972, up to 100 calendar years prior, to find a year that has this month\n    // and day. Normal months and days will match immediately, but for leap days\n    // and leap months we may have to look for a while.\n    const startDateIso = { year: 1972, month: 12, day: 31 };\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\n    // Note: relies on lexicographical ordering of monthCodes\n    const calendarYear =\n      calendarOfStartDateIso.monthCode > monthCode ||\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\n        ? calendarOfStartDateIso.year\n        : calendarOfStartDateIso.year - 1;\n    for (let i = 0; i < 100; i++) {\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\n        { day, monthCode, year: calendarYear - i },\n        cache\n      );\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n        return { month: isoMonth, day: isoDay, year: isoYear };\n      } else if (overflow === 'constrain') {\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\n        if (\n          closestCalendar === undefined ||\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n            roundTripCalendarDate.day > closestCalendar.day)\n        ) {\n          closestCalendar = roundTripCalendarDate;\n          closestIso = isoDate;\n        }\n      }\n    }\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n  }\n}\n\ninterface HebrewMonthInfo {\n  [m: string]: (\n    | {\n        leap: undefined;\n        regular: number;\n      }\n    | {\n        leap: number;\n        regular: undefined;\n      }\n    | {\n        leap: number;\n        regular: number;\n      }\n  ) & {\n    monthCode: string;\n    days:\n      | number\n      | {\n          min: number;\n          max: number;\n        };\n  };\n}\n\nclass HebrewHelper extends HelperBase {\n  id = 'hebrew' as const;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    const { year } = calendarDate;\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\n    // also has per-year changes to the number of days of Heshvan and Kislev.\n    // Given that these can be calculated by counting the number of days in\n    // those months, I assume that these DO NOT need to be exposed as\n    // Hebrew-only prototype fields or methods.\n    return (7 * year + 1) % 19 < 7;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly) {\n    return this.inLeapYear(calendarDate) ? 13 : 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'min');\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'max');\n  }\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\n    const { month, year } = calendarDate;\n    const monthCode = this.getMonthCode(year, month);\n    const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\n    const daysInMonth = monthInfo[1].days;\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n  }\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = calendarDate;\n    return { year: year - 3760, month: 1, day: 1 };\n  }\n  months: HebrewMonthInfo = {\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n  };\n  getMonthCode(year: number, month: number) {\n    if (this.inLeapYear({ year })) {\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n    } else {\n      return buildMonthCode(month);\n    }\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    // The incoming type is actually CalendarDate (same as args to\n    // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n    // reassignments below, so as an alternative to 10+ type casts, we'll lie\n    // here and claim that the type has `day` and `year` filled in already.\n    let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate as Omit<\n      typeof calendarDate,\n      'year' | 'day'\n    > & { year: number; day: number };\n    if (year === undefined && eraYear !== undefined) year = eraYear;\n    if (eraYear === undefined && year !== undefined) eraYear = year;\n    if (fromLegacyDate) {\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n      // output returns the numeric equivalent of `month` as a string, meaning\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n      // means Adar. In this case, `month` will already be correct and no action\n      // is needed. However, in Node 14 and later formatToParts returns the name\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n      // correct `month` using the string name as a key.\n      if (monthExtra) {\n        const monthInfo = this.months[monthExtra];\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n      }\n      // Because we're getting data from legacy Date, then `month` will always be present\n      monthCode = this.getMonthCode(year, month as number);\n      const result = { year, month: month as number, day, era: undefined as string | undefined, eraYear, monthCode };\n      return result;\n    } else {\n      // When called without input coming from legacy Date output, simply ensure\n      // that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (month === undefined) {\n        if ((monthCode as string).endsWith('L')) {\n          if (monthCode !== 'M05L') {\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n          }\n          month = 6;\n          if (!this.inLeapYear({ year })) {\n            if (overflow === 'reject') {\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n            } else {\n              // constrain to same day of next month (Adar)\n              month = 6;\n              monthCode = 'M06';\n            }\n          }\n        } else {\n          month = monthCodeNumberPart(monthCode as string);\n          // if leap month is before this one, the month index is one more than the month code\n          if (this.inLeapYear({ year }) && month >= 6) month++;\n          const largestMonth = this.monthsInYear({ year });\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n      } else {\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n        } else {\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n        }\n        if (monthCode === undefined) {\n          monthCode = this.getMonthCode(year, month);\n        } else {\n          const calculatedMonthCode = this.getMonthCode(year, month);\n          if (calculatedMonthCode !== monthCode) {\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n          }\n        }\n      }\n      return { ...calendarDate, day, month, monthCode: monthCode as string, year, eraYear };\n    }\n  }\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  override hasEra = false;\n}\n\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nabstract class IslamicBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // In leap years, the 12th month has 30 days. In non-leap years: 29.\n    const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n    return days === 30;\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n  DAYS_PER_ISO_YEAR = 365.2425;\n  override constantEra = 'ah';\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: MathFloor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n  }\n}\n\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n  id = 'islamic' as const;\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n  id = 'islamic-umalqura' as const;\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n  id = 'islamic-tbla' as const;\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n  id = 'islamic-civil' as const;\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n  id = 'islamic-rgsa' as const;\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n  id = 'islamicc' as const;\n}\n\nclass PersianHelper extends HelperBase {\n  id = 'persian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // Same logic (count days in the last month) for Persian as for Islamic,\n    // even though Persian is solar and Islamic is lunar.\n    return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 29;\n    return month <= 6 ? 31 : 30;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 30;\n    return month <= 6 ? 31 : 30;\n  }\n  override constantEra = 'ap';\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: year + 621, month: 1, day: 1 };\n  }\n}\n\ninterface IndianMonthInfo {\n  [month: number]: {\n    length: number;\n    month: number;\n    day: number;\n    leap?: {\n      length: number;\n      month: number;\n      day: number;\n    };\n    nextYear?: true | undefined;\n  };\n}\n\nclass IndianHelper extends HelperBase {\n  id = 'indian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\n    // the result is a leap year in the Gregorian calendar, then the Saka year\n    // is a leap year as well.\n    return isGregorianLeapYear(calendarDate.year + 78);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  override constantEra = 'saka';\n  // Indian months always start at the same well-known Gregorian month and\n  // day. So this conversion is easy and fast. See\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\n  months: IndianMonthInfo = {\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n    2: { length: 31, month: 4, day: 21 },\n    3: { length: 31, month: 5, day: 22 },\n    4: { length: 31, month: 6, day: 22 },\n    5: { length: 31, month: 7, day: 23 },\n    6: { length: 31, month: 8, day: 23 },\n    7: { length: 30, month: 9, day: 23 },\n    8: { length: 30, month: 10, day: 23 },\n    9: { length: 30, month: 11, day: 22 },\n    10: { length: 30, month: 12, day: 22 },\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\n  };\n  getMonthInfo(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    let monthInfo = this.months[month];\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\n    return monthInfo;\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n    // calendar fast!\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const monthInfo = this.getMonthInfo(calendarDate);\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n    const isoMonth = monthInfo.month;\n    const isoDay = monthInfo.day;\n    const isoDate = ES.AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n    return isoDate;\n  }\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n  // expected.\n  vulnerableToBceBug =\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n  override checkIcuBugs(isoDate: IsoYMD) {\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\n      throw new RangeError(\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n      );\n    }\n  }\n}\n\n/**\n * Era metadata defined for each calendar.\n * TODO: instead of optional properties, this should really have rules\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\n *  */\ninterface InputEra {\n  /** name of the era */\n  name: string;\n\n  /**\n   * Signed calendar year where this era begins.Will be\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\n   * numbering starts at the beginning of the anchor era, which is true\n   * for all ICU calendars except Japanese. If an era starts mid-year\n   * then a calendar month and day are included. Otherwise\n   * `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch?: { year: number; month: number; day: number };\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: string;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n/**\n * Transformation of the `InputEra` type with all fields filled in by\n * `adjustEras()`\n * */\ninterface Era {\n  /** name of the era */\n  name: string;\n\n  /**\n   * alternate name of the era used in old versions of ICU data\n   * format is `era{n}` where n is the zero-based index of the era\n   * with the oldest era being 0.\n   * */\n  genericName: string;\n\n  /**\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\n   * eras) for the anchor era assuming that `year` numbering starts at the\n   * beginning of the anchor era, which is true for all ICU calendars except\n   * Japanese. For input, the month and day are optional. If an era starts\n   * mid-year then a calendar month and day are included.\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch: CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch: IsoYMD;\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: Era;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\n  let eras: (InputEra | Era)[] = erasParam;\n  if (eras.length === 0) {\n    throw new RangeError('Invalid era data: eras are required');\n  }\n  if (eras.length === 1 && eras[0].reverseOf) {\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n  }\n  if (eras.length === 1 && !eras[0].name) {\n    throw new RangeError('Invalid era data: at least one named era is required');\n  }\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\n    throw new RangeError('Invalid era data: only one era can count years backwards');\n  }\n\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\n  // anchor.\n  let anchorEra: Era | InputEra | undefined;\n  eras.forEach((e) => {\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n      anchorEra = e;\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n    } else if (!e.name) {\n      throw new RangeError('If era name is blank, it must be the anchor era');\n    }\n  });\n\n  // If the era name is undefined, then it's an anchor that doesn't interact\n  // with eras at all. For example, Japanese `year` is always the same as ISO\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n  // Strip it from the list that's returned.\n  eras = eras.filter((e) => e.name);\n\n  eras.forEach((e) => {\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n    // Replace the string-valued \"reverseOf\" property with the actual era object\n    // that's reversed.\n    const { reverseOf } = e;\n    if (reverseOf) {\n      const reversedEra = eras.find((era) => era.name === reverseOf);\n      if (reversedEra === undefined) throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n      e.reverseOf = reversedEra as Era;\n      e.anchorEpoch = reversedEra.anchorEpoch;\n      e.isoEpoch = reversedEra.isoEpoch;\n    }\n    type YMD = {\n      year: number;\n      month: number;\n      day: number;\n    };\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\n  });\n\n  // Ensure that the latest epoch is first in the array. This lets us try to\n  // match eras in index order, with the last era getting the remaining older\n  // years. Any reverse-signed era must be at the end.\n  ArraySort.call(eras, (e1, e2) => {\n    if (e1.reverseOf) return 1;\n    if (e2.reverseOf) return -1;\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\n    return e2.isoEpoch.year - e1.isoEpoch.year;\n  });\n\n  // If there's a reversed era, then the one before it must be the era that's\n  // being reversed.\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\n  if (lastEraReversed) {\n    if (lastEraReversed !== eras[eras.length - 2]) throw new RangeError('Invalid era data: invalid reverse-sign era');\n  }\n\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n  // zero-based index, with the oldest era being zero. This format is used by\n  // older versions of ICU data.\n  eras.forEach((e, i) => {\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\n  });\n\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\n}\n\nfunction isGregorianLeapYear(year: number) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n/** Base for all Gregorian-like calendars. */\nabstract class GregorianBaseHelper extends HelperBase {\n  id: BuiltinCalendarId;\n  eras: Era[];\n  anchorEra: Era;\n\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super();\n    this.id = id;\n    const { eras, anchorEra } = adjustEras(originalEras);\n    this.anchorEra = anchorEra;\n    this.eras = eras;\n  }\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // Calendars that don't override this method use the same months and leap\n    // years as Gregorian. Once we know the ISO year corresponding to the\n    // calendar year, we'll know if it's a leap year or not.\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n    return isGregorianLeapYear(year);\n  }\n  monthsInYear(/* calendarDate */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM): number {\n    const { month } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n  maximumMonthLength(calendarDate: CalendarYM): number {\n    return this.minimumMonthLength(calendarDate);\n  }\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\n  completeEraYear(calendarDate: Partial<FullCalendarDate>) {\n    const checkField = (name: keyof FullCalendarDate, value: string | number | undefined) => {\n      const currentValue = calendarDate[name];\n      if (currentValue != null && currentValue != value) {\n        throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n      }\n    };\n    const eraFromYear = (year: number) => {\n      let eraYear;\n      const adjustedCalendarDate = { ...calendarDate, year };\n      const matchingEra = this.eras.find((e, i) => {\n        if (i === this.eras.length - 1) {\n          if (e.reverseOf) {\n            // This is a reverse-sign era (like BCE) which must be the oldest\n            // era. Count years backwards.\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n            eraYear = e.anchorEpoch.year - year;\n            return true;\n          }\n          // last era always gets all \"leftover\" (older than epoch) years,\n          // so no need for a comparison like below.\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n        if (comparison >= 0) {\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        return false;\n      });\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\n      return { eraYear: eraYear as unknown as number, era: matchingEra.name };\n    };\n\n    let { year, eraYear, era } = calendarDate;\n    if (year != null) {\n      ({ eraYear, era } = eraFromYear(year));\n      checkField('era', era);\n      checkField('eraYear', eraYear);\n    } else if (eraYear != null) {\n      const matchingEra =\n        era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n      if (eraYear < 1 && matchingEra.reverseOf) {\n        throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n      }\n      if (matchingEra.reverseOf) {\n        year = matchingEra.anchorEpoch.year - eraYear;\n      } else {\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n      }\n      checkField('year', year);\n      // We'll accept dates where the month/day is earlier than the start of\n      // the era or after its end as long as it's in the same year. If that\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\n      // the `year`.\n      ({ eraYear, era } = eraFromYear(year));\n    } else {\n      throw new RangeError('Either `year` or `eraYear` and `era` are required');\n    }\n    return { ...calendarDate, year, eraYear, era };\n  }\n  override adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain'\n  ): FullCalendarDate {\n    let calendarDate = calendarDateParam;\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n    const { month, monthCode } = calendarDate;\n    if (month === undefined) calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode as string) };\n    this.validateCalendarDate(calendarDate);\n    calendarDate = this.completeEraYear(calendarDate);\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const { year, month, day } = calendarDate;\n    const { anchorEra } = this;\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n  }\n  // Several calendars based on the Gregorian calendar use Julian dates (not\n  // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n  v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n    .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n    .startsWith('12');\n  calendarIsVulnerableToJulianBug = false;\n  override checkIcuBugs(isoDate: IsoYMD) {\n    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n      const beforeJulianSwitch = ES.CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n      if (beforeJulianSwitch) {\n        throw new RangeError(\n          `calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n            ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)'\n        );\n      }\n    }\n  }\n}\n\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super(id, originalEras);\n  }\n  override inLeapYear(calendarDate: CalendarYearOnly) {\n    // Leap years happen one year before the Julian leap year. Note that this\n    // calendar is based on the Julian calendar which has a leap year every 4\n    // years, unlike the Gregorian calendar which doesn't have leap years on\n    // years divisible by 100 except years divisible by 400.\n    //\n    // Note that we're assuming that leap years in before-epoch times match\n    // how leap years are defined now. This is probably not accurate but I'm\n    // not sure how better to do it.\n    const { year } = calendarDate;\n    return (year + 1) % 4 === 0;\n  }\n  override monthsInYear(/* calendarDate */) {\n    return 13;\n  }\n  override minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\n    return 30;\n  }\n  override maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minimumMonthLength(calendarDate);\n  }\n}\n\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n  }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('coptic', [\n      { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n      { name: 'era0', reverseOf: 'era1' }\n    ]);\n  }\n}\n\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethiopic', [\n      { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n      { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n    ]);\n  }\n}\n\nclass RocHelper extends GregorianBaseHelper {\n  constructor() {\n    super('roc', [\n      { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n      { name: 'before-roc', reverseOf: 'minguo' }\n    ]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n}\n\nclass BuddhistHelper extends GregorianBaseHelper {\n  constructor() {\n    super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n}\n\nclass GregoryHelper extends GregorianBaseHelper {\n  constructor() {\n    super('gregory', [\n      { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n      { name: 'bce', reverseOf: 'ce' }\n    ]);\n  }\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\n    let { era, eraYear } = calendarDate;\n    // Firefox 96 introduced a bug where the `'short'` format of the era\n    // option mistakenly returns the one-letter (narrow) format instead. The\n    // code below handles either the correct or Firefox-buggy format. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n    if (era === 'bc' || era === 'b') era = 'bce';\n    if (era === 'ad' || era === 'a') era = 'ce';\n    return { era, eraYear } as T;\n  }\n}\n\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n  constructor() {\n    super('japanese', [\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n      { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n      { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n      { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n      { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n      { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n      { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n      { name: 'bce', reverseOf: 'ce' }\n    ]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n\n  // The last 3 Japanese eras confusingly return only one character in the\n  // default \"short\" era, so need to use the long format.\n  override eraLength = 'long' as const;\n\n  override erasBeginMidYear = true;\n\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: IsoYMD): T {\n    const { era, eraYear } = calendarDate;\n    const { year: isoYear } = isoDate;\n    if (this.eras.find((e) => e.name === era)) return { era, eraYear } as T;\n    return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear }) as T;\n  }\n}\n\ninterface ChineseMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth: number };\n}\ninterface ChineseDraftMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth?: number };\n}\n\nabstract class ChineseBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    const months = this.getMonthList(calendarDate.year, cache);\n    return ObjectEntries(months).length === 13;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\n    if (calendarYear === undefined) {\n      throw new TypeError('Missing year');\n    }\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n    const dateTimeFormat = this.getFormatter();\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n      const legacyDate = new Date(isoStringFeb1);\n      // Now add the requested number of days, which may wrap to the next month.\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n      const calendarMonthString = (newYearGuess.find((tv) => tv.type === 'month') as Intl.DateTimeFormatPart).value;\n      const calendarDay = +(newYearGuess.find((tv) => tv.type === 'day') as Intl.DateTimeFormatPart).value;\n      let calendarYearToVerify: globalThis.Intl.DateTimeFormatPart | number | undefined = newYearGuess.find(\n        (tv) => (tv.type as string) === 'relatedYear'\n      );\n      if (calendarYearToVerify !== undefined) {\n        calendarYearToVerify = +calendarYearToVerify.value;\n      } else {\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n        // output of Intl.DateTimeFormat.formatToParts.\n        throw new RangeError(\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n        );\n      }\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\n    };\n\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\n    // the first month or near the end of the last month of the previous year.\n    let isoDaysDelta = 17;\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n\n    // If we didn't guess the first month correctly, add (almost in some months)\n    // a lunar month\n    if (calendarMonthString !== '1') {\n      isoDaysDelta += 29;\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n    }\n\n    // Now back up to near the start of the first month, but not too near that\n    // off-by-one issues matter.\n    isoDaysDelta -= calendarDay - 5;\n    const result = {} as ChineseDraftMonthInfo;\n    let monthIndex = 1;\n    let oldCalendarDay: number | undefined;\n    let oldMonthString: string | undefined;\n    let done = false;\n    do {\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n      if (oldCalendarDay) {\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\n      }\n      if (calendarYearToVerify !== calendarYear) {\n        done = true;\n      } else {\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\n        // Move to the next month. Because months are sometimes 29 days, the day of the\n        // calendar month will move forward slowly but not enough to flip over to a new\n        // month before the loop ends at 12-13 months.\n        isoDaysDelta += 30;\n      }\n      oldCalendarDay = calendarDay;\n      oldMonthString = calendarMonthString;\n    } while (!done);\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n\n    cache.set(key, result);\n    return result as ChineseMonthInfo;\n  }\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year, month } = calendarDate;\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n    if (fromLegacyDate) {\n      // Legacy Date output returns a string that's an integer with an optional\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n      // month. Below we'll normalize the output.\n      year = eraYear;\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\n      const monthString = `${month}${monthExtra || ''}`;\n      const months = this.getMonthList(year as number, cache);\n      const monthInfo = months[monthString];\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n      month = monthInfo.monthIndex;\n      return { year: year as number, month, day: day as number, era: undefined, eraYear, monthCode };\n    } else {\n      // When called without input coming from legacy Date output,\n      // simply ensure that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (year === undefined) year = eraYear;\n      if (eraYear === undefined) eraYear = year;\n      if (month === undefined) {\n        ES.assertExists(monthCode);\n        const months = this.getMonthList(year as number, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        let monthInfo = months[numberPart];\n        month = monthInfo && monthInfo.monthIndex;\n\n        // If this leap month isn't present in this year, constrain to the same\n        // day of the previous month.\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\n          let withoutML = monthCode.slice(1, -1);\n          if (withoutML[0] === '0') withoutML = withoutML.slice(1);\n          monthInfo = months[withoutML];\n          if (monthInfo) {\n            month = monthInfo.monthIndex;\n            monthCode = buildMonthCode(withoutML);\n          }\n        }\n        if (month === undefined) {\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n        }\n      } else if (monthCode === undefined) {\n        const months = this.getMonthList(year as number, cache);\n        const monthEntries = ObjectEntries(months);\n        const largestMonth = monthEntries.length;\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, largestMonth);\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\n        } else {\n          month = ES.ConstrainToRange(month, 1, largestMonth);\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n        }\n        const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n        if (matchingMonthEntry === undefined) {\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n        }\n        monthCode = buildMonthCode(\n          matchingMonthEntry[0].replace('bis', ''),\n          matchingMonthEntry[0].indexOf('bis') !== -1\n        );\n      } else {\n        // Both month and monthCode are present. Make sure they don't conflict.\n        const months = this.getMonthList(year as number, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        const monthInfo = months[numberPart];\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n        if (month !== monthInfo.monthIndex) {\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n        }\n      }\n      return {\n        ...calendarDate,\n        year: year as number,\n        eraYear,\n        month,\n        monthCode: monthCode,\n        day: day as number\n      };\n    }\n  }\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  override hasEra = false;\n}\n\nclass ChineseHelper extends ChineseBaseHelper {\n  id = 'chinese' as const;\n}\n\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n  id = 'dangi' as const;\n}\n\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nclass NonIsoCalendar implements CalendarImpl {\n  constructor(private readonly helper: HelperBase) {}\n  dateFromFields(\n    fieldsParam: Params['dateFromFields'][0],\n    options: NonNullable<Params['dateFromFields'][1]>,\n    calendarSlotValue: string\n  ): Temporal.PlainDate {\n    const cache = new OneObjectCache();\n    const fieldNames = this.fields(['day', 'month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n    const result = ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n    cache.setObject(result);\n    return result;\n  }\n  yearMonthFromFields(\n    fieldsParam: Params['yearMonthFromFields'][0],\n    options: NonNullable<Params['yearMonthFromFields'][1]>,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainYearMonth {\n    const cache = new OneObjectCache();\n    const fieldNames = this.fields(['month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n    const result = ES.CreateTemporalYearMonth(year, month, calendarSlotValue, /* referenceISODay = */ day);\n    cache.setObject(result);\n    return result;\n  }\n  monthDayFromFields(\n    fieldsParam: Params['monthDayFromFields'][0],\n    options: NonNullable<Params['monthDayFromFields'][1]>,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainMonthDay {\n    const cache = new OneObjectCache();\n    // For lunisolar calendars, either `monthCode` or `year` must be provided\n    // because `month` is ambiguous without a year or a code.\n    const fieldNames = this.fields(['day', 'month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n    // `year` is a reference year where this month/day exists in this calendar\n    const result = ES.CreateTemporalMonthDay(month, day, calendarSlotValue, /* referenceISOYear = */ year);\n    cache.setObject(result);\n    return result;\n  }\n  fields(fieldsParam: string[]): string[] {\n    let fields = fieldsParam;\n    if (ArrayIncludes.call(fields, 'year')) fields = [...fields, 'era', 'eraYear'];\n    return fields;\n  }\n  fieldKeysToIgnore(\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\n    const result = new OriginalSet();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      ES.Call(SetPrototypeAdd, result, [key]);\n      switch (key) {\n        case 'era':\n          ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          ES.Call(SetPrototypeAdd, result, ['year']);\n          break;\n        case 'eraYear':\n          ES.Call(SetPrototypeAdd, result, ['era']);\n          ES.Call(SetPrototypeAdd, result, ['year']);\n          break;\n        case 'year':\n          ES.Call(SetPrototypeAdd, result, ['era']);\n          ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          break;\n        case 'month':\n          ES.Call(SetPrototypeAdd, result, ['monthCode']);\n          // See https://github.com/tc39/proposal-temporal/issues/1784\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n        case 'monthCode':\n          ES.Call(SetPrototypeAdd, result, ['month']);\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n        case 'day':\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n      }\n    }\n    return [...ES.Call(SetPrototypeValues, result, [])];\n  }\n  dateAdd(\n    date: Temporal.PlainDate,\n    years: number,\n    months: number,\n    weeks: number,\n    days: number,\n    overflow: Overflow,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainDate {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n    const { year, month, day } = isoAdded;\n    const newTemporalObject = ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n    // The new object's cache starts with the cache of the old object\n    const newCache = new OneObjectCache(cache);\n    newCache.setObject(newTemporalObject);\n    return newTemporalObject;\n  }\n  dateUntil(one: Temporal.PlainDate, two: Temporal.PlainDate, largestUnit: Temporal.DateUnit) {\n    const cacheOne = OneObjectCache.getCacheForObject(one);\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\n    const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n    const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n    return result;\n  }\n  year(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.year;\n  }\n  month(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.month;\n  }\n  day(date: Temporal.PlainDate | Temporal.PlainMonthDay): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.day;\n  }\n  era(date: Temporal.PlainDate | Temporal.PlainYearMonth): string | undefined {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.era;\n  }\n  eraYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number | undefined {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.eraYear;\n  }\n  monthCode(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): string {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.monthCode;\n  }\n  dayOfWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].dayOfWeek(date);\n  }\n  dayOfYear(date: Temporal.PlainDate): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.isoToCalendarDate(date, cache);\n    const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n    const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n    return diffDays + 1;\n  }\n  weekOfYear(date: Temporal.PlainDate): number {\n    return impl['iso8601'].weekOfYear(date);\n  }\n  yearOfWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].yearOfWeek(date);\n  }\n  daysInWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].daysInWeek(date);\n  }\n  daysInMonth(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n\n    // Easy case: if the helper knows the length without any heavy calculation.\n    const max = this.helper.maximumMonthLength(calendarDate);\n    const min = this.helper.minimumMonthLength(calendarDate);\n    if (max === min) return max;\n\n    // The harder case is where months vary every year, e.g. islamic calendars.\n    // Find the answer by calculating the difference in days between the first\n    // day of the current month and the first day of the next month.\n    const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n    const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n    return result;\n  }\n  daysInYear(dateParam: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n    const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    return result;\n  }\n  monthsInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.monthsInYear(calendarDate, cache);\n    return result;\n  }\n  inLeapYear(dateParam: Temporal.PlainDate | Temporal.PlainYearMonth): boolean {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.inLeapYear(calendarDate, cache);\n    return result;\n  }\n}\n\nfor (const Helper of [\n  HebrewHelper,\n  PersianHelper,\n  EthiopicHelper,\n  EthioaaHelper,\n  CopticHelper,\n  ChineseHelper,\n  DangiHelper,\n  RocHelper,\n  IndianHelper,\n  BuddhistHelper,\n  GregoryHelper,\n  JapaneseHelper,\n  IslamicHelper,\n  IslamicUmalquraHelper,\n  IslamicTblaHelper,\n  IslamicCivilHelper,\n  IslamicRgsaHelper,\n  IslamicCcHelper\n]) {\n  const helper = new Helper();\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\n  // per-calendar logic.\n  impl[helper.id] = new NonIsoCalendar(helper);\n}\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\n\nexport class PlainDate implements Temporal.PlainDate {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    isoDayParam: Params['constructor'][2],\n    calendarParam: Params['constructor'][3] = 'iso8601'\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get yearOfWeek(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalDateLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalDateLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialDate = ES.PrepareTemporalFields(temporalDateLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarDateFromFields(calendar, fields, options);\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], optionsParam: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    const duration = ES.ToTemporalDuration(temporalDurationLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    optionsParam: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    const duration = ES.CreateNegatedTemporalDuration(ES.ToTemporalDuration(temporalDurationLike));\n    const options = ES.GetOptionsObject(optionsParam);\n\n    return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalDate(otherParam);\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalDateToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n  }\n  toPlainDateTime(temporalTimeParam: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    if (temporalTimeParam === undefined) return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n\n    const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    type TimeZoneAndPlainTimeProps = Exclude<typeof item, string | Temporal.TimeZoneProtocol>;\n    let timeZone: Temporal.TimeZoneLike, temporalTime: TimeZoneAndPlainTimeProps['plainTime'];\n    if (ES.IsObject(item)) {\n      if (ES.IsTemporalTimeZone(item)) {\n        timeZone = item;\n      } else {\n        const timeZoneLike = (item as TimeZoneAndPlainTimeProps).timeZone;\n        if (timeZoneLike === undefined) {\n          ES.uncheckedAssertNarrowedType<Temporal.TimeZoneProtocol>(\n            item,\n            \"if no timeZone property, then assume it's a custom time zone object\"\n          );\n          timeZone = ES.ToTemporalTimeZoneSlotValue(item);\n        } else {\n          timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneLike);\n          ES.uncheckedAssertNarrowedType<TimeZoneAndPlainTimeProps>(\n            item,\n            \"it's a property bag with a timeZone and optional plainTime\"\n          );\n          temporalTime = item.plainTime;\n        }\n      }\n    } else {\n      timeZone = ES.ToTemporalTimeZoneSlotValue(item);\n    }\n\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    let hour = 0,\n      minute = 0,\n      second = 0,\n      millisecond = 0,\n      microsecond = 0,\n      nanosecond = 0;\n    if (temporalTime !== undefined) {\n      temporalTime = ES.ToTemporalTime(temporalTime);\n      ES.uncheckedAssertNarrowedType<Temporal.PlainTime>(\n        temporalTime,\n        'ToTemporalTime above always returns a PlainTime'\n      );\n      hour = GetSlot(temporalTime, ISO_HOUR);\n      minute = GetSlot(temporalTime, ISO_MINUTE);\n      second = GetSlot(temporalTime, ISO_SECOND);\n      millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n      microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n      nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n    }\n\n    const dt = ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalDate(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalDate(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalDate(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    return ES.CompareISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY)\n    );\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\n}\n\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\n\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\n\nexport class PlainDateTime implements Temporal.PlainDateTime {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    isoDayParam: Params['constructor'][2],\n    hourParam: Params['constructor'][3] = 0,\n    minuteParam: Params['constructor'][4] = 0,\n    secondParam: Params['constructor'][5] = 0,\n    millisecondParam: Params['constructor'][6] = 0,\n    microsecondParam: Params['constructor'][7] = 0,\n    nanosecondParam: Params['constructor'][8] = 0,\n    calendarParam: Params['constructor'][9] = 'iso8601'\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalDateTimeSlots(\n      this,\n      isoYear,\n      isoMonth,\n      isoDay,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalDateTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalDateTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\n\n    const options = ES.GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialDateTime = ES.PrepareTemporalFields(temporalDateTimeLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n      ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    if (temporalTimeParam === undefined) return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n\n    const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withPlainDate(temporalDateParam: Params['withPlainDate'][0]): Return['withPlainDate'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return new PlainDateTime(\n      GetSlot(this, ISO_YEAR),\n      GetSlot(this, ISO_MONTH),\n      GetSlot(this, ISO_DAY),\n      GetSlot(this, ISO_HOUR),\n      GetSlot(this, ISO_MINUTE),\n      GetSlot(this, ISO_SECOND),\n      GetSlot(this, ISO_MILLISECOND),\n      GetSlot(this, ISO_MICROSECOND),\n      GetSlot(this, ISO_NANOSECOND),\n      calendar\n    );\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    let year = GetSlot(this, ISO_YEAR);\n    let month = GetSlot(this, ISO_MONTH);\n    let day = GetSlot(this, ISO_DAY);\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode\n    ));\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      GetSlot(this, CALENDAR)\n    );\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalDateTime(otherParam);\n    for (const slot of [\n      ISO_YEAR,\n      ISO_MONTH,\n      ISO_DAY,\n      ISO_HOUR,\n      ISO_MINUTE,\n      ISO_SECOND,\n      ISO_MILLISECOND,\n      ISO_MICROSECOND,\n      ISO_NANOSECOND\n    ]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n  }\n\n  toZonedDateTime(\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\n    optionsParam: Params['toZonedDateTime'][1] = undefined\n  ): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n    const options = ES.GetOptionsObject(optionsParam);\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    const instant = ES.GetInstantFor(timeZone, this, disambiguation);\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToDate(this);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToTime(this);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalDateTime(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalDateTime(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDateTime(oneParam);\n    const two = ES.ToTemporalDateTime(twoParam);\n    for (const slot of [\n      ISO_YEAR,\n      ISO_MONTH,\n      ISO_DAY,\n      ISO_HOUR,\n      ISO_MINUTE,\n      ISO_SECOND,\n      ISO_MILLISECOND,\n      ISO_MICROSECOND,\n      ISO_NANOSECOND\n    ] as const) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n    }\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\n}\n\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\nimport JSBI from 'jsbi';\n\nexport class Duration implements Temporal.Duration {\n  constructor(\n    yearsParam: Params['constructor'][0] = 0,\n    monthsParam: Params['constructor'][1] = 0,\n    weeksParam: Params['constructor'][2] = 0,\n    daysParam: Params['constructor'][3] = 0,\n    hoursParam: Params['constructor'][4] = 0,\n    minutesParam: Params['constructor'][5] = 0,\n    secondsParam: Params['constructor'][6] = 0,\n    millisecondsParam: Params['constructor'][7] = 0,\n    microsecondsParam: Params['constructor'][8] = 0,\n    nanosecondsParam: Params['constructor'][9] = 0\n  ) {\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\n\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    CreateSlots(this);\n    SetSlot(this, YEARS, years);\n    SetSlot(this, MONTHS, months);\n    SetSlot(this, WEEKS, weeks);\n    SetSlot(this, DAYS, days);\n    SetSlot(this, HOURS, hours);\n    SetSlot(this, MINUTES, minutes);\n    SetSlot(this, SECONDS, seconds);\n    SetSlot(this, MILLISECONDS, milliseconds);\n    SetSlot(this, MICROSECONDS, microseconds);\n    SetSlot(this, NANOSECONDS, nanoseconds);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${ES.TemporalDurationToString(this)}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get years(): Return['years'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, YEARS);\n  }\n  get months(): Return['months'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MONTHS);\n  }\n  get weeks(): Return['weeks'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, WEEKS);\n  }\n  get days(): Return['days'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, DAYS);\n  }\n  get hours(): Return['hours'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, HOURS);\n  }\n  get minutes(): Return['minutes'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MINUTES);\n  }\n  get seconds(): Return['seconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, SECONDS);\n  }\n  get milliseconds(): Return['milliseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MILLISECONDS);\n  }\n  get microseconds(): Return['microseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MICROSECONDS);\n  }\n  get nanoseconds(): Return['nanoseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, NANOSECONDS);\n  }\n  get sign(): Return['sign'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.DurationSign(\n      GetSlot(this, YEARS),\n      GetSlot(this, MONTHS),\n      GetSlot(this, WEEKS),\n      GetSlot(this, DAYS),\n      GetSlot(this, HOURS),\n      GetSlot(this, MINUTES),\n      GetSlot(this, SECONDS),\n      GetSlot(this, MILLISECONDS),\n      GetSlot(this, MICROSECONDS),\n      GetSlot(this, NANOSECONDS)\n    );\n  }\n  get blank(): Return['blank'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return (\n      ES.DurationSign(\n        GetSlot(this, YEARS),\n        GetSlot(this, MONTHS),\n        GetSlot(this, WEEKS),\n        GetSlot(this, DAYS),\n        GetSlot(this, HOURS),\n        GetSlot(this, MINUTES),\n        GetSlot(this, SECONDS),\n        GetSlot(this, MILLISECONDS),\n        GetSlot(this, MICROSECONDS),\n        GetSlot(this, NANOSECONDS)\n      ) === 0\n    );\n  }\n  with(durationLike: Params['with'][0]): Return['with'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const partialDuration = ES.PrepareTemporalFields(\n      durationLike,\n      // NOTE: Field order here is important.\n      [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n      ],\n      'partial'\n    );\n    const {\n      years = GetSlot(this, YEARS),\n      months = GetSlot(this, MONTHS),\n      weeks = GetSlot(this, WEEKS),\n      days = GetSlot(this, DAYS),\n      hours = GetSlot(this, HOURS),\n      minutes = GetSlot(this, MINUTES),\n      seconds = GetSlot(this, SECONDS),\n      milliseconds = GetSlot(this, MILLISECONDS),\n      microseconds = GetSlot(this, MICROSECONDS),\n      nanoseconds = GetSlot(this, NANOSECONDS)\n    } = partialDuration;\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  negated(): Return['negated'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.CreateNegatedTemporalDuration(this);\n  }\n  abs(): Return['abs'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return new Duration(\n      Math.abs(GetSlot(this, YEARS)),\n      Math.abs(GetSlot(this, MONTHS)),\n      Math.abs(GetSlot(this, WEEKS)),\n      Math.abs(GetSlot(this, DAYS)),\n      Math.abs(GetSlot(this, HOURS)),\n      Math.abs(GetSlot(this, MINUTES)),\n      Math.abs(GetSlot(this, SECONDS)),\n      Math.abs(GetSlot(this, MILLISECONDS)),\n      Math.abs(GetSlot(this, MICROSECONDS)),\n      Math.abs(GetSlot(this, NANOSECONDS))\n    );\n  }\n  add(other: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromDuration('add', this, other, options);\n  }\n  subtract(other: Params['subtract'][0], options: Params['subtract'][1] = undefined): Return['subtract'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromDuration('subtract', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n\n    let defaultLargestUnit = ES.DefaultTemporalLargestUnit(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    );\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n\n    let largestUnit = ES.GetTemporalUnit(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\n    let relativeTo = ES.ToRelativeTemporalObject(roundTo);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    let smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'datetime', undefined);\n\n    let smallestUnitPresent = true;\n    if (!smallestUnit) {\n      smallestUnitPresent = false;\n      smallestUnit = 'nanosecond';\n    }\n    defaultLargestUnit = ES.LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n    let largestUnitPresent = true;\n    if (!largestUnit) {\n      largestUnitPresent = false;\n      largestUnit = defaultLargestUnit;\n    }\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n    if (!smallestUnitPresent && !largestUnitPresent) {\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\n    }\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n\n    const maximumIncrements = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    } as { [k in Temporal.DateTimeUnit]?: number };\n    const maximum = maximumIncrements[smallestUnit];\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n    ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(\n      years,\n      months,\n      weeks,\n      days,\n      largestUnit,\n      relativeTo\n    ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      ES.RoundDuration(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode,\n        relativeTo\n      ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      ES.AdjustRoundedDurationDays(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode,\n        relativeTo\n      ));\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      largestUnit,\n      relativeTo\n    ));\n    ({ years, months, weeks, days } = ES.BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  total(optionsParam: Params['total'][0]): Return['total'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\n    const options =\n      typeof optionsParam === 'string'\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\n        : ES.GetOptionsObject(optionsParam);\n    const relativeTo = ES.ToRelativeTemporalObject(options);\n    const unit = ES.GetTemporalUnit(options, 'unit', 'datetime', ES.REQUIRED);\n\n    // Convert larger units down to days\n    ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n    // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n    let intermediate;\n    if (ES.IsTemporalZonedDateTime(relativeTo)) {\n      intermediate = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n    }\n    let balanceResult = ES.BalancePossiblyInfiniteDuration(\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      unit,\n      intermediate\n    );\n    if (balanceResult === 'positive overflow') {\n      return Infinity;\n    } else if (balanceResult === 'negative overflow') {\n      return -Infinity;\n    }\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = balanceResult);\n    // Finally, truncate to the correct unit and calculate remainder\n    const { total } = ES.RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      1,\n      unit,\n      'trunc',\n      relativeTo\n    );\n    return total;\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\n    }\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\n      precision,\n      'Precision cannot be \"minute\" because of RangeError above'\n    );\n    return ES.TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDurationToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    if (typeof Intl !== 'undefined' && typeof (Intl as any).DurationFormat !== 'undefined') {\n      return new (Intl as any).DurationFormat(locales, options).format(this);\n    }\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n    return ES.TemporalDurationToString(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() to compare Temporal.Duration');\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    if (ES.IsTemporalDuration(item)) {\n      return new Duration(\n        GetSlot(item, YEARS),\n        GetSlot(item, MONTHS),\n        GetSlot(item, WEEKS),\n        GetSlot(item, DAYS),\n        GetSlot(item, HOURS),\n        GetSlot(item, MINUTES),\n        GetSlot(item, SECONDS),\n        GetSlot(item, MILLISECONDS),\n        GetSlot(item, MICROSECONDS),\n        GetSlot(item, NANOSECONDS)\n      );\n    }\n    return ES.ToTemporalDuration(item);\n  }\n  static compare(\n    oneParam: Params['compare'][0],\n    twoParam: Params['compare'][1],\n    optionsParam: Params['compare'][2] = undefined\n  ) {\n    const one = ES.ToTemporalDuration(oneParam);\n    const two = ES.ToTemporalDuration(twoParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const relativeTo = ES.ToRelativeTemporalObject(options);\n    const y1 = GetSlot(one, YEARS);\n    const mon1 = GetSlot(one, MONTHS);\n    const w1 = GetSlot(one, WEEKS);\n    let d1 = GetSlot(one, DAYS);\n    const h1 = GetSlot(one, HOURS);\n    const min1 = GetSlot(one, MINUTES);\n    const s1 = GetSlot(one, SECONDS);\n    const ms1 = GetSlot(one, MILLISECONDS);\n    const µs1 = GetSlot(one, MICROSECONDS);\n    let ns1 = GetSlot(one, NANOSECONDS);\n    const y2 = GetSlot(two, YEARS);\n    const mon2 = GetSlot(two, MONTHS);\n    const w2 = GetSlot(two, WEEKS);\n    let d2 = GetSlot(two, DAYS);\n    const h2 = GetSlot(two, HOURS);\n    const min2 = GetSlot(two, MINUTES);\n    const s2 = GetSlot(two, SECONDS);\n    const ms2 = GetSlot(two, MILLISECONDS);\n    const µs2 = GetSlot(two, MICROSECONDS);\n    let ns2 = GetSlot(two, NANOSECONDS);\n    const shift1 = ES.CalculateOffsetShift(relativeTo, y1, mon1, w1, d1);\n    const shift2 = ES.CalculateOffsetShift(relativeTo, y2, mon2, w2, d2);\n    if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n      ({ days: d1 } = ES.UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n      ({ days: d2 } = ES.UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n    }\n    const totalNs1 = ES.TotalDurationNanoseconds(d1, h1, min1, s1, ms1, µs1, ns1, shift1);\n    const totalNs2 = ES.TotalDurationNanoseconds(d2, h2, min2, s2, ms2, µs2, ns2, shift2);\n    return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(totalNs1, totalNs2)));\n  }\n  [Symbol.toStringTag]!: 'Temporal.Duration';\n}\n\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_MONTH, ISO_DAY, ISO_YEAR, CALENDAR, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\n\nconst ObjectCreate = Object.create;\n\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\n  constructor(\n    isoMonthParam: Params['constructor'][0],\n    isoDayParam: Params['constructor'][0],\n    calendarParam: string | Temporal.CalendarProtocol = 'iso8601',\n    referenceISOYearParam = 1972\n  ) {\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    const referenceISOYear = ES.ToIntegerWithTruncation(referenceISOYearParam);\n\n    ES.CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n  }\n\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n\n  with(temporalMonthDayLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalMonthDayLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialMonthDay = ES.PrepareTemporalFields(temporalMonthDayLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarMonthDayFromFields(calendar, fields, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalMonthDay(otherParam);\n    for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalMonthDayToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalMonthDayToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const receiverFieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n\n    const inputFieldNames = ES.CalendarFields(calendar, ['year'] as const);\n    const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n\n    // TODO: Use MergeLists abstract operation.\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n    const options = ObjectCreate(null);\n    options.overflow = 'reject';\n    return ES.CalendarDateFromFields(calendar, mergedFields, options);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalMonthDay(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalMonthDay(\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR),\n        GetSlot(item, ISO_YEAR)\n      );\n    }\n    return ES.ToTemporalMonthDay(item, options);\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\n}\n\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport type { Temporal } from '..';\n\nconst instant: typeof Temporal.Now['instant'] = () => {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  return new Instant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime: typeof Temporal.Now['plainDateTime'] = (\n  calendarLike,\n  temporalTimeZoneLike = ES.DefaultTimeZone()\n) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n  const inst = instant();\n  return ES.GetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO: typeof Temporal.Now['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const inst = instant();\n  return ES.GetPlainDateTimeFor(tZ, inst, 'iso8601');\n};\nconst zonedDateTime: typeof Temporal.Now['zonedDateTime'] = (\n  calendarLike,\n  temporalTimeZoneLike = ES.DefaultTimeZone()\n) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO: typeof Temporal.Now['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return zonedDateTime('iso8601', temporalTimeZoneLike);\n};\nconst plainDate: typeof Temporal.Now['plainDate'] = (calendarLike, temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO: typeof Temporal.Now['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO: typeof Temporal.Now['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZoneId: typeof Temporal.Now['timeZoneId'] = () => {\n  return ES.DefaultTimeZone();\n};\n\nexport const Now: typeof Temporal.Now = {\n  instant,\n  plainDateTime,\n  plainDateTimeISO,\n  plainDate,\n  plainDateISO,\n  plainTimeISO,\n  timeZoneId,\n  zonedDateTime,\n  zonedDateTimeISO,\n  [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n  value: 'Temporal.Now',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\n\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\n\nconst ObjectAssign = Object.assign;\n\ntype TemporalTimeToStringOptions = {\n  unit: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['unit'];\n  increment: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['increment'];\n  roundingMode: Temporal.RoundingMode;\n};\n\nfunction TemporalTimeToString(\n  time: Temporal.PlainTime,\n  precision: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['precision'],\n  options: TemporalTimeToStringOptions | undefined = undefined\n) {\n  let hour = GetSlot(time, ISO_HOUR);\n  let minute = GetSlot(time, ISO_MINUTE);\n  let second = GetSlot(time, ISO_SECOND);\n  let millisecond = GetSlot(time, ISO_MILLISECOND);\n  let microsecond = GetSlot(time, ISO_MICROSECOND);\n  let nanosecond = GetSlot(time, ISO_NANOSECOND);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      increment,\n      unit,\n      roundingMode\n    ));\n  }\n\n  const hourString = ES.ISODateTimePartString(hour);\n  const minuteString = ES.ISODateTimePartString(minute);\n  const seconds = ES.FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  return `${hourString}:${minuteString}${seconds}`;\n}\n\nexport class PlainTime implements Temporal.PlainTime {\n  constructor(\n    isoHourParam = 0,\n    isoMinuteParam = 0,\n    isoSecondParam = 0,\n    isoMillisecondParam = 0,\n    isoMicrosecondParam = 0,\n    isoNanosecondParam = 0\n  ) {\n    const isoHour = isoHourParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoHourParam);\n    const isoMinute = isoMinuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinuteParam);\n    const isoSecond = isoSecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecondParam);\n    const isoMillisecond = isoMillisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecondParam);\n    const isoMicrosecond = isoMicrosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecondParam);\n    const isoNanosecond = isoNanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecondParam);\n\n    ES.RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n    CreateSlots(this);\n    SetSlot(this, ISO_HOUR, isoHour);\n    SetSlot(this, ISO_MINUTE, isoMinute);\n    SetSlot(this, ISO_SECOND, isoSecond);\n    SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n    SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n    SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n\n  with(temporalTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalTimeLike);\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\n\n    const fields = ES.ToTemporalTimeRecord(this);\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, partialTime);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainTime('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainTime('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const MAX_INCREMENTS = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\n\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode\n    ));\n\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalTime(otherParam);\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return true;\n  }\n\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return TemporalTimeToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n  }\n\n  toPlainDateTime(temporalDateParam: Params['toPlainDateTime'][0]): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    if (!ES.IsObject(item)) {\n      throw new TypeError('invalid argument');\n    }\n\n    const dateLike = item.plainDate;\n    if (dateLike === undefined) {\n      throw new TypeError('missing date property');\n    }\n    const temporalDate = ES.ToTemporalDate(dateLike);\n\n    const timeZoneLike = item.timeZone;\n    if (timeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property');\n    }\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneLike);\n\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return {\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND)\n    };\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n    if (ES.IsTemporalTime(item)) {\n      return new PlainTime(\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND)\n      );\n    }\n    return ES.ToTemporalTime(item, overflow);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalTime(oneParam);\n    const two = ES.ToTemporalTime(twoParam);\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND] as const) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n    }\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\n}\n\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { DefineIntrinsic, GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  TIMEZONE_ID,\n  EPOCHNANOSECONDS,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { TimeZoneParams as Params, TimeZoneReturn as Return } from './internaltypes';\n\nexport class TimeZone implements Temporal.TimeZone {\n  constructor(timeZoneIdentifierParam: string) {\n    // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n    //       This check exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: identifier is required');\n    }\n\n    const timeZoneIdentifier = ES.GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n    CreateSlots(this);\n    SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get id(): Return['id'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  getOffsetNanosecondsFor(instantParam: Params['getOffsetNanosecondsFor'][0]): Return['getOffsetNanosecondsFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (ES.IsTimeZoneOffsetString(id)) {\n      return ES.ParseTimeZoneOffsetString(id);\n    }\n\n    return ES.GetNamedTimeZoneOffsetNanoseconds(id, GetSlot(instant, EPOCHNANOSECONDS));\n  }\n  getOffsetStringFor(instantParam: Params['getOffsetStringFor'][0]): Return['getOffsetStringFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    return ES.GetOffsetStringFor(this, instant);\n  }\n  getPlainDateTimeFor(\n    instantParam: Params['getPlainDateTimeFor'][0],\n    calendarParam: Params['getPlainDateTimeFor'][1] = 'iso8601'\n  ): Return['getPlainDateTimeFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return ES.GetPlainDateTimeFor(this, instant, calendar);\n  }\n  getInstantFor(\n    dateTimeParam: Params['getInstantFor'][0],\n    optionsParam: Params['getInstantFor'][1] = undefined\n  ): Return['getInstantFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    return ES.GetInstantFor(this, dateTime, disambiguation);\n  }\n  getPossibleInstantsFor(dateTimeParam: Params['getPossibleInstantsFor'][0]): Return['getPossibleInstantsFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (ES.IsTimeZoneOffsetString(id)) {\n      const epochNs = ES.GetUTCEpochNanoseconds(\n        GetSlot(dateTime, ISO_YEAR),\n        GetSlot(dateTime, ISO_MONTH),\n        GetSlot(dateTime, ISO_DAY),\n        GetSlot(dateTime, ISO_HOUR),\n        GetSlot(dateTime, ISO_MINUTE),\n        GetSlot(dateTime, ISO_SECOND),\n        GetSlot(dateTime, ISO_MILLISECOND),\n        GetSlot(dateTime, ISO_MICROSECOND),\n        GetSlot(dateTime, ISO_NANOSECOND)\n      );\n      if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n      const offsetNs = ES.ParseTimeZoneOffsetString(id);\n      return [new Instant(JSBI.subtract(epochNs, JSBI.BigInt(offsetNs)))];\n    }\n\n    const possibleEpochNs = ES.GetNamedTimeZoneEpochNanoseconds(\n      id,\n      GetSlot(dateTime, ISO_YEAR),\n      GetSlot(dateTime, ISO_MONTH),\n      GetSlot(dateTime, ISO_DAY),\n      GetSlot(dateTime, ISO_HOUR),\n      GetSlot(dateTime, ISO_MINUTE),\n      GetSlot(dateTime, ISO_SECOND),\n      GetSlot(dateTime, ISO_MILLISECOND),\n      GetSlot(dateTime, ISO_MICROSECOND),\n      GetSlot(dateTime, ISO_NANOSECOND)\n    );\n    return possibleEpochNs.map((ns) => new Instant(ns));\n  }\n  getNextTransition(startingPointParam: Params['getNextTransition'][0]): Return['getNextTransition'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ES.ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds: JSBI | null = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = ES.GetNamedTimeZoneNextTransition(id, epochNanoseconds);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n  getPreviousTransition(startingPointParam: Params['getPreviousTransition'][0]): Return['getPreviousTransition'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ES.ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds: JSBI | null = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = ES.GetNamedTimeZonePreviousTransition(id, epochNanoseconds);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n  toString(): string {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    const timeZoneSlotValue = ES.ToTemporalTimeZoneSlotValue(item);\n    return ES.ToTemporalTimeZoneObject(timeZoneSlotValue);\n  }\n  [Symbol.toStringTag]!: 'Temporal.TimeZone';\n}\n\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\nDefineIntrinsic('Temporal.TimeZone.prototype.getOffsetNanosecondsFor', TimeZone.prototype.getOffsetNanosecondsFor);\nDefineIntrinsic('Temporal.TimeZone.prototype.getPossibleInstantsFor', TimeZone.prototype.getPossibleInstantsFor);\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, CALENDAR, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainYearMonthParams as Params, PlainYearMonthReturn as Return } from './internaltypes';\n\nconst ObjectCreate = Object.create;\n\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    calendarParam: Params['constructor'][2] = 'iso8601',\n    referenceISODayParam: Params['constructor'][3] = 1\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    const referenceISODay = ES.ToIntegerWithTruncation(referenceISODayParam);\n\n    ES.CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalYearMonthLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalYearMonthLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialYearMonth = ES.PrepareTemporalFields(temporalYearMonthLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarYearMonthFromFields(calendar, fields, options);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalYearMonth(otherParam);\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalYearMonthToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalYearMonthToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const receiverFieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n\n    const inputFieldNames = ES.CalendarFields(calendar, ['day'] as const);\n    const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n\n    // TODO: Use MergeLists abstract operation.\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n    const options = ObjectCreate(null);\n    options.overflow = 'reject';\n    return ES.CalendarDateFromFields(calendar, mergedFields, options);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalYearMonth(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalYearMonth(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, CALENDAR),\n        GetSlot(item, ISO_DAY)\n      );\n    }\n    return ES.ToTemporalYearMonth(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalYearMonth(oneParam);\n    const two = ES.ToTemporalYearMonth(twoParam);\n    return ES.CompareISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY)\n    );\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\n}\n\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n","import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  ISO_HOUR,\n  INSTANT,\n  ISO_DAY,\n  ISO_MONTH,\n  ISO_YEAR,\n  ISO_MICROSECOND,\n  ISO_MILLISECOND,\n  ISO_MINUTE,\n  ISO_NANOSECOND,\n  ISO_SECOND,\n  TIME_ZONE,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { ZonedDateTimeParams as Params, ZonedDateTimeReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND, ZERO, HOUR_NANOS } from './ecmascript';\n\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\nconst ObjectCreate = Object.create;\n\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\n  constructor(\n    epochNanosecondsParam: bigint | JSBI,\n    timeZoneParam: string | Temporal.TimeZoneProtocol,\n    calendarParam: string | Temporal.CalendarProtocol = 'iso8601'\n  ) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    //       ToTemporalTimeZoneSlotValue(undefined) has a clear enough message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get timeZoneId(): Return['timeZoneId'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalTimeZoneIdentifier(GetSlot(this, TIME_ZONE));\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_NANOSECOND);\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get epochSeconds(): Return['epochSeconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, BILLION));\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, MILLION));\n  }\n  get epochMicroseconds(): Return['epochMicroseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ES.ToBigIntExternal(ES.BigIntFloorDiv(value, THOUSAND));\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get hoursInDay(): Return['hoursInDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const year = GetSlot(dt, ISO_YEAR);\n    const month = GetSlot(dt, ISO_MONTH);\n    const day = GetSlot(dt, ISO_DAY);\n    const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n    const tomorrowFields = ES.AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n    const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const todayNs = GetSlot(ES.GetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n    const tomorrowNs = GetSlot(ES.GetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n    const diffNs = JSBI.subtract(tomorrowNs, todayNs);\n    return ES.BigIntDivideToNumber(diffNs, HOUR_NANOS);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get offset(): Return['offset'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.GetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n  with(temporalZonedDateTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\n      throw new TypeError('invalid zoned-date-time-like');\n    }\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fieldNames: (keyof Temporal.ZonedDateTimeLike)[] = ES.CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    fieldNames.push('offset');\n    let fields = ES.PrepareTemporalFields(this, fieldNames, ['offset']);\n    const partialZonedDateTime = ES.PrepareTemporalFields(temporalZonedDateTimeLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, ['offset']);\n\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    const offset = ES.ToTemporalOffset(options, 'prefer');\n\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n      ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n    const offsetNs = ES.ParseTimeZoneOffsetString(fields.offset);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      'option',\n      offsetNs,\n      timeZone,\n      disambiguation,\n      offset,\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n  withPlainDate(temporalDateParam: Params['withPlainDate'][0]): Return['withPlainDate'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n    const thisDt = dateTime(this);\n    const hour = GetSlot(thisDt, ISO_HOUR);\n    const minute = GetSlot(thisDt, ISO_MINUTE);\n    const second = GetSlot(thisDt, ISO_SECOND);\n    const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n    const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n    const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n\n    calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n\n    const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    const temporalTime = temporalTimeParam === undefined ? new PlainTime() : ES.ToTemporalTime(temporalTimeParam);\n\n    const thisDt = dateTime(this);\n    const year = GetSlot(thisDt, ISO_YEAR);\n    const month = GetSlot(thisDt, ISO_MONTH);\n    const day = GetSlot(thisDt, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromZonedDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromZonedDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    // first, round the underlying DateTime fields\n    const dt = dateTime(this);\n    let year = GetSlot(dt, ISO_YEAR);\n    let month = GetSlot(dt, ISO_MONTH);\n    let day = GetSlot(dt, ISO_DAY);\n    let hour = GetSlot(dt, ISO_HOUR);\n    let minute = GetSlot(dt, ISO_MINUTE);\n    let second = GetSlot(dt, ISO_SECOND);\n    let millisecond = GetSlot(dt, ISO_MILLISECOND);\n    let microsecond = GetSlot(dt, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n    const instantStart = ES.GetInstantFor(timeZone, dtStart, 'compatible');\n    const endNs = ES.AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = JSBI.subtract(endNs, JSBI.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n    if (JSBI.lessThanOrEqual(dayLengthNs, ZERO)) {\n      throw new RangeError('cannot round a ZonedDateTime in a calendar with zero or negative length days');\n    }\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode,\n      // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n      // (which can hold up to 104 days in nanoseconds)\n      JSBI.toNumber(dayLengthNs)\n    ));\n\n    // Now reset all DateTime fields but leave the TimeZone. The offset will\n    // also be retained if the new date/time values are still OK with the old\n    // offset. Otherwise the offset will be changed to be compatible with the\n    // new date/time values. If DST disambiguation is required, the `compatible`\n    // disambiguation algorithm will be used.\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      'option',\n      offsetNs,\n      timeZone,\n      'compatible',\n      'prefer',\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalZonedDateTime(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const showOffset = ES.ToShowOffsetOption(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const showTimeZone = ES.ToTimeZoneNameOption(options);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    optionsParam: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const optionsCopy = ObjectCreate(null);\n    // This is not quite per specification, but this polyfill's DateTimeFormat\n    // already doesn't match the InitializeDateTimeFormat operation, and the\n    // access order might change anyway;\n    // see https://github.com/tc39/ecma402/issues/747\n    ES.CopyDataProperties(optionsCopy, options, ['timeZone']);\n\n    if (options.timeZone !== undefined) {\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\n    }\n\n    if (\n      optionsCopy.year === undefined &&\n      optionsCopy.month === undefined &&\n      optionsCopy.day === undefined &&\n      optionsCopy.weekday === undefined &&\n      optionsCopy.dateStyle === undefined &&\n      optionsCopy.hour === undefined &&\n      optionsCopy.minute === undefined &&\n      optionsCopy.second === undefined &&\n      optionsCopy.timeStyle === undefined &&\n      optionsCopy.dayPeriod === undefined &&\n      optionsCopy.timeZoneName === undefined\n    ) {\n      optionsCopy.timeZoneName = 'short';\n      // The rest of the defaults will be filled in by formatting the Instant\n    }\n\n    let timeZone = ES.ToTemporalTimeZoneIdentifier(GetSlot(this, TIME_ZONE));\n    if (ES.IsTimeZoneOffsetString(timeZone)) {\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\n      throw new RangeError('toLocaleString does not support offset string time zones');\n    }\n    timeZone = ES.GetCanonicalTimeZoneIdentifier(timeZone);\n    optionsCopy.timeZone = timeZone;\n\n    const formatter = new DateTimeFormat(locales, optionsCopy);\n\n    const localeCalendarIdentifier = ES.Call(customResolvedOptions, formatter, []).calendar;\n    const calendarIdentifier = ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n    if (\n      calendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== calendarIdentifier\n    ) {\n      throw new RangeError(\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\n          ` in locale with calendar ${localeCalendarIdentifier}`\n      );\n    }\n\n    return formatter.format(GetSlot(this, INSTANT));\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n  }\n  startOfDay(): Return['startOfDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(\n      GetSlot(dt, ISO_YEAR),\n      GetSlot(dt, ISO_MONTH),\n      GetSlot(dt, ISO_DAY),\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      calendar\n    );\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const instant = ES.GetInstantFor(timeZone, dtStart, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toInstant(): Return['toInstant'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToDate(dateTime(this));\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToTime(dateTime(this));\n  }\n  toPlainDateTime(): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return dateTime(this);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const tz = GetSlot(this, TIME_ZONE);\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(dt, ISO_DAY),\n      isoHour: GetSlot(dt, ISO_HOUR),\n      isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n      isoMinute: GetSlot(dt, ISO_MINUTE),\n      isoMonth: GetSlot(dt, ISO_MONTH),\n      isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n      isoSecond: GetSlot(dt, ISO_SECOND),\n      isoYear: GetSlot(dt, ISO_YEAR),\n      offset: ES.GetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n      timeZone: tz\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n  getTimeZone(): Return['getTimeZone'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalTimeZoneObject(GetSlot(this, TIME_ZONE));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalZonedDateTime(item)) {\n      ES.ToTemporalDisambiguation(options); // validate and ignore\n      ES.ToTemporalOffset(options, 'reject');\n      ES.ToTemporalOverflow(options);\n      return ES.CreateTemporalZonedDateTime(\n        GetSlot(item, EPOCHNANOSECONDS),\n        GetSlot(item, TIME_ZONE),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalZonedDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalZonedDateTime(oneParam);\n    const two = ES.ToTemporalZonedDateTime(twoParam);\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\n}\n\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\n\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\n  return ES.GetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n","// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\n\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n  Temporal.Instant,\n  Temporal.Calendar,\n  Temporal.PlainDate,\n  Temporal.PlainDateTime,\n  Temporal.Duration,\n  Temporal.PlainMonthDay,\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\n  Temporal.PlainTime,\n  Temporal.TimeZone,\n  Temporal.PlainYearMonth,\n  Temporal.ZonedDateTime\n];\nfor (const type of types) {\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n    descriptor.configurable = false;\n    descriptor.enumerable = false;\n    descriptor.writable = false;\n    Object.defineProperty(type, 'prototype', descriptor);\n  }\n}\n\nexport { Temporal, Intl, toTemporalInstant };\n","import { Instant } from './instant';\n\nimport JSBI from 'jsbi';\nimport { MILLION } from './ecmascript';\n\nexport function toTemporalInstant(this: Date) {\n  // Observable access to valueOf is not correct here, but unavoidable\n  const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n  return new Instant(epochNanoseconds);\n}\n"],"names":["_defineProperty","options","descr","stylize","this","Symbol","toStringTag","concat","depth","entries","_i","_arr","prop","EPOCHNANOSECONDS","TIMEZONE_ID","ISO_YEAR","ISO_MONTH","ISO_DAY","ISO_HOUR","ISO_MINUTE","ISO_SECOND","ISO_MILLISECOND","ISO_MICROSECOND","ISO_NANOSECOND","CALENDAR","DATE_BRAND","YEAR_MONTH_BRAND","MONTH_DAY_BRAND","INSTANT","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MICROSECONDS","NANOSECONDS","tzComponent","timeZoneID","RegExp","source","join","yearpart","monthpart","daypart","datesplit","timesplit","offset","offsetpart","annotation","zoneddatetime","time","ArrayIncludes","Array","prototype","includes","ArrayPrototypePush","push","IntlDateTimeFormat","globalThis","Intl","DateTimeFormat","MathMin","Math","min","MathMax","max","MathAbs","abs","MathFloor","floor","MathSign","sign","MathTrunc","trunc","NumberIsNaN","Number","isNaN","NumberIsFinite","isFinite","NumberCtor","StringCtor","String","NumberMaxSafeInteger","MAX_SAFE_INTEGER","ObjectCreate","Object","create","ObjectGetOwnPropertyDescriptor","getOwnPropertyDescriptor","ReflectApply","Reflect","apply","ReflectOwnKeys","ownKeys","ZERO","JSBI","BigInt","ONE","SIXTY","TWENTY_FOUR","THOUSAND","MILLION","NEGATIVE_ONE","HOUR_NANOS","multiply","BILLION","DAY_NANOS","NS_MIN","NS_MAX","YEAR_MIN","YEAR_MAX","BEFORE_FIRST_OFFSET_TRANSITION","ABOUT_TEN_YEARS_NANOS","ABOUT_ONE_YEAR_NANOS","TWO_WEEKS_NANOS","BUILTIN_CALENDAR_IDS","isZero","value","GetMethod","obj","methodName","result","Call","target","thisArgument","args","arguments","length","argumentsList","IsObject","_typeof","ToNumber","TypeError","ToIntegerOrInfinity","number","integer","IsIntegralNumber","argument","absValue","ToString","ToIntegerWithTruncation","RangeError","ToPositiveIntegerWithTruncation","valueParam","property","undefined","divmod","x","y","divide","remainder","isNegativeJSBI","signJSBI","lessThan","BUILTIN_CASTS","Map","ToIntegerIfIntegral","BUILTIN_DEFAULTS","SINGULAR_PLURAL_UNITS","SINGULAR_FOR","map","e","PLURAL_FOR","_ref","_ref2","_slicedToArray","p","UNITS_DESCENDING","_ref3","DURATION_FIELDS","from","keys","sort","IntlDateTimeFormatEnUsCache","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","instance","get","timeZone","hour12","era","year","month","day","hour","minute","second","set","ToObject","CopyDataProperties","excludedValues","_step","_iterator","_createForOfIteratorHelper","_loop","nextKey","excludedKeys","some","is","propertyIsEnumerable","propValue","s","n","done","IsTemporalInstant","item","HasSlot","IsTemporalTimeZone","CALENDAR_ID","IsTemporalDuration","MILLISECONDS","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","RejectTemporalLikeObject","calendar","ParseTemporalTimeZone","stringIdent","ParseTemporalTimeZoneString","PARSE","test","ianaName","ParseISODateTime","_unused3","z","GetCanonicalTimeZoneIdentifier","FormatTimeZoneOffsetString","ParseTimeZoneOffsetString","MaybeFormatCalendarAnnotation","showCalendar","FormatCalendarAnnotation","ToTemporalCalendarIdentifier","id","flag","isoString","match","exec","yearString","slice","hasTime","millisecond","fraction","microsecond","nanosecond","offsetSign","offsetHours","offsetFraction","offsetMinutes","endsWith","offsetSeconds","_step2","_iterator2","matchAll","_step2$value","key","critical","err","f","RejectDateTime","ParseTemporalTimeString","_step3","_iterator3","_step3$value","ParseTemporalMonthDayString","RejectISODate","_unused","ParseTemporalYearMonthString","_unused2","referenceISODay","_step4","_iterator4","_step4$value","referenceISOYear","_step5","_iterator5","_step5$value","ParseTemporalInstant","ParseTemporalInstantString","BalanceISODateTime","epochNs","GetUTCEpochNanoseconds","RegulateISODate","yearParam","monthParam","dayParam","overflow","_ConstrainISODate","ConstrainISODate","RegulateTime","hourParam","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","RejectTime","_ConstrainTime","ConstrainTime","ConstrainToRange","ToTemporalDurationRecord","ParseTemporalDurationString","every","element","years","months","weeks","days","hours","fHours","minutesStr","fMinutes","secondsStr","fSeconds","minutes","seconds","_ref5","_ref6","_ref7","excessNanoseconds","_ref8","nanoseconds","microseconds","milliseconds","RejectDuration","GetSlot","_step6","partial","ToTemporalPartialDurationRecord","temporalDurationLike","_step7","any","_iterator7","_iterator6","ToTemporalOverflow","GetOption","ToTemporalDisambiguation","ToTemporalRoundingMode","ToTemporalOffset","fallback","ToCalendarNameOption","ToTimeZoneNameOption","ToShowOffsetOption","ToTemporalRoundingIncrement","increment","roundingIncrement","integerIncrement","ValidateTemporalRoundingIncrement","dividend","inclusive","maximum","ToFractionalSecondDigits","digitsValue","normalizedOptions","fractionalSecondDigits","digitCount","ToSecondsStringPrecisionRecord","precision","smallestUnit","unit","pow","REQUIRED","GetTemporalUnit","unitGroup","extraValues","allowedSingular","_iterator9","singular","category","_toConsumableArray","requiredOrDefault","defaultVal","_allowedSingular","plural","allowedValues","retval","has","ToRelativeTemporalObject","relativeTo","offsetBehaviour","matchMinutes","TemporalDateTimeToDate","fieldNames","CalendarFields","GetTemporalCalendarSlotValueWithISODefault","PrepareTemporalFields","dateOptions","_InterpretTemporalDat","InterpretTemporalDateTimeFields","fields","ToTemporalTimeZoneSlotValue","_ParseISODateTime4","IsBuiltinCalendar","CreateTemporalDate","CreateTemporalZonedDateTime","InterpretISODateTimeOffset","DefaultTemporalLargestUnit","_i2","_arr$_i","LargerOfTwoTemporalUnits","indexOf","unit1","unit2","requiredFields","_ref9","emptySourceErrorMessage","_step10","_iterator10","bag","call","ToTemporalTimeRecord","_i3","_fields","field","valueDesc","completeness","ToTemporalDate","itemParam","CalendarDateFromFields","_ParseTemporalDateStr","ParseTemporalDateString","date","_RegulateTime","GetPlainDateTimeFor","CreateTemporalDateTime","_InterpretTemporalDat2","_ParseTemporalDateTim","ParseTemporalDateTimeString","ASCIILowercase","ToTemporalDuration","GetIntrinsic","ToTemporalInstant","ns","ToTemporalMonthDay","calendarAbsent","calendarFromItem","ToTemporalCalendarSlotValue","monthCode","CalendarMonthDayFromFields","_ParseTemporalMonthDa2","CreateTemporalMonthDay","ToTemporalTime","TemporalPlainTime","_RegulateTime2","_ParseTemporalTimeStr","ToTemporalYearMonth","CalendarYearMonthFromFields","_ParseTemporalYearMon2","CreateTemporalYearMonth","offsetNs","disambiguation","offsetOpt","matchMinute","dt","GetInstantFor","subtract","_step11","possibleInstants","GetPossibleInstantsFor","_iterator11","candidate","candidateOffset","roundedCandidateOffset","RoundNumberToIncrement","MINUTE_NANOS","offsetStr","timeZoneString","toString","DisambiguatePossibleInstants","_InterpretTemporalDat3","ParseTemporalZonedDateTimeString","isoYear","isoMonth","isoDay","RejectDateRange","CreateSlots","SetSlot","TemporalPlainDate","CreateTemporalDateSlots","CreateTemporalDateTimeSlots","h","ms","µs","RejectDateTimeRange","TemporalPlainDateTime","CreateTemporalMonthDaySlots","TemporalPlainMonthDay","RejectYearMonthRange","RejectToRange","TemporalPlainYearMonth","CreateTemporalZonedDateTimeSlots","epochNanoseconds","instant","TemporalZonedDateTime","fieldNamesParam","calendarObj","_step12","_iterator12","name","CalendarMergeFields","additionalFields","CalendarDateAdd","dateAddParam","duration","dateAdd","CalendarDateUntil","dateUntil","dateUntilParam","otherDate","CalendarYear","dateLike","CalendarMonth","CalendarMonthCode","CalendarDay","CalendarEra","CalendarDayOfWeek","CalendarWeekOfYear","CalendarYearOfWeek","CalendarDaysInWeek","CalendarDaysInMonth","CalendarMonthsInYear","CalendarInLeapYear","calendarLike","ObjectImplementsTemporalCalendarProtocol","object","IsTemporalCalendar","identifier","_unused4","slotValue","ToTemporalCalendarObject","CalendarEquals","one","two","ThrowIfCalendarsNotEqual","errorMessageAction","cal1","cal2","ConsolidateCalendars","sOne","sTwo","dateFromFieldsParam","temporalTimeZoneLike","ObjectImplementsTemporalTimeZoneProtocol","ToTemporalTimeZoneIdentifier","ToTemporalTimeZoneObject","dateTime","TemporalDateTimeToTime","GetOffsetNanosecondsFor","getOffsetNanosecondsForParam","timeZoneObject","GetOffsetStringFor","GetISOPartsFromEpoch","Instant","numInstants","utcns","dayBefore","dayAfter","add","offsetBefore","PlainDateTime","earlier","AddDateTime","later","possible","getPossibleInstantsForParam","_step13","_iterator13","ISOYearString","yearNumber","ISODateTimePartString","part","FormatSecondsStringPart","secs","fractionNumber","padStart","TemporalInstantToString","outputTimeZone","FormatISOTimeZoneOffsetString","TemporalDurationToString","formatNumber","num","DurationSign","roundingMode","RoundDuration","dateParts","timeParts","nsBigInt","µsBigInt","msBigInt","secondsBigInt","secondParts","total","TotalDurationNanoseconds","_divmod","quotient","_divmod2","_divmod3","decimalPart","toNumber","unshift","TemporalDateToString","TemporalDateTimeToString","RoundISODateTime","monthString","dayString","hourString","minuteString","secondsString","TemporalMonthDayToString","monthDay","resultString","calendarID","calendarString","TemporalYearMonthToString","yearMonth","TemporalZonedDateTimeToString","zdt","showOffset","RoundInstant","TemporalInstant","tz","showTimeZone","IsTimeZoneOffsetString","string","OFFSET","resolvedOptions","GetNamedTimeZoneOffsetNanoseconds","_GetNamedTimeZoneDate","GetNamedTimeZoneDateTimeParts","reducedYear","yearCycles","nsIn400YearCycle","reducedUTC","utc","offsetNanosecondsParam","offsetNanoseconds","secondString","post","legacyDate","Date","setUTCFullYear","getTime","greaterThan","_divmod4","nanos","epochMilliseconds","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","_GetFormatterParts","GetFormatterParts","datetime","format","parseFromEnUsFormat","parts","split","toUpperCase","maxJSBI","SystemUTCEpochNanoSeconds","GetNamedTimeZoneNextTransition","oneYearLater","uppercap","afterLatestPossibleTzdbRuleChange","leftNanos","leftOffsetNs","rightNanos","rightOffsetNs","bisect","GetNamedTimeZonePreviousTransition","afterLatestRule","isFarFuture","lowercap","lastPrecomputed","newTimeToCheck","LeapYear","ISODaysInMonth","standard","leapyear","DayOfWeek","m","Y","c","dow","DayOfYear","WeekOfYear","doy","doj","week","mon","_i4","_arr2","w","d","BalanceISOYearMonth","BalanceISODate","_BalanceISOYearMonth","daysIn400YearCycle","nCycles","daysInYear","testYear","_BalanceISOYearMonth3","deltaDays","_NonNegativeBigIntDiv","NonNegativeBigIntDivmod","_NonNegativeBigIntDiv2","_NonNegativeBigIntDiv4","_NonNegativeBigIntDiv5","_NonNegativeBigIntDiv6","secondsParam","millisecondsParam","daysParam","nanosecondsParam","offsetShift","hoursParam","minutesParam","microsecondsParam","NanosecondsToDays","dayLengthNs","startNs","start","endNs","end","dtStart","dtEnd","daysNumber","DifferenceISODateTime","intermediateNs","AddZonedDateTime","daysBigInt","isOverflow","oneDayFartherNs","relativeNs","relativeInstant","greaterThanOrEqual","Error","BalanceDuration","largestUnit","BalancePossiblyInfiniteDuration","nanosecondsBigInt","microsecondsBigInt","millisecondsBigInt","minutesBigInt","hoursBigInt","_NanosecondsToDays","_divmod6","_divmod7","_divmod8","_divmod9","_divmod11","_divmod12","_divmod13","_divmod15","_divmod16","_divmod17","_divmod18","_divmod19","_divmod20","_i5","_arr3","UnbalanceDurationRelative","yearsParam","monthsParam","weeksParam","TemporalDuration","signBI","relativeToParam","oneYear","oneMonth","newRelativeTo","untilOptions","oneYearMonths","untilResult","oneYearDays","MoveRelativeDate","oneMonthDays","oneWeekDays","oneWeek","CalculateOffsetShift","after","CreateNegatedTemporalDuration","_i6","_arr4","propSign","DifferenceISODate","m1","d1","y2","m2","d2","CompareISODate","y1","NegateTemporalRoundingMode","ToLimitedTemporalDuration","disallowedProperties","_step8","record","_iterator8","DATE","YM","MD","TIME","DATETIME","INST","ORIGINAL","TZ_RESOLVED","CAL_ID","LOCALE","OPTIONS","descriptor","assign","ObjectHasOwnProperty","hasOwnProperty","getPropLazy","val","DateTimeFormatImpl","locale","optionsParam","hasOptions","ObjectAssign","original","ro","clonedResolved","dateAmend","yearMonthAmend","monthDayAmend","timeAmend","datetimeAmend","defineProperty","writable","supportedLocalesOf","locales","propertyDescriptors","_extractOverrides","extractOverrides","formatter","_len","rest","_this$ORIGINAL","formatRange","a","b","isTemporalObject","sameTemporalType","_extractOverrides3","aa","aformatter","_extractOverrides4","bb","bformatter","formatToParts","_this$ORIGINAL2","_extractOverrides2","_len2","_key2","formatRangeToParts","_extractOverrides5","_extractOverrides6","amend","amended","opt","weekday","timeZoneName","dateStyle","hasTimeOptions","dayPeriod","timeStyle","hasDateOptions","instantAmend","_classCallCheck","ES","until","other","since","roundToParam","roundTo","otherParam","equal","digits","roundedNs","roundedInstant","toJSON","toLocaleString","valueOf","timeZoneParam","epochSecondsParam","epochSeconds","epochMillisecondsParam","epochMicrosecondsParam","epochMicroseconds","epochNanosecondsParam","oneParam","twoParam","oneNs","twoNs","MakeIntrinsicClass","ArraySort","ObjectEntries","OriginalSet","Set","SetPrototypeValues","values","impl","Calendar","idParam","dateFromFields","yearMonthFromFields","monthDayFromFields","fieldsArray","allowed","delete","mergeFields","fieldsParam","additionalFieldsParam","fieldsCopy","additionalFieldsCopy","additionalKeys","overriddenKeys","fieldKeysToIgnore","merged","dateParam","durationParam","_impl$GetSlot$dateUnt","Duration","dayOfWeek","dayOfYear","weekOfYear","yearOfWeek","daysInMonth","monthsInYear","inLeapYear","monthCodeNumberPart","startsWith","buildMonthCode","leap","resolveNonLunisolarMonth","calendarDate","monthsPerYear","numberPart","DefineIntrinsic","daysInWeek","eraYear","calendarSlotValue","_fields2","_ConstrainISODate2","useYear","_fields4","_ES$RegulateISODate2","ix","SetPrototypeAdd","_ES$AddISODate","OneObjectCache","cacheToClone","misses","performance","now","i","_this$map","entry","MAX_CACHE_ENTRIES","report","calls","objectMap","cache","toUtcIsoDateString","simpleDateDiff","WeakMap","HelperBase","erasBeginMidYear","_createClass","getFormatter","eraLength","isoDate","_this","JSON","stringify","func","cached","dateTimeFormat","type","matches","monthExtra","hasEra","normalize","replace","toLowerCase","reviseIntlEra","checkIcuBugs","adjustCalendarDate","forEach","keyReverse","constantEra","calendarType","calendarDateParam","validateCalendarDate","_calendarDate","largestMonth","_calendarDate2","_resolveNonLunisolarM","maximumMonthLength","_objectSpread","keyOriginal","_this2","originalDate","_date","isoEstimate","estimateIsoDate","calculateSameMonthResult","diffDays","testIsoEstimate","minimumMonthLength","testCalendarDate","isoToCalendarDate","addDaysIso","roundtripEstimate","diff","diffTotalDaysEstimate","compareCalendarDates","oldRoundtripEstimate","oldSign","order","date1Param","date2Param","date1","date2","calendarToIsoDate","addedIso","absMonths","oldCalendarDate","monthsInOldYear","regulateDate","_ref2$years","_ref2$months","_ref2$weeks","_ref2$days","addedYears","addedMonths","addMonthsCalendar","initialDays","addDaysCalendar","calendarOne","calendarTwo","calendarDaysUntil","totalDays","diffYears","diffInYearSign","current","next","addedCalendarDate","addedIsoDate","endOfMonthIso","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","oneIso","twoIso","isoDaysUntil","_this$isoToCalendarDa","calendarOfStartDateIso","calendarYear","roundTripCalendarDate","closestCalendar","closestIso","Tishri","regular","Heshvan","Kislev","Sivan","Tamuz","Av","Elul","_this3","minMaxMonthLength","minOrMax","getMonthCode","monthInfo","find","fromLegacyDate","calculatedMonthCode","HebrewHelper","IslamicBaseHelper","_HelperBase2","_inherits","_super2","_createSuper","_this4","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","IslamicHelper","_IslamicBaseHelper","_super3","_this5","_IslamicBaseHelper2","IslamicUmalquraHelper","_super4","_this6","IslamicTblaHelper","_IslamicBaseHelper3","_super5","_this7","IslamicCivilHelper","_IslamicBaseHelper4","_super6","_this8","IslamicRgsaHelper","_IslamicBaseHelper5","_super7","_this9","IslamicCcHelper","_IslamicBaseHelper6","_super8","_this10","PersianHelper","_HelperBase3","_super9","_this11","IndianHelper","_HelperBase4","_super10","_this12","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","GregorianBaseHelper","_HelperBase5","_super11","originalEras","_this13","v8IsVulnerableToJulianBug","calendarIsVulnerableToJulianBug","adjustEras","erasParam","eras","reverseOf","filter","isAnchor","anchorEpoch","anchorEra","hasYearZero","reversedEra","isoEpoch","e1","e2","lastEraReversed","genericName","_this14","currentValue","eraFromYear","adjustedCalendarDate","matchingEra","checkField","OrthodoxBaseHelper","_GregorianBaseHelper","_super12","EthioaaHelper","_OrthodoxBaseHelper","_super13","_super14","EthiopicHelper","RocHelper","_GregorianBaseHelper2","_super16","_this15","BuddhistHelper","_GregorianBaseHelper3","_super17","_this16","GregoryHelper","_GregorianBaseHelper4","_super18","JapaneseHelper","_GregorianBaseHelper5","_super19","_this17","ChineseBaseHelper","_HelperBase6","_super20","_this18","getMonthList","_this19","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","calendarMonthString","tv","calendarDay","calendarYearToVerify","isoDaysDelta","_getCalendarDate","_getCalendarDate2","oldCalendarDay","oldMonthString","monthIndex","_getCalendarDate3","PlainDate","isoYearParam","isoMonthParam","isoDayParam","calendarParam","_with","temporalDateLike","partialDate","slot","toPlainDateTime","temporalTimeParam","temporalTime","timeZoneLike","plainTime","toPlainYearMonth","temporalDateTimeLike","partialDateTime","withPlainTime","temporalDateParam","temporalDate","partialDuration","_partialDuration$mont","_partialDuration$week","_partialDuration$days","_partialDuration$hour","_partialDuration$minu","_partialDuration$seco","_partialDuration$mill","_partialDuration$micr","_partialDuration$nano","defaultLargestUnit","smallestUnitPresent","largestUnitPresent","_ES$UnbalanceDuration","_ES$RoundDuration","_ES$AdjustRoundedDura","BalanceDurationRelative","PlainMonthDay","referenceISOYearParam","temporalMonthDayLike","partialMonthDay","receiverFieldNames","inputFieldNames","mergedFields","getISOFields","getCalendar","plainDateTime","tZ","inst","plainDateTimeISO","zonedDateTime","Now","plainDate","plainDateISO","plainTimeISO","timeZoneId","zonedDateTimeISO","TemporalTimeToString","PlainTime","isoHourParam","isoMinuteParam","isoSecondParam","isoMillisecondParam","isoMicrosecondParam","isoNanosecondParam","isoHour","isoMinute","isoSecond","isoMillisecond","isoMicrosecond","isoNanosecond","temporalTimeLike","partialTime","_ES$RegulateTime","_ES$ToSecondsStringPr","TimeZone","timeZoneIdentifierParam","instantParam","getPlainDateTimeFor","getInstantFor","dateTimeParam","possibleEpochNs","nsEarlier","nsLater","earliest","latest","startingPointParam","startingPoint","PlainYearMonth","referenceISODayParam","temporalYearMonthLike","partialYearMonth","customResolvedOptions","ZonedDateTime","DateTime","today","tomorrowFields","tomorrow","todayNs","tomorrowNs","temporalZonedDateTimeLike","partialZonedDateTime","thisDt","instantStart","lessThanOrEqual","optionsCopy","localeCalendarIdentifier","calendarIdentifier","startOfDay","toInstant","toPlainDate","Temporal","_types","configurable","enumerable"],"mappings":"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"}