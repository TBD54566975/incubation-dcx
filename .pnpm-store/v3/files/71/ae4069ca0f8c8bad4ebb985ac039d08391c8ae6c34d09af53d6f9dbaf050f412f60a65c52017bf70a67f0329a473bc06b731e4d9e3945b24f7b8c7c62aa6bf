var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { TtlCache } from '@web5/common';
import { AgentPermissionsApi } from './permissions-api.js';
export class CachedPermissions {
    constructor({ agent, cachedDefault }) {
        /** cache for fetching a permission {@link PermissionGrant}, keyed by a specific MessageType and protocol */
        this.cachedPermissions = new TtlCache({ ttl: 60 * 1000 });
        this.permissionsApi = new AgentPermissionsApi({ agent });
        this.cachedDefault = cachedDefault !== null && cachedDefault !== void 0 ? cachedDefault : false;
    }
    getPermission({ connectedDid, delegateDid, delegate, messageType, protocol, cached = this.cachedDefault }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Currently we only support finding grants based on protocols
            // A different approach may be necessary when we introduce `protocolPath` and `contextId` specific impersonation
            const cacheKey = [connectedDid, delegateDid, messageType, protocol].join('~');
            const cachedGrant = cached ? this.cachedPermissions.get(cacheKey) : undefined;
            if (cachedGrant) {
                return cachedGrant;
            }
            const permissionGrants = yield this.permissionsApi.fetchGrants({
                author: delegateDid,
                target: delegateDid,
                grantor: connectedDid,
                grantee: delegateDid,
            });
            // get the delegate grants that match the messageParams and are associated with the connectedDid as the grantor
            const grant = yield AgentPermissionsApi.matchGrantFromArray(connectedDid, delegateDid, { messageType, protocol }, permissionGrants, delegate);
            if (!grant) {
                throw new Error(`CachedPermissions: No permissions found for ${messageType}: ${protocol}`);
            }
            this.cachedPermissions.set(cacheKey, grant);
            return grant;
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            this.cachedPermissions.clear();
        });
    }
}
//# sourceMappingURL=cached-permissions.js.map