{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/cache.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/bytes.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/vendor/base-x.js", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/bases/base.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/bases/base32.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/bases/base58.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/bases/base64.ts", "../../src/type-utils.ts", "../../src/convert.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/varint.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/vendor/varint.js", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/hashes/digest.ts", "../../../../node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/src/cid.ts", "../../src/multicodec.ts", "../../src/object.ts", "../../src/stores.ts", "../../src/stream.ts", "../../src/stream-node.ts"],
  "sourcesContent": ["export type * from './types.js';\n\nexport * from './cache.js';\nexport * from './convert.js';\nexport * from './multicodec.js';\nexport * from './object.js';\nexport * from './stores.js';\nexport * from './stream.js';\nexport * from './stream-node.js';\nexport * from './type-utils.js';", "import TTLCache from '@isaacs/ttlcache';\nexport { TTLCache as TtlCache };", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefix.codePointAt(0) as number\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabet: string, bitsPerChar: number, name: string): Uint8Array {\n  // Build the character lookup table:\n  const codes: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "/**\n * Represents an array of a fixed length, preventing modifications to its size.\n *\n * The `FixedLengthArray` utility type transforms a standard array into a variant where\n * methods that could alter the length are omitted. It leverages TypeScript's advanced types,\n * such as conditional types and mapped types, to ensure that the array cannot be resized\n * through methods like `push`, `pop`, `splice`, `shift`, and `unshift`. The utility type\n * maintains all other characteristics of a standard array, including indexing, iteration,\n * and type checking for its elements.\n *\n * Note: The type does not prevent direct assignment to indices, even if it would exceed\n * the original length. However, such actions would lead to TypeScript type errors.\n *\n * @example\n * ```ts\n * // Declare a variable with a type of fixed-length array of three strings.\n * let myFixedLengthArray: FixedLengthArray< [string, string, string]>;\n *\n * // Array declaration tests\n * myFixedLengthArray = [ 'a', 'b', 'c' ];  // OK\n * myFixedLengthArray = [ 'a', 'b', 123 ];  // TYPE ERROR\n * myFixedLengthArray = [ 'a' ];            // LENGTH ERROR\n * myFixedLengthArray = [ 'a', 'b' ];       // LENGTH ERROR\n *\n * // Index assignment tests\n * myFixedLengthArray[1] = 'foo';           // OK\n * myFixedLengthArray[1000] = 'foo';        // INVALID INDEX ERROR\n *\n * // Methods that mutate array length\n * myFixedLengthArray.push('foo');          // MISSING METHOD ERROR\n * myFixedLengthArray.pop();                // MISSING METHOD ERROR\n *\n * // Direct length manipulation\n * myFixedLengthArray.length = 123;         // READ-ONLY ERROR\n *\n * // Destructuring\n * let [ a ] = myFixedLengthArray;          // OK\n * let [ a, b ] = myFixedLengthArray;       // OK\n * let [ a, b, c ] = myFixedLengthArray;    // OK\n * let [ a, b, c, d ] = myFixedLengthArray; // INVALID INDEX ERROR\n * ```\n *\n * @template T extends any[] - The array type to be transformed.\n */\nexport type FixedLengthArray<T extends any[]> =\n  Pick<T, Exclude<keyof T, ArrayLengthMutationKeys>>\n  & {\n    /**\n     * Custom iterator for the `FixedLengthArray` type.\n     *\n     * This iterator allows the `FixedLengthArray` to be used in standard iteration\n     * contexts, such as `for...of` loops and spread syntax. It ensures that even though\n     * the array is of a fixed length with disabled mutation methods, it still retains\n     * iterable behavior similar to a regular array.\n     *\n     * @returns An IterableIterator for the array items.\n     */\n    [Symbol.iterator]: () => IterableIterator<ArrayItems<T>>\n  };\n\n/** Helper types for {@link FixedLengthArray} */\ntype ArrayLengthMutationKeys = 'splice' | 'push' | 'pop' | 'shift' | 'unshift' | number;\ntype ArrayItems<T extends Array<any>> = T extends Array<infer TItems> ? TItems : never;\n\n/**\n * isArrayBufferSlice\n *\n * Checks if the ArrayBufferView represents a slice (subarray or a subview)\n * of an ArrayBuffer.\n *\n * An ArrayBufferView (TypedArray or DataView) can represent a portion of an\n * ArrayBuffer - such a view is said to be a \"slice\" of the original buffer.\n * This can occur when the `subarray` or `slice` method is called on a\n * TypedArray or when a DataView is created with a byteOffset and/or\n * byteLength that doesn't cover the full ArrayBuffer.\n *\n * @param arrayBufferView - The ArrayBufferView to be checked\n * @returns true if the ArrayBufferView represents a slice of an ArrayBuffer; false otherwise.\n */\nexport function isArrayBufferSlice(arrayBufferView: ArrayBufferView): boolean {\n  return arrayBufferView.byteOffset !== 0 || arrayBufferView.byteLength !== arrayBufferView.buffer.byteLength;\n}\n\n/**\n * Checks if the given object is an AsyncIterable.\n *\n * An AsyncIterable is an object that implements the AsyncIterable protocol,\n * which means it has a [Symbol.asyncIterator] method. This function checks\n * if the provided object conforms to this protocol by verifying the presence\n * and type of the [Symbol.asyncIterator] method.\n *\n * @param obj - The object to be checked for AsyncIterable conformity.\n * @returns True if the object is an AsyncIterable, false otherwise.\n *\n * @example\n * ```ts\n * // Returns true for a valid AsyncIterable\n * const asyncIterable = {\n *   async *[Symbol.asyncIterator]() {\n *     yield 1;\n *     yield 2;\n *   }\n * };\n * console.log(isAsyncIterable(asyncIterable)); // true\n * ```\n *\n * @example\n * ```ts\n * // Returns false for a regular object\n * console.log(isAsyncIterable({ a: 1, b: 2 })); // false\n * ```\n */\nexport function isAsyncIterable(obj: any): obj is AsyncIterable<any> {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * isDefined\n *\n * Utility function to check if a variable is neither null nor undefined.\n * This function helps in making TypeScript infer the type of the variable\n * as being defined, excluding `null` and `undefined`.\n *\n * The function uses strict equality (`!==`) for the comparison, ensuring\n * that the variable is not just falsy (like an empty string or zero),\n * but is truly either `null` or `undefined`.\n *\n * @param arg - The variable to be checked\n * @returns true if the variable is neither `null` nor `undefined`\n */\nexport function isDefined<T>(arg: T): arg is Exclude<T, null | undefined> {\n  return arg !== null && typeof arg !== 'undefined';\n}\n\n/**\n * Utility type that transforms a type `T` to have only certain keys `K` as required, while the\n * rest remain optional, except for keys specified in `O`, which are omitted entirely.\n *\n * This type is useful when you need a variation of a type where only specific properties are\n * required, and others are either optional or not included at all. It allows for more flexible type\n * definitions based on existing types without the need to redefine them.\n *\n * @template T - The original type to be transformed.\n * @template K - The keys of `T` that should be required.\n * @template O - The keys of `T` that should be omitted from the resulting type (optional).\n *\n * @example\n * ```ts\n * // Given an interface\n * interface Example {\n *   requiredProp: string;\n *   optionalProp?: number;\n *   anotherOptionalProp?: boolean;\n * }\n *\n * // Making 'optionalProp' required and omitting 'anotherOptionalProp'\n * type ModifiedExample = RequireOnly<Example, 'optionalProp', 'anotherOptionalProp'>;\n * // Result: { requiredProp?: string; optionalProp: number; }\n * ```\n */\nexport type RequireOnly<T, K extends keyof T, O extends keyof T = never> = Required<Pick<T, K>> & Omit<Partial<T>, O>;\n\n/**\n * universalTypeOf\n *\n * Why does this function exist?\n *\n * You can typically check if a value is of a particular type, such as\n * Uint8Array or ArrayBuffer, by using the `instanceof` operator. The\n * `instanceof` operator checks the prototype property of a constructor\n * in the object's prototype chain.\n *\n * However, there is a caveat with the `instanceof` check if the value\n * was created from a different JavaScript context (like an iframe or\n * a web worker). In those cases, the `instanceof` check might fail\n * because each context has a different global object, and therefore,\n * different built-in constructor functions.\n *\n * The `typeof` operator provides information about the type of the\n * operand in a less detailed way. For basic data types like number,\n * string, boolean, and undefined, the `typeof` operator works as\n * expected.  However, for objects, including arrays and null,\n * it always returns \"object\".  For functions, it returns \"function\".\n * So, while `typeof` is good for basic type checking, it doesn't\n * give detailed information about complex data types.\n *\n * Unlike `instanceof` and `typeof`, `Object.prototype.toString.call(value)`\n * can ensure a consistent result across different JavaScript\n * contexts.\n *\n * Credit for inspiration:\n *   Angus Croll\n *   https://github.com/angus-c\n *   https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/\n */\nexport function universalTypeOf(value: unknown) {\n  // Returns '[Object Type]' string.\n  const typeString = Object.prototype.toString.call(value);\n  // Returns ['Object', 'Type'] array or null.\n  const match = typeString.match(/\\s([a-zA-Z0-9]+)/);\n  // Deconstructs the array and gets just the type from index 1.\n  const [_, type] = match as RegExpMatchArray;\n\n  return type;\n}\n\n/**\n * Utility type to extract the type resolved by a Promise.\n *\n * This type unwraps the type `T` from `Promise<T>` if `T` is a Promise, otherwise returns `T` as\n * is. It's useful in situations where you need to handle the type returned by a promise-based\n * function in a synchronous context, such as defining types for test vectors or handling return\n * types in non-async code blocks.\n *\n * @template T - The type to unwrap from the Promise.\n *\n * @example\n * ```ts\n * // For a Promise type, it extracts the resolved type.\n * type AsyncNumber = Promise<number>;\n * type UnwrappedNumber = UnwrapPromise<AsyncNumber>; // number\n *\n * // For a non-Promise type, it returns the type as is.\n * type StringValue = string;\n * type UnwrappedString = UnwrapPromise<StringValue>; // string\n * ```\n */\nexport type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;", "import type { Multibase } from 'multiformats';\n\nimport { base32z } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64url } from 'multiformats/bases/base64';\n\nimport { isAsyncIterable, isArrayBufferSlice, universalTypeOf } from './type-utils.js';\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\nexport class Convert {\n  data: any;\n  format: string;\n\n  constructor(data: any, format: string) {\n    this.data = data;\n    this.format = format;\n  }\n\n  static arrayBuffer(data: ArrayBuffer): Convert {\n    return new Convert(data, 'ArrayBuffer');\n  }\n\n  static asyncIterable(data: AsyncIterable<any>): Convert {\n    if (!isAsyncIterable(data)) {\n      throw new TypeError('Input must be of type AsyncIterable.');\n    }\n    return new Convert(data, 'AsyncIterable');\n  }\n\n  static base32Z(data: string): Convert {\n    return new Convert(data, 'Base32Z');\n  }\n\n  static base58Btc(data: string): Convert {\n    return new Convert(data, 'Base58Btc');\n  }\n\n  static base64Url(data: string): Convert {\n    return new Convert(data, 'Base64Url');\n  }\n\n  /**\n   * Reference:\n   * The BufferSource type is a TypeScript type that represents an ArrayBuffer\n   * or one of the ArrayBufferView types, such a TypedArray (e.g., Uint8Array)\n   * or a DataView.\n   */\n  static bufferSource(data: BufferSource): Convert {\n    return new Convert(data, 'BufferSource');\n  }\n\n  static hex(data: string): Convert {\n    if (typeof data !== 'string') {\n      throw new TypeError('Hex input must be a string.');\n    }\n    if (data.length % 2 !== 0) {\n      throw new TypeError('Hex input must have an even number of characters.');\n    }\n    return new Convert(data, 'Hex');\n  }\n\n  static multibase(data: string): Convert {\n    return new Convert(data, 'Multibase');\n  }\n\n  static object(data: Record<string, any>): Convert {\n    return new Convert(data, 'Object');\n  }\n\n  static string(data: string): Convert {\n    return new Convert(data, 'String');\n  }\n\n  static uint8Array(data: Uint8Array): Convert {\n    return new Convert(data, 'Uint8Array');\n  }\n\n  toArrayBuffer(): ArrayBuffer {\n    switch (this.format) {\n\n      case 'Base58Btc': {\n        return base58btc.baseDecode(this.data).buffer;\n      }\n\n      case 'Base64Url': {\n        return base64url.baseDecode(this.data).buffer;\n      }\n\n      case 'BufferSource': {\n        const dataType = universalTypeOf(this.data);\n        if (dataType === 'ArrayBuffer') {\n          // Data is already an ArrayBuffer, No conversion is necessary.\n          return this.data;\n        } else if (ArrayBuffer.isView(this.data)) {\n          // Data is a DataView or a different TypedArray (e.g., Uint16Array).\n          if (isArrayBufferSlice(this.data)) {\n            // Data is a slice of an ArrayBuffer. Return a new ArrayBuffer or ArrayBufferView of the same slice.\n            return this.data.buffer.slice(this.data.byteOffset, this.data.byteOffset + this.data.byteLength);\n          } else {\n            // Data is a whole ArrayBuffer viewed as a different TypedArray or DataView. Return the whole ArrayBuffer.\n            return this.data.buffer;\n          }\n        } else {\n          throw new TypeError(`${this.format} value is not of type: ArrayBuffer, DataView, or TypedArray.`);\n        }\n      }\n\n      case 'Hex': {\n        return this.toUint8Array().buffer;\n      }\n\n      case 'String': {\n        return this.toUint8Array().buffer;\n      }\n\n      case 'Uint8Array': {\n        return this.data.buffer;\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to ArrayBuffer is not supported.`);\n    }\n  }\n\n  async toArrayBufferAsync(): Promise<ArrayBuffer> {\n    switch (this.format) {\n      case 'AsyncIterable': {\n        const blob = await this.toBlobAsync();\n        return await blob.arrayBuffer();\n      }\n\n      default:\n        throw new TypeError(`Asynchronous conversion from ${this.format} to ArrayBuffer is not supported.`);\n    }\n  }\n\n  toBase32Z(): string {\n    switch (this.format) {\n\n      case 'Uint8Array': {\n        return base32z.baseEncode(this.data);\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to Base64Z is not supported.`);\n    }\n  }\n\n  toBase58Btc(): string {\n    switch (this.format) {\n\n      case 'ArrayBuffer': {\n        const u8a = new Uint8Array(this.data);\n        return base58btc.baseEncode(u8a);\n      }\n\n      case 'Multibase': {\n        return this.data.substring(1);\n      }\n\n      case 'Uint8Array': {\n        return base58btc.baseEncode(this.data);\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to Base58Btc is not supported.`);\n    }\n  }\n\n  toBase64Url(): string {\n    switch (this.format) {\n\n      case 'ArrayBuffer': {\n        const u8a = new Uint8Array(this.data);\n        return base64url.baseEncode(u8a);\n      }\n\n      case 'BufferSource': {\n        const u8a = this.toUint8Array();\n        return base64url.baseEncode(u8a);\n      }\n\n      case 'Object': {\n        const string = JSON.stringify(this.data);\n        const u8a = textEncoder.encode(string);\n        return base64url.baseEncode(u8a);\n      }\n\n      case 'String': {\n        const u8a = textEncoder.encode(this.data);\n        return base64url.baseEncode(u8a);\n      }\n\n      case 'Uint8Array': {\n        return base64url.baseEncode(this.data);\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to Base64Url is not supported.`);\n    }\n  }\n\n  async toBlobAsync(): Promise<Blob> {\n    switch (this.format) {\n      case 'AsyncIterable': {\n        // Initialize an array to hold the chunks from the AsyncIterable.\n        const chunks = [];\n\n        // Asynchronously iterate over each chunk in the AsyncIterable.\n        for await (const chunk of (this.data as AsyncIterable<any>)) {\n          // Append each chunk to the chunks array. These chunks can be of any type, typically binary data or text.\n          chunks.push(chunk);\n        }\n\n        // Create a new Blob from the aggregated chunks.\n        // The Blob constructor combines these chunks into a single Blob object.\n        const blob = new Blob(chunks);\n\n        return blob;\n      }\n\n      default:\n        throw new TypeError(`Asynchronous conversion from ${this.format} to Blob is not supported.`);\n    }\n  }\n\n  toHex(): string {\n    // pre-calculating Hex values improves runtime by 6-10x.\n    const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n\n    switch (this.format) {\n\n      case 'ArrayBuffer': {\n        const u8a = this.toUint8Array();\n        return Convert.uint8Array(u8a).toHex();\n      }\n\n      case 'Base64Url': {\n        const u8a = this.toUint8Array();\n        return Convert.uint8Array(u8a).toHex();\n      }\n\n      case 'Uint8Array': {\n        let hex = '';\n        for (let i = 0; i < this.data.length; i++) {\n          hex += hexes[this.data[i]];\n        }\n        return hex;\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to Hex is not supported.`);\n    }\n  }\n\n  toMultibase(): Multibase<any> {\n    switch (this.format) {\n      case 'Base58Btc': {\n        return `z${this.data}`;\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to Multibase is not supported.`);\n    }\n  }\n\n  toObject(): object {\n    switch (this.format) {\n\n      case 'Base64Url': {\n        const u8a = base64url.baseDecode(this.data);\n        const text = textDecoder.decode(u8a);\n        return JSON.parse(text);\n      }\n\n      case 'String': {\n        return JSON.parse(this.data);\n      }\n\n      case 'Uint8Array': {\n        const text = textDecoder.decode(this.data);\n        return JSON.parse(text);\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to Object is not supported.`);\n    }\n  }\n\n  async toObjectAsync(): Promise<any> {\n    switch (this.format) {\n      case 'AsyncIterable': {\n        // Convert the AsyncIterable to a String.\n        const text = await this.toStringAsync();\n\n        // Parse the string as JSON. This step assumes that the string represents a valid JSON structure.\n        // JSON.parse() will convert the string into a corresponding JavaScript object.\n        const json = JSON.parse(text);\n\n        // Return the parsed JavaScript object. The type of this object will depend on the structure\n        // of the JSON in the stream. It could be an object, array, string, number, etc.\n        return json;\n      }\n\n      default:\n        throw new TypeError(`Asynchronous conversion from ${this.format} to Object is not supported.`);\n    }\n  }\n\n  toString(): string {\n    switch (this.format) {\n\n      case 'ArrayBuffer': {\n        return textDecoder.decode(this.data);\n      }\n\n      case 'Base64Url': {\n        const u8a = base64url.baseDecode(this.data);\n        return textDecoder.decode(u8a);\n      }\n\n      case 'Object': {\n        return JSON.stringify(this.data);\n      }\n\n      case 'Uint8Array': {\n        return textDecoder.decode(this.data);\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to String is not supported.`);\n    }\n  }\n\n  async toStringAsync(): Promise<string> {\n    switch (this.format) {\n      case 'AsyncIterable': {\n        // Initialize an empty string to accumulate the decoded text.\n        let str = '';\n\n        // Iterate over the chunks from the AsyncIterable.\n        for await (const chunk of (this.data as AsyncIterable<any>)) {\n          // If the chunk is already a string, concatenate it directly.\n          if (typeof chunk === 'string')\n            str += chunk;\n          else\n          // If the chunk is a Uint8Array or similar, use the decoder to convert it to a string.\n          // The `stream: true` option lets the decoder handle multi-byte characters spanning\n          // multiple chunks.\n            str += textDecoder.decode(chunk, { stream: true });\n        }\n\n        // Finalize the decoding process to handle any remaining bytes and signal the end of the stream.\n        // The `stream: false` option flushes the decoder's internal state.\n        str += textDecoder.decode(undefined, { stream: false });\n\n        // Return the accumulated string.\n        return str;\n      }\n\n      default:\n        throw new TypeError(`Asynchronous conversion from ${this.format} to String is not supported.`);\n    }\n  }\n\n  toUint8Array(): Uint8Array {\n    switch (this.format) {\n\n      case 'ArrayBuffer': {\n        // \u00C7reate Uint8Array as a view on the ArrayBuffer.\n        // Note: The Uint8Array shares the same memory as the ArrayBuffer, so this operation is very efficient.\n        return new Uint8Array(this.data);\n      }\n\n      case 'Base32Z': {\n        return base32z.baseDecode(this.data);\n      }\n\n      case 'Base58Btc': {\n        return base58btc.baseDecode(this.data);\n      }\n\n      case 'Base64Url': {\n        return base64url.baseDecode(this.data);\n      }\n\n      case 'BufferSource': {\n        const dataType = universalTypeOf(this.data);\n        if (dataType === 'Uint8Array') {\n          // Data is already a Uint8Array. No conversion is necessary.\n          // Note: Uint8Array is a type of BufferSource.\n          return this.data;\n        } else if (dataType === 'ArrayBuffer') {\n          // Data is an ArrayBuffer, create Uint8Array as a view on the ArrayBuffer.\n          // Note: The Uint8Array shares the same memory as the ArrayBuffer, so this operation is very efficient.\n          return new Uint8Array(this.data);\n        } else if (ArrayBuffer.isView(this.data)) {\n          // Data is a DataView or a different TypedArray (e.g., Uint16Array).\n          return new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);\n        } else {\n          throw new TypeError(`${this.format} value is not of type: ArrayBuffer, DataView, or TypedArray.`);\n        }\n      }\n\n      case 'Hex': {\n        const u8a = new Uint8Array(this.data.length / 2);\n        for (let i = 0; i < this.data.length; i += 2) {\n          const byteValue = parseInt(this.data.substring(i, i + 2), 16);\n          if (isNaN(byteValue)) {\n            throw new TypeError('Input is not a valid hexadecimal string.');\n          }\n          u8a[i / 2] = byteValue;\n        }\n        return u8a;\n      }\n\n      case 'Object': {\n        const string = JSON.stringify(this.data);\n        return textEncoder.encode(string);\n      }\n\n      case 'String': {\n        return textEncoder.encode(this.data);\n      }\n\n      default:\n        throw new TypeError(`Conversion from ${this.format} to Uint8Array is not supported.`);\n    }\n  }\n\n  async toUint8ArrayAsync(): Promise<Uint8Array> {\n    switch (this.format) {\n      case 'AsyncIterable': {\n        const arrayBuffer = await this.toArrayBufferAsync();\n        return new Uint8Array(arrayBuffer);\n      }\n\n      default:\n        throw new TypeError(`Asynchronous conversion from ${this.format} to Uint8Array is not supported.`);\n    }\n  }\n}", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import { varint } from 'multiformats';\n\nexport type MulticodecCode = number;\n\nexport type MulticodecDefinition<MulticodecCode> = {\n  code: MulticodecCode;\n  // codeBytes: Uint8Array;\n  name: string;\n}\n\n/**\n * The `Multicodec` class provides an interface to prepend binary data\n * with a prefix that identifies the data that follows.\n * https://github.com/multiformats/multicodec/blob/master/table.csv\n *\n * Multicodec is a self-describing multiformat, it wraps other formats with\n * a tiny bit of self-description. A multicodec identifier is a\n * varint (variable integer) that indicates the format of the data.\n *\n * The canonical table of multicodecs can be access at the following URL:\n * https://github.com/multiformats/multicodec/blob/master/table.csv\n *\n * Example usage:\n *\n * ```ts\n * Multicodec.registerCodec({ code: 0xed, name: 'ed25519-pub' });\n * const prefixedData = Multicodec.addPrefix({ code: 0xed, data: new Uint8Array(32) });\n * ```\n */\nexport class Multicodec {\n  /**\n   * A static field containing a map of codec codes to their corresponding names.\n   */\n  static codeToName = new Map<MulticodecCode, string>();\n\n  /**\n   * A static field containing a map of codec names to their corresponding codes.\n   */\n  static nameToCode = new Map<string, MulticodecCode>();\n\n  /**\n   * Adds a multicodec prefix to input data.\n   *\n   * @param options - The options for adding a prefix.\n   * @param options.code - The codec code. Either the code or name must be provided.\n   * @param options.name - The codec name. Either the code or name must be provided.\n   * @param options.data - The data to be prefixed.\n   * @returns The data with the added prefix as a Uint8Array.\n   */\n  public static addPrefix(options: {\n    code?: MulticodecCode,\n    data: Uint8Array,\n    name?: string,\n  }): Uint8Array {\n    let { code, data, name } = options;\n\n    if (!(name ? !code : code)) {\n      throw new Error(`Either 'name' or 'code' must be defined, but not both.`);\n    }\n\n    // If code was given, confirm it exists, or lookup code by name.\n    code = Multicodec.codeToName.has(code!) ? code : Multicodec.nameToCode.get(name!);\n\n    // Throw error if a registered Codec wasn't found.\n    if (code === undefined) {\n      throw new Error(`Unsupported multicodec: ${options.name ?? options.code}`);\n    }\n\n    // Create a new array to store the prefix and input data.\n    const prefixLength = varint.encodingLength(code);\n    const dataWithPrefix = new Uint8Array(prefixLength + data.byteLength);\n    dataWithPrefix.set(data, prefixLength);\n\n    // Prepend the prefix.\n    varint.encodeTo(code, dataWithPrefix);\n\n    return dataWithPrefix;\n  }\n\n  /**\n   * Get the Multicodec code from given prefixed data.\n   *\n   * @param options - The options for getting the codec code.\n   * @param options.prefixedData - The data to extract the codec code from.\n   * @returns - The Multicodec code as a number.\n   */\n  public static getCodeFromData(options: {\n    prefixedData: Uint8Array\n  }): MulticodecCode {\n    const { prefixedData } = options;\n    const [code, _] = varint.decode(prefixedData);\n\n    return code;\n  }\n\n  /**\n   * Get the Multicodec code from given Multicodec name.\n   *\n   * @param options - The options for getting the codec code.\n   * @param options.name - The name to lookup.\n   * @returns - The Multicodec code as a number.\n   */\n  public static getCodeFromName(options: {\n    name: string\n  }): MulticodecCode {\n    const { name } = options;\n\n    // Throw error if a registered Codec wasn't found.\n    const code = Multicodec.nameToCode.get(name);\n    if (code === undefined) {\n      throw new Error(`Unsupported multicodec: ${name}`);\n    }\n\n    return code;\n  }\n\n  /**\n   * Get the Multicodec name from given Multicodec code.\n   *\n   * @param options - The options for getting the codec name.\n   * @param options.name - The code to lookup.\n   * @returns - The Multicodec name as a string.\n   */\n  public static getNameFromCode(options: {\n    code: MulticodecCode\n  }): string {\n    const { code } = options;\n\n    // Throw error if a registered Codec wasn't found.\n    const name = Multicodec.codeToName.get(code);\n    if (name === undefined) {\n      throw new Error(`Unsupported multicodec: ${code}`);\n    }\n\n    return name;\n  }\n\n  /**\n   * Registers a new codec in the Multicodec class.\n   *\n   * @param codec - The codec to be registered.\n   */\n  public static registerCodec(codec: MulticodecDefinition<MulticodecCode>) {\n    Multicodec.codeToName.set(codec.code, codec.name);\n    Multicodec.nameToCode.set(codec.name, codec.code);\n  }\n\n  /**\n   * Returns the data with the Multicodec prefix removed.\n   *\n   * @param refixedData - The data to extract the codec code from.\n   * @returns {Uint8Array}\n   */\n  public static removePrefix(options: {\n    prefixedData: Uint8Array\n  }): { code: MulticodecCode, name: string, data: Uint8Array } {\n    const { prefixedData } = options;\n    const [code, codeByteLength] = varint.decode(prefixedData);\n\n    // Throw error if a registered Codec wasn't found.\n    const name = Multicodec.codeToName.get(code);\n    if (name === undefined) {\n      throw new Error(`Unsupported multicodec: ${code}`);\n    }\n\n    return { code, data: prefixedData.slice(codeByteLength), name };\n  }\n}\n\n// Pre-defined registered codecs:\nMulticodec.registerCodec({ code: 0xed, name: 'ed25519-pub' });\nMulticodec.registerCodec({ code: 0x1300, name: 'ed25519-priv' });\nMulticodec.registerCodec({ code: 0xec, name: 'x25519-pub' });\nMulticodec.registerCodec({ code: 0x1302, name: 'x25519-priv' });\nMulticodec.registerCodec({ code: 0xe7, name: 'secp256k1-pub' });\nMulticodec.registerCodec({ code: 0x1301, name: 'secp256k1-priv' });", "/**\n * Checks whether the given object has any properties.\n */\nexport function isEmptyObject(obj: unknown): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  if (Object.getOwnPropertySymbols(obj).length > 0) {\n    return false;\n  }\n\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * Recursively removes all properties with an empty object or array as its value from the given object.\n */\nexport function removeEmptyObjects(obj: Record<string, unknown>): void {\n  Object.keys(obj).forEach(key => {\n    if (typeof(obj[key]) === 'object') {\n      // recursive remove empty object or array properties in nested objects\n      removeEmptyObjects(obj[key] as Record<string, unknown>);\n    }\n\n    if (isEmptyObject(obj[key])) {\n      delete obj[key];\n    }\n  });\n}\n\n/**\n * Recursively removes all properties with `undefined` as its value from the given object.\n */\nexport function removeUndefinedProperties(obj: Record<string, unknown>): void {\n  Object.keys(obj).forEach(key => {\n    if (obj[key] === undefined) {\n      delete obj[key];\n    } else if (typeof(obj[key]) === 'object') {\n      removeUndefinedProperties(obj[key] as Record<string, unknown>); // recursive remove `undefined` properties in nested objects\n    }\n  });\n}", "import type { AbstractLevel } from 'abstract-level';\n\nimport { Level } from 'level';\n\nimport type { KeyValueStore } from './types.js';\n\nexport class LevelStore<K = string, V = any> implements KeyValueStore<K, V> {\n  private store: AbstractLevel<string | Buffer | Uint8Array, K, V>;\n\n  constructor({ db, location = 'DATASTORE' }: {\n    db?: AbstractLevel<string | Buffer | Uint8Array, K, V>;\n    location?: string;\n  } = {}) {\n    this.store = db ?? new Level<K, V>(location);\n  }\n\n  async clear(): Promise<void> {\n    await this.store.clear();\n  }\n\n  async close(): Promise<void> {\n    await this.store.close();\n  }\n\n  async delete(key: K): Promise<void> {\n    await this.store.del(key);\n  }\n\n  async get(key: K): Promise<V | undefined> {\n    try {\n      return await this.store.get(key);\n    } catch (error: any) {\n      // Don't throw when a key wasn't found.\n      if (error.notFound) return undefined;\n      throw error;\n    }\n  }\n\n  async set(key: K, value: V): Promise<void> {\n    await this.store.put(key, value);\n  }\n}\n\n/**\n * The `MemoryStore` class is an implementation of\n * `KeyValueStore` that holds data in memory.\n *\n * It provides a basic key-value store that works synchronously and keeps all\n * data in memory. This can be used for testing, or for handling small amounts\n * of data with simple key-value semantics.\n *\n * Example usage:\n *\n * ```ts\n * const memoryStore = new MemoryStore<string, number>();\n * await memoryStore.set(\"key1\", 1);\n * const value = await memoryStore.get(\"key1\");\n * console.log(value); // 1\n * ```\n *\n * @public\n */\nexport class MemoryStore<K, V> implements KeyValueStore<K, V> {\n  /**\n   * A private field that contains the Map used as the key-value store.\n   */\n  private store: Map<K, V> = new Map();\n\n  /**\n   * Clears all entries in the key-value store.\n   *\n   * @returns A Promise that resolves when the operation is complete.\n   */\n  async clear(): Promise<void> {\n    this.store.clear();\n  }\n\n  /**\n   * This operation is no-op for `MemoryStore`\n   * and will log a warning if called.\n   */\n  async close(): Promise<void> {\n    /** no-op */\n  }\n\n  /**\n   * Deletes an entry from the key-value store by its key.\n   *\n   * @param id - The key of the entry to delete.\n   * @returns A Promise that resolves to a boolean indicating whether the entry was successfully deleted.\n   */\n  async delete(id: K): Promise<boolean> {\n    return this.store.delete(id);\n  }\n\n  /**\n   * Retrieves the value of an entry by its key.\n   *\n   * @param id - The key of the entry to retrieve.\n   * @returns A Promise that resolves to the value of the entry, or `undefined` if the entry does not exist.\n   */\n  async get(id: K): Promise<V | undefined> {\n    return this.store.get(id);\n  }\n\n  /**\n   * Checks for the presence of an entry by key.\n   *\n   * @param id - The key to check for the existence of.\n   * @returns A Promise that resolves to a boolean indicating whether an element with the specified key exists or not.\n   */\n  async has(id: K): Promise<boolean> {\n    return this.store.has(id);\n  }\n\n  /**\n   * Retrieves all values in the key-value store.\n   *\n   * @returns A Promise that resolves to an array of all values in the store.\n   */\n  async list(): Promise<V[]> {\n    return Array.from(this.store.values());\n  }\n\n  /**\n   * Sets the value of an entry in the key-value store.\n   *\n   * @param id - The key of the entry to set.\n   * @param key - The new value for the entry.\n   * @returns A Promise that resolves when the operation is complete.\n   */\n  async set(id: K, key: V): Promise<void> {\n    this.store.set(id, key);\n  }\n}", "import { Convert } from './convert.js';\n\nexport class Stream {\n  /**\n   * Transforms a `ReadableStream` into an `AsyncIterable`. This allows for the asynchronous\n   * iteration over the stream's data chunks.\n   *\n   * This method creates an async iterator from a `ReadableStream`, enabling the use of\n   * `for await...of` loops to process stream data. It reads from the stream until it's closed or\n   * errored, yielding each chunk as it becomes available.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream({ ... });\n   * for await (const chunk of Stream.asAsyncIterator(readableStream)) {\n   *   // process each chunk\n   * }\n   * ```\n   *\n   * @remarks\n   * - The method ensures proper cleanup by releasing the reader lock when iteration is completed or\n   *   if an error occurs.\n   *\n   * @param readableStream - The Web `ReadableStream` to be transformed into an `AsyncIterable`.\n   * @returns An `AsyncIterable` that yields data chunks from the `ReadableStream`.\n   */\n  public static async * asAsyncIterator<T>(readableStream: ReadableStream<T>): AsyncIterable<T> {\n    const reader = readableStream.getReader();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        yield value;\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n\n  /**\n   * Consumes a `ReadableStream` and returns its contents as an `ArrayBuffer`.\n   *\n   * This method reads all data from a `ReadableStream`, collects it, and converts it into an\n   * `ArrayBuffer`.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream({ ... });\n   * const arrayBuffer = await Stream.consumeToArrayBuffer({ readableStream });\n   * ```\n   *\n   * @param readableStream - The Web `ReadableStream` whose data will be consumed.\n   * @returns A Promise that resolves to an `ArrayBuffer` containing all the data from the stream.\n   */\n  public static async consumeToArrayBuffer({ readableStream }: { readableStream: ReadableStream}): Promise<ArrayBuffer> {\n    const iterableStream = Stream.asAsyncIterator(readableStream);\n    const arrayBuffer = await Convert.asyncIterable(iterableStream).toArrayBufferAsync();\n\n    return arrayBuffer;\n  }\n\n  /**\n   * Consumes a `ReadableStream` and returns its contents as a `Blob`.\n   *\n   * This method reads all data from a `ReadableStream`, collects it, and converts it into a `Blob`.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream({ ... });\n   * const blob = await Stream.consumeToBlob({ readableStream });\n   * ```\n   *\n   * @param readableStream - The Web `ReadableStream` whose data will be consumed.\n   * @returns A Promise that resolves to a `Blob` containing all the data from the stream.\n   */\n  public static async consumeToBlob({ readableStream }: { readableStream: ReadableStream}): Promise<Blob> {\n    const iterableStream = Stream.asAsyncIterator(readableStream);\n    const blob = await Convert.asyncIterable(iterableStream).toBlobAsync();\n\n    return blob;\n  }\n\n  /**\n   * Consumes a `ReadableStream` and returns its contents as a `Uint8Array`.\n   *\n   * This method reads all data from a `ReadableStream`, collects it, and converts it into a\n   * `Uint8Array`.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream({ ... });\n   * const bytes = await Stream.consumeToBytes({ readableStream });\n   * ```\n   *\n   * @param readableStream - The Web `ReadableStream` whose data will be consumed.\n   * @returns A Promise that resolves to a `Uint8Array` containing all the data from the stream.\n   */\n  public static async consumeToBytes({ readableStream }: { readableStream: ReadableStream }): Promise<Uint8Array> {\n    const iterableStream = Stream.asAsyncIterator(readableStream);\n    const bytes = await Convert.asyncIterable(iterableStream).toUint8ArrayAsync();\n\n    return bytes;\n  }\n\n  /**\n   * Consumes a `ReadableStream` and parses its contents as JSON.\n   *\n   * This method reads all the data from the stream, converts it to a text string, and then parses\n   * it as JSON, returning the resulting object.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream({ ... });\n   * const jsonData = await Stream.consumeToJson({ readableStream });\n   * ```\n   *\n   * @param readableStream - The Web `ReadableStream` whose JSON content will be consumed.\n   * @returns A Promise that resolves to the parsed JSON object from the stream's data.\n   */\n  public static async consumeToJson({ readableStream }: { readableStream: ReadableStream}): Promise<any> {\n    const iterableStream = Stream.asAsyncIterator(readableStream);\n    const object = await Convert.asyncIterable(iterableStream).toObjectAsync();\n\n    return object;\n  }\n\n  /**\n   * Consumes a `ReadableStream` and returns its contents as a text string.\n   *\n   * This method reads all the data from the stream, converting it into a single string.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream({ ... });\n   * const text = await Stream.consumeToText({ readableStream });\n   * ```\n   *\n   * @param readableStream - The Web `ReadableStream` whose text content will be consumed.\n   * @returns A Promise that resolves to a string containing all the data from the stream.\n   */\n  public static async consumeToText({ readableStream }: { readableStream: ReadableStream}): Promise<string> {\n    const iterableStream = Stream.asAsyncIterator(readableStream);\n    const text = await Convert.asyncIterable(iterableStream).toStringAsync();\n\n    return text;\n  }\n\n  /**\n   * Generates a `ReadableStream` of `Uint8Array` chunks with customizable length and fill value.\n   *\n   * This method creates a `ReadableStream` that emits `Uint8Array` chunks. You can specify the\n   * total length of the stream, the length of individual chunks, and a fill value or range for the\n   * chunks. It's useful for testing or when specific binary data streams are required.\n   *\n   * @example\n   * ```ts\n   * // Create a stream of 1000 bytes with 100-byte chunks filled with 0xAA.\n   * const byteStream = Stream.generateByteStream({\n   *   streamLength: 1000,\n   *   chunkLength: 100,\n   *   fillValue: 0xAA\n   * });\n   *\n   * // Create an unending stream of 100KB chunks filled with values that range from 1 to 99.\n   * const byteStream = Stream.generateByteStream({\n   *  chunkLength: 100 * 1024,\n   *  fillValue: [1, 99]\n   * });\n   * ```\n   *\n   * @param streamLength - The total length of the stream in bytes. If omitted, the stream is infinite.\n   * @param chunkLength - The length of each chunk. If omitted, each chunk is the size of `streamLength`.\n   * @param fillValue - A value or range to fill the chunks with. Can be a single number or a tuple [min, max].\n   * @returns A `ReadableStream` that emits `Uint8Array` chunks.\n   */\n  public static generateByteStream({ streamLength, chunkLength, fillValue }: {\n    streamLength?: number,\n    chunkLength?: number,\n    fillValue?: number | [number, number]\n  }): ReadableStream<Uint8Array> {\n    let bytesRemaining = streamLength ?? Infinity;\n    let controller: ReadableStreamDefaultController<Uint8Array>;\n\n    function enqueueChunk() {\n      const currentChunkLength = Math.min(bytesRemaining, chunkLength ?? Infinity);\n      bytesRemaining -= currentChunkLength;\n\n      let chunk: Uint8Array;\n\n      if (typeof fillValue === 'number') {\n        chunk = new Uint8Array(currentChunkLength).fill(fillValue);\n\n      } else if (Array.isArray(fillValue)) {\n        chunk = new Uint8Array(currentChunkLength);\n        const [min, max] = fillValue;\n        const range = max - min + 1;\n        for (let i = 0; i < currentChunkLength; i++) {\n          chunk[i] = Math.floor(Math.random() * range) + min;\n        }\n\n      } else {\n        chunk = new Uint8Array(currentChunkLength);\n      }\n\n      controller.enqueue(chunk);\n\n      // If there are no more bytes to send, close the stream\n      if (bytesRemaining <= 0) {\n        controller.close();\n      }\n    }\n\n    return new ReadableStream<Uint8Array>({\n      start(c) {\n        controller = c;\n        enqueueChunk();\n      },\n      pull() {\n        enqueueChunk();\n      },\n    });\n  }\n\n  /**\n   * Checks if the provided Web `ReadableStream` is in a readable state.\n   *\n   * After verifying that the stream is a Web {@link https://streams.spec.whatwg.org/#rs-model | ReadableStream},\n   * this method checks the {@link https://streams.spec.whatwg.org/#readablestream-locked | locked}\n   * property of the ReadableStream. The `locked` property is `true` if a reader is currently\n   * active, meaning the stream is either being read or has already been read (and hence is not in a\n   * readable state). If `locked` is `false`, it means the stream is still in a state where it can\n   * be read.\n   *\n   * In the case where a `ReadableStream` has been unlocked but is no longer readable (for example,\n   * if it has been fully read or cancelled), additional checks are needed beyond just examining the\n   * locked property. The ReadableStream API does not provide a direct way to check if the stream\n   * has data left or if it's in a readable state once it's been unlocked.\n   *\n   * Per {@link https://streams.spec.whatwg.org/#other-specs-rs-introspect | WHATWG Streams, Section 9.1.3. Introspection}:\n   *\n   * > ...note that apart from checking whether or not the stream is locked, this direct\n   * > introspection is not possible via the public JavaScript API, and so specifications should\n   * > instead use the algorithms in \u00A79.1.2 Reading. (For example, instead of testing if the stream\n   * > is readable, attempt to get a reader and handle any exception.)\n   *\n   * This implementation employs the technique suggested by the WHATWG Streams standard by\n   * attempting to acquire a reader and checking the state of the reader. If acquiring a reader\n   * succeeds, it immediately releases the lock and returns `true`, indicating the stream is\n   * readable. If an error occurs while trying to get a reader (which can happen if the stream is\n   * already closed or errored), it catches the error and returns `false`, indicating the stream is\n   * not readable.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream({ ... });\n   * const isStreamReadable = Stream.isReadable({ readableStream });\n   * console.log(isStreamReadable); // Output: true or false\n   * ```\n   *\n   * @remarks\n   * - This method does not check whether the stream has data left to read; it only checks if the\n   *   stream is in a state that allows reading. It is possible for a stream to be unlocked but\n   *   still have no data left if it has never been locked to a reader.\n   *\n   * @param readableStream - The Web `ReadableStream` to be checked for readability.\n   *\n   * @returns `true` if the stream is a `ReadableStream` and is in a readable state (not locked and\n   *          no error on getting a reader); otherwise, `false`.\n   */\n  public static isReadable({ readableStream }: { readableStream: ReadableStream }): boolean {\n    // Check if the stream is a WHATWG `ReadableStream`.\n    if (!Stream.isReadableStream(readableStream)) {\n      return false;\n    }\n\n    // Check if the stream is locked.\n    if (readableStream.locked) {\n      return false;\n    }\n\n    try {\n      // Try to get a reader to check if the stream is readable.\n      const reader = readableStream.getReader();\n      // If successful, immediately release the lock.\n      reader.releaseLock();\n      return true;\n    } catch (error) {\n      // If an error occurs (e.g., the stream is not readable), return false.\n      return false;\n    }\n  }\n\n  /**\n   * Checks if an object is a Web `ReadableStream`.\n   *\n   * This method verifies whether the given object is a `ReadableStream` by checking its type and\n   * the presence of the `getReader` function.\n   *\n   * @example\n   * ```ts\n   * const obj = getSomeObject();\n   * if (Stream.isReadableStream(obj)) {\n   *   // obj is a ReadableStream\n   * }\n   * ```\n   *\n   * @param obj - The object to be checked.\n   * @returns `true` if `obj` is a `ReadableStream`; otherwise, `false`.\n   */\n  public static isReadableStream(obj: unknown): obj is ReadableStream {\n    return (\n      typeof obj === 'object' && obj !== null &&\n      'getReader' in obj && typeof obj.getReader === 'function'\n    );\n  }\n\n  /**\n   * Checks if an object is a Web `ReadableStream`, `WritableStream`, or `TransformStream`.\n   *\n   * This method verifies the type of a given object to determine if it is one of the standard\n   * stream types in the Web Streams API: `ReadableStream`, `WritableStream`, or `TransformStream`.\n   * It employs type-checking strategies that are specific to each stream type.\n   *\n   * The method checks for the specific functions and properties associated with each stream type:\n   * - `ReadableStream`: Identified by the presence of a `getReader` method.\n   * - `WritableStream`: Identified by the presence of a `getWriter` and `abort` methods.\n   * - `TransformStream`: Identified by having both `readable` and `writable` properties.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new ReadableStream();\n   * console.log(Stream.isStream(readableStream)); // Output: true\n   *\n   * const writableStream = new WritableStream();\n   * console.log(Stream.isStream(writableStream)); // Output: true\n   *\n   * const transformStream = new TransformStream();\n   * console.log(Stream.isStream(transformStream)); // Output: true\n   *\n   * const nonStreamObject = {};\n   * console.log(Stream.isStream(nonStreamObject)); // Output: false\n   * ```\n   *\n   * @remarks\n   * - This method does not differentiate between `ReadableStream`, `WritableStream`, and\n   *   `TransformStream`. It checks if the object conforms to any of these types.\n   * - This method is specific to the Web Streams API and may not recognize non-standard or custom\n   *   stream-like objects that do not adhere to the Web Streams API specifications.\n   *\n   * @param obj - The object to be checked for being a Web `ReadableStream`, `WritableStream`, or `TransformStream`.\n   * @returns `true` if the object is a `ReadableStream`, `WritableStream`, or `TransformStream`; otherwise, `false`.\n   */\n  public static isStream(obj: unknown): obj is ReadableStream | WritableStream | TransformStream {\n    return Stream.isReadableStream(obj) || Stream.isWritableStream(obj) || Stream.isTransformStream(obj);\n  }\n\n  /**\n   * Checks if an object is a `TransformStream`.\n   *\n   * This method verifies whether the given object is a `TransformStream` by checking its type and\n   * the presence of `readable` and `writable` properties.\n   *\n   * @example\n   * ```ts\n   * const obj = getSomeObject();\n   * if (Stream.isTransformStream(obj)) {\n   *   // obj is a TransformStream\n   * }\n   * ```\n   *\n   * @param obj - The object to be checked.\n   * @returns `true` if `obj` is a `TransformStream`; otherwise, `false`.\n   */\n  public static isTransformStream(obj: unknown): obj is TransformStream {\n    return (\n      typeof obj === 'object' && obj !== null &&\n      'readable' in obj && typeof obj.readable === 'object' &&\n      'writable' in obj && typeof obj.writable === 'object'\n    );\n  }\n\n  /**\n   * Checks if an object is a `WritableStream`.\n   *\n   * This method determines whether the given object is a `WritableStream` by verifying its type and\n   * the presence of the `getWriter` and `abort` functions.\n   *\n   * @example\n   * ```ts\n   * const obj = getSomeObject();\n   * if (Stream.isWritableStream(obj)) {\n   *   // obj is a WritableStream\n   * }\n   * ```\n   *\n   * @param obj - The object to be checked.\n     * @returns `true` if `obj` is a `TransformStream`; otherwise, `false`.\n     */\n  public static isWritableStream(obj: unknown): obj is WritableStream {\n    return (\n      typeof obj === 'object' && obj !== null &&\n      'getWriter' in obj && typeof obj.getWriter === 'function' &&\n      'abort' in obj && typeof obj.abort === 'function'\n    );\n  }\n}", "import type { Duplex, ReadableStateOptions, Transform, Writable } from 'readable-stream';\n\nimport { Readable } from 'readable-stream';\nimport { Stream } from './stream.js';\nimport { Convert } from './convert.js';\n\nexport { Readable } from 'readable-stream';\n\nexport class NodeStream {\n  /**\n   * Consumes a `Readable` stream and returns its contents as an `ArrayBuffer`.\n   *\n   * This method reads all data from a Node.js `Readable` stream, collects it, and converts it into\n   * an `ArrayBuffer`.\n   *\n   * @example\n   * ```ts\n   * const nodeReadable = getReadableStreamSomehow();\n   * const arrayBuffer = await NodeStream.consumeToArrayBuffer({ readable: nodeReadable });\n   * ```\n   *\n   * @param readable - The Node.js Readable stream whose data will be consumed.\n   * @returns A Promise that resolves to an `ArrayBuffer` containing all the data from the stream.\n   */\n  public static async consumeToArrayBuffer({ readable }: { readable: Readable}): Promise<ArrayBuffer> {\n    const arrayBuffer = await Convert.asyncIterable(readable).toArrayBufferAsync();\n\n    return arrayBuffer;\n  }\n\n  /**\n   * Consumes a `Readable` stream and returns its contents as a `Blob`.\n   *\n   * This method reads all data from a Node.js `Readable` stream, collects it, and converts it into\n   * a `Blob`.\n   *\n   * @example\n   * ```ts\n   * const nodeReadable = getReadableStreamSomehow();\n   * const blob = await NodeStream.consumeToBlob({ readable: nodeReadable });\n   * ```\n   *\n   * @param readableStream - The Node.js `Readable` stream whose data will be consumed.\n   * @returns A Promise that resolves to a `Blob` containing all the data from the stream.\n   */\n  public static async consumeToBlob({ readable }: { readable: Readable }): Promise<Blob> {\n    const blob = await Convert.asyncIterable(readable).toBlobAsync();\n\n    return blob;\n  }\n\n  /**\n   * Consumes a `Readable` stream and returns its contents as a `Uint8Array`.\n   *\n   * This method reads all data from a Node.js `Readable`, collects it, and converts it into a\n   * `Uint8Array`.\n   *\n   * @example\n   * ```ts\n   * const nodeReadable = getReadableStreamSomehow();\n   * const bytes = await NodeStream.consumeToBytes({ readable: nodeReadable });\n   * ```\n   *\n   * @param readableStream - The Node.js `Readable` stream whose data will be consumed.\n   * @returns A Promise that resolves to a `Uint8Array` containing all the data from the stream.\n   */\n  public static async consumeToBytes({ readable }: { readable: Readable }): Promise<Uint8Array> {\n    const bytes = await Convert.asyncIterable(readable).toUint8ArrayAsync();\n\n    return bytes;\n  }\n\n  /**\n   * Consumes a `Readable` stream and parses its contents as JSON.\n   *\n   * This method reads all the data from the stream, converts it to a text string, and then parses\n   * it as JSON, returning the resulting object.\n   *\n   * @example\n   * ```ts\n   * const nodeReadable = getReadableStreamSomehow();\n   * const jsonData = await NodeStream.consumeToJson({ readable: nodeReadable });\n   * ```\n   *\n   * @param readableStream - The Node.js `Readable` stream whose JSON content will be consumed.\n   * @returns A Promise that resolves to the parsed JSON object from the stream's data.\n   */\n  public static async consumeToJson({ readable }: { readable: Readable }): Promise<any> {\n    const object = await Convert.asyncIterable(readable).toObjectAsync();\n\n    return object;\n  }\n\n  /**\n   * Consumes a `Readable` stream and returns its contents as a text string.\n   *\n   * This method reads all the data from the stream, converting it into a single string.\n   *\n   * @example\n   * ```ts\n   * const nodeReadable = getReadableStreamSomehow();\n   * const text = await NodeStream.consumeToText({ readable: nodeReadable });\n   * ```\n   *\n   * @param readableStream - The Node.js `Readable` stream whose text content will be consumed.\n   * @returns A Promise that resolves to a string containing all the data from the stream.\n   */\n  public static async consumeToText({ readable }: { readable: Readable}): Promise<string> {\n    const text = await Convert.asyncIterable(readable).toStringAsync();\n\n    return text;\n  }\n\n  /**\n   * Converts a Web `ReadableStream` to a Node.js `Readable` stream.\n   *\n   * This method takes a Web `ReadableStream` and converts it to a Node.js `Readable` stream.\n   * The conversion is done by reading chunks from the Web `ReadableStream` and pushing them\n   * into the Node.js `Readable` stream.\n   *\n   * @example\n   * ```ts\n   * const webReadableStream = getWebReadableStreamSomehow();\n   * const nodeReadableStream = NodeStream.fromWebReadable({ readableStream: webReadableStream });\n   * ```\n   *\n   * @param readableStream - The Web `ReadableStream` to be converted.\n   * @param readableOptions - Optional `Readable` stream options for the Node.js stream.\n   * @returns The Node.js `Readable` stream.\n   */\n  public static fromWebReadable({ readableStream, readableOptions }: {\n    readableStream: ReadableStream,\n    readableOptions?: ReadableStateOptions\n  }): Readable {\n    if (!Stream.isReadableStream(readableStream)) {\n      throw new TypeError(`NodeStream.fromWebReadable: 'readableStream' is not a Web ReadableStream.`);\n    }\n\n    const reader = readableStream.getReader();\n    let closed = false;\n\n    const nodeReadable = new Readable({\n      ...readableOptions,\n\n      read: function () {\n        reader.read().then(({ done, value }) => {\n          if (done) {\n            this.push(null); // Push null to signify end of stream.\n          } else {\n            if (!this.push(value)) {\n              // When push returns false, we should stop reading until _read is called again.\n              return;\n            }\n          }\n        }).catch((error) => {\n          // If an error occurs while reading, destroy the stream.\n          this.destroy(error);\n        });\n      },\n\n      destroy: function (error, callback) {\n        function done() {\n          callback(error);\n        }\n\n        if (!closed) {\n          reader.cancel(error)\n            .then(done)\n            .catch(done);\n          return;\n        }\n        done();\n      }\n    });\n\n    reader.closed\n      .then(() => {\n        closed = true; // Prevents reader.cancel() from being called in destroy()\n      })\n      .catch((error) => {\n        closed = true; // Prevents reader.cancel() from being called in destroy()\n        nodeReadable.destroy(error);\n      });\n\n    return nodeReadable;\n  }\n\n  /**\n   * Checks if a Node.js stream (`Readable`, `Writable`, `Duplex`, or `Transform`) has been destroyed.\n   *\n   * This method determines whether the provided Node.js stream has been destroyed. A stream\n   * is considered destroyed if its 'destroyed' property is set to true or if its internal state\n   * indicates it has been destroyed.\n   *\n   * @example\n   * ```ts\n   * const stream = getStreamSomehow();\n   * stream.destroy(); // Destroy the stream.\n   * const isDestroyed = NodeStream.isDestroyed({ stream });\n   * console.log(isDestroyed); // Output: true\n   * ```\n   *\n   * @param stream - The Node.js stream to check.\n   * @returns `true` if the stream has been destroyed; otherwise, `false`.\n   */\n  public static isDestroyed({ stream }: { stream: Readable | Writable | Duplex | Transform }): boolean {\n    if (!NodeStream.isStream(stream)) {\n      throw new TypeError(`NodeStream.isDestroyed: 'stream' is not a Node stream.`);\n    }\n\n    const writableState = '_writableState' in stream ? stream._writableState : undefined;\n    const readableState = stream._readableState;\n    const state = writableState || readableState;\n\n    return !!(stream.destroyed || state.destroyed);\n  }\n\n  /**\n   * Checks if a Node.js `Readable` stream is still readable.\n   *\n   * This method checks if a Node.js `Readable` stream is still in a state that allows reading from\n   * it. A stream is considered readable if it has not ended, has not been destroyed, and is not\n   * currently paused.\n   *\n   * @example\n   * ```ts\n   * const readableStream = new Readable();\n   * const isReadable = NodeStream.isReadable({ readable: readableStream });\n   * console.log(isReadable); // Output: true or false\n   * ```\n   *\n   * @param readable - The Node.js `Readable` stream to be checked.\n   * @returns `true` if the stream is still readable; otherwise, `false`.\n   */\n  public static isReadable({ readable }: { readable: Readable }): boolean {\n    // Check if the object is a Node Readable stream.\n    if (!NodeStream.isReadableStream(readable)) {\n      return false;\n    }\n\n    // Check if the stream is still readable.\n    return (\n      readable.readable && // Is the stream readable?\n        (typeof readable._readableState.ended === 'boolean' && !readable._readableState.ended) && // Has the 'end' method been called?\n        (typeof readable._readableState.endEmitted === 'boolean' && !readable._readableState.endEmitted) && // Has the 'end' event been emitted?\n        !readable.destroyed && // Has the 'destroy' method been called?\n        !readable.isPaused() // Is the stream paused?\n    );\n  }\n\n  /**\n   * Checks if an object is a Node.js `Readable` stream.\n   *\n   * This method verifies if the provided object is a Node.js `Readable` stream by checking for\n   * specific properties and methods typical of a `Readable` stream in Node.js.\n   *\n   * @example\n   * ```ts\n   * const obj = getSomeObject();\n   * if (NodeStream.isReadableStream(obj)) {\n   *   // obj is a Node.js Readable stream\n   * }\n   * ```\n   *\n   * @param obj - The object to be checked.\n   * @returns `true` if `obj` is a Node.js `Readable` stream; otherwise, `false`.\n   */\n  static isReadableStream(obj: unknown): obj is Readable {\n    return (\n      typeof obj === 'object' &&\n        obj !== null &&\n        ('pipe' in obj && typeof obj.pipe === 'function') &&\n        ('on' in obj && typeof obj.on === 'function') &&\n        (!('_writableState' in obj) && '_readableState' in obj)\n    );\n  }\n\n  /**\n   * Checks if the provided object is a Node.js stream (`Duplex`, `Readable`, `Writable`, or `Transform`).\n   *\n   * This method checks for the presence of internal properties specific to Node.js streams:\n   * `_readableState` and `_writableState`. These properties are present in Node.js stream\n   * instances, allowing identification of the stream type.\n   *\n   * The `_readableState` property is found in `Readable` and `Duplex` streams (including\n   * `Transform` streams, which are a type of `Duplex` stream), indicating that the stream can be\n   * read from. The `_writableState` property is found in `Writable` and `Duplex` streams,\n   * indicating that the stream can be written to.\n   *\n   * @example\n   * ```ts\n   * const { Readable, Writable, Duplex, Transform } = require('stream');\n   *\n   * const readableStream = new Readable();\n   * console.log(NodeStream.isStream(readableStream)); // Output: true\n   *\n   * const writableStream = new Writable();\n   * console.log(NodeStream.isStream(writableStream)); // Output: true\n   *\n   * const duplexStream = new Duplex();\n   * console.log(NodeStream.isStream(duplexStream)); // Output: true\n   *\n   * const transformStream = new Transform();\n   * console.log(NodeStream.isStream(transformStream)); // Output: true\n   *\n   * const nonStreamObject = {};\n   * console.log(NodeStream.isStream(nonStreamObject)); // Output: false\n   * ```\n   *\n   * @remarks\n   * - This method does not differentiate between the different types of streams (Readable,\n   *   Writable, Duplex, Transform). It simply checks if the object is any kind of Node.js stream.\n   * - While this method can identify standard Node.js streams, it may not recognize custom or\n   *   third-party stream-like objects that do not inherit directly from Node.js's stream classes\n   *   or do not have these internal state properties. This is intentional as many of the methods\n   *   in this library are designed to work with standard Node.js streams.\n   *\n   * @param obj - The object to be checked for being a Node.js stream.\n   * @returns `true` if the object is a Node.js stream (`Duplex`, `Readable`, `Writable`, or `Transform`); otherwise, `false`.\n   */\n  public static isStream(obj: unknown): obj is Duplex | Readable | Writable | Transform  {\n    return (\n      typeof obj === 'object' && obj !== null &&\n      ('_readableState' in obj || '_writableState' in obj)\n    );\n  }\n\n  /**\n   * Converts a Node.js `Readable` stream to a Web `ReadableStream`.\n   *\n   * This method provides a bridge between Node.js streams and the Web Streams API by converting a\n   * Node.js `Readable` stream into a Web `ReadableStream`. It listens for 'data', 'end', and 'error'\n   * events on the Node.js stream and appropriately enqueues data, closes, or errors the Web\n   * `ReadableStream`.\n   *\n   * If the Node.js stream is already destroyed, the method returns an immediately cancelled\n   * Web `ReadableStream`.\n   *\n   * @example\n   * ```ts\n   * const nodeReadable = getNodeReadableStreamSomehow();\n   * const webReadableStream = NodeStream.toWebReadable({ readable: nodeReadable });\n   * ```\n   *\n   * @param readable - The Node.js `Readable` stream to be converted.\n   * @returns A Web `ReadableStream` corresponding to the provided Node.js `Readable` stream.\n   * @throws TypeError if `readable` is not a Node.js `Readable` stream.\n   * @throws Error if the Node.js `Readable` stream is already destroyed.\n   */\n  static toWebReadable({ readable }: { readable: Readable }): ReadableStream {\n    if (!NodeStream.isReadableStream(readable)) {\n      throw new TypeError(`NodeStream.toWebReadable: 'readable' is not a Node Readable stream.`);\n    }\n\n    if (NodeStream.isDestroyed({ stream: readable })) {\n      const readable = new ReadableStream();\n      readable.cancel();\n      return readable;\n    }\n\n    return new ReadableStream({\n      start(controller) {\n        readable.on('data', (chunk) => {\n          controller.enqueue(chunk);\n        });\n\n        readable.on('end', () => {\n          controller.close();\n        });\n\n        readable.on('error', (err) => {\n          controller.error(err);\n        });\n      },\n\n      cancel() {\n        readable.destroy();\n      }\n    });\n  }\n}"],
  "mappings": "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",
  "names": ["TTLCache", "encode", "length", "i", "j", "decode", "encode", "decode", "format", "decode", "encode", "decode", "decode", "decode", "equals", "base", "baseCache", "equals", "base", "decode", "length", "cache", "cid", "import_readable_stream", "readable"]
}
