var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// ! TODO : Make sure I remove `@noble/ciphers` from the Agent package.json once this is moved to the `@web5/crypto` package.
import { getWebcryptoSubtle } from '@noble/ciphers/webcrypto';
import { Convert } from '@web5/common';
/**
 * The `Hkdf` class provides an interface for HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
 * as defined in RFC 5869.
 *
 * Note: The `baseKeyBytes` that will be the input key material for HKDF should be a high-entropy secret
 * value, such as a cryptographic key. It should be kept confidential and not be derived from a
 * low-entropy value, such as a password.
 *
 * @example
 * ```ts
 * const info = new Uint8Array([...]);
 * const derivedKeyBytes = await Hkdf.deriveKeyBytes({
 *   baseKeyBytes: new Uint8Array([...]), // Input keying material
 *   hash: 'SHA-256', // The hash function to use ('SHA-256', 'SHA-384', 'SHA-512')
 *   salt: new Uint8Array([...]), // The salt value
 *   info: new Uint8Array([...]), // Optional application-specific information
 *   length: 256 // The length of the derived key in bits
 * });
 * ```
 */
export class Hkdf {
    /**
     * Derives a key using the HMAC-based Extract-and-Expand Key Derivation Function (HKDF).
     *
     * This method generates a derived key using a hash function from input keying material given as
     * `baseKeyBytes`. The length of the derived key can be specified. Optionally, it can also use a salt
     * and info for the derivation process.
     *
     * HKDF is useful in various cryptographic applications and protocols, especially when
     * there's a need to derive multiple keys from a single source of key material.
     *
     * Note: The `baseKeyBytes` that will be the input key material for HKDF should be a high-entropy
     * secret value, such as a cryptographic key. It should be kept confidential and not be derived
     * from a low-entropy value, such as a password.
     *
     * @example
     * ```ts
     * const info = new Uint8Array([...]);
     * const derivedKeyBytes = await Hkdf.deriveKeyBytes({
     *   baseKeyBytes: new Uint8Array([...]), // Input keying material
     *   hash: 'SHA-256', // The hash function to use ('SHA-256', 'SHA-384', 'SHA-512')
     *   salt: new Uint8Array([...]), // The salt value
     *   info: new Uint8Array([...]), // Optional application-specific information
     *   length: 256 // The length of the derived key in bits
     * });
     * ```
     *
     * @param params - The parameters for key derivation.
     * @returns A Promise that resolves to the derived key as a byte array.
     */
    static deriveKeyBytes({ baseKeyBytes, length, hash, salt, info = new Uint8Array() }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get the Web Crypto API interface.
            const webCrypto = getWebcryptoSubtle();
            // Import the baseKeyBytes into the Web Crypto API to use for the key derivation operation.
            const webCryptoKey = yield webCrypto.importKey('raw', baseKeyBytes, { name: 'HKDF' }, false, ['deriveBits']);
            // Convert the salt and info to Uint8Array if they are provided as strings.
            salt = typeof salt === 'string' ? Convert.string(salt).toUint8Array() : salt;
            info = typeof info === 'string' ? Convert.string(info).toUint8Array() : info;
            // Derive the bytes using the Web Crypto API.
            const derivedKeyBuffer = yield crypto.subtle.deriveBits({ name: 'HKDF', hash, salt, info }, webCryptoKey, length);
            // Convert from ArrayBuffer to Uint8Array.
            const derivedKeyBytes = new Uint8Array(derivedKeyBuffer);
            return derivedKeyBytes;
        });
    }
}
//# sourceMappingURL=hkdf.js.map