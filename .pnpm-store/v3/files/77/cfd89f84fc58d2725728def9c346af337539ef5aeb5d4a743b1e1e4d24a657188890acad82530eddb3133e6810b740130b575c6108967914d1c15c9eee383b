var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BearerIdentity } from './bearer-identity.js';
import { isPortableDid } from './prototyping/dids/utils.js';
import { InMemoryIdentityStore } from './store-identity.js';
export function isPortableIdentity(obj) {
    // Validate that the given value is an object that has the necessary properties of PortableIdentity.
    return !(!obj || typeof obj !== 'object' || obj === null)
        && 'did' in obj
        && 'metadata' in obj
        && isPortableDid(obj.did);
}
export class AgentIdentityApi {
    constructor({ agent, store } = {}) {
        this._agent = agent;
        // If `store` is not given, use an in-memory store by default.
        this._store = store !== null && store !== void 0 ? store : new InMemoryIdentityStore();
    }
    /**
     * Retrieves the `Web5PlatformAgent` execution context.
     *
     * @returns The `Web5PlatformAgent` instance that represents the current execution context.
     * @throws Will throw an error if the `agent` instance property is undefined.
     */
    get agent() {
        if (this._agent === undefined) {
            throw new Error('AgentIdentityApi: Unable to determine agent execution context.');
        }
        return this._agent;
    }
    set agent(agent) {
        this._agent = agent;
    }
    create({ metadata, didMethod = 'dht', didOptions, store, tenant }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Unless an existing `tenant` is specified, a record that includes the DID's URI, document,
            // and metadata will be stored under a new tenant controlled by the newly created DID.
            const bearerDid = yield this.agent.did.create({
                method: didMethod,
                options: didOptions,
                store,
                tenant
            });
            // Create the BearerIdentity object.
            const identity = new BearerIdentity({
                did: bearerDid,
                metadata: Object.assign(Object.assign({}, metadata), { uri: bearerDid.uri, tenant: tenant !== null && tenant !== void 0 ? tenant : bearerDid.uri })
            });
            // Persist the Identity to the store, by default, unless the `store` option is set to false.
            if (store !== null && store !== void 0 ? store : true) {
                yield this._store.set({
                    id: identity.did.uri,
                    data: identity.metadata,
                    agent: this.agent,
                    tenant: identity.metadata.tenant,
                    preventDuplicates: false,
                    useCache: true
                });
            }
            return identity;
        });
    }
    export({ didUri, tenant }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Attempt to retrieve the Identity from the Agent's Identity store.
            const bearerIdentity = yield this.get({ didUri, tenant });
            if (!bearerIdentity) {
                throw new Error(`AgentIdentityApi: Failed to export due to Identity not found: ${didUri}`);
            }
            // If the Identity was found, return the Identity in a portable format, and if supported by the
            // Agent's key manager, the private key material.
            const portableIdentity = yield bearerIdentity.export();
            return portableIdentity;
        });
    }
    get({ didUri, tenant }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Attempt to retrieve the Identity from the Agent's Identity store.
            const storedIdentity = yield this._store.get({ id: didUri, agent: this.agent, tenant, useCache: true });
            // If the Identity is not found in the store, return undefined.
            if (!storedIdentity)
                return undefined;
            // Retrieve the DID from the Agent's DID store using the tenant value from the stored
            // Identity's metadata.
            const storedDid = yield this.agent.did.get({ didUri, tenant: storedIdentity.tenant });
            // If the Identity is present but the DID is not found, throw an error.
            if (!storedDid) {
                throw new Error(`AgentIdentityApi: Identity is present in the store but DID is missing: ${didUri}`);
            }
            // Create the BearerIdentity object.
            const identity = new BearerIdentity({ did: storedDid, metadata: storedIdentity });
            return identity;
        });
    }
    import({ portableIdentity }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Import the PortableDid to the Agent's DID store.
            const storedDid = yield this.agent.did.import({
                portableDid: portableIdentity.portableDid,
                tenant: portableIdentity.metadata.tenant
            });
            // Verify the DID is present in the Agent's DID store.
            if (!storedDid) {
                throw new Error(`AgentIdentityApi: Failed to import Identity: ${portableIdentity.metadata.uri}`);
            }
            // Create the BearerIdentity object.
            const identity = new BearerIdentity({ did: storedDid, metadata: portableIdentity.metadata });
            // Store the Identity metadata in the Agent's Identity store.
            yield this._store.set({
                id: identity.did.uri,
                data: identity.metadata,
                agent: this.agent,
                tenant: identity.metadata.tenant,
                preventDuplicates: true,
                useCache: true
            });
            return identity;
        });
    }
    list({ tenant } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // Retrieve the list of Identities from the Agent's Identity store.
            const storedIdentities = yield this._store.list({ agent: this.agent, tenant });
            const identities = yield Promise.all(storedIdentities.map((metadata) => __awaiter(this, void 0, void 0, function* () {
                return this.get({ didUri: metadata.uri, tenant: metadata.tenant });
            })));
            return identities.filter(identity => typeof identity !== 'undefined');
        });
    }
    manage({ portableIdentity }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Retrieve the DID using the `tenant` stored in the given Identity's metadata.
            const storedDid = yield this.agent.did.get({
                didUri: portableIdentity.metadata.uri,
                tenant: portableIdentity.metadata.tenant
            });
            // Verify the DID is present in the DID store.
            if (!storedDid) {
                throw new Error(`AgentIdentityApi: Failed to manage Identity: ${portableIdentity.metadata.uri}`);
            }
            // Create the BearerIdentity object.
            const identity = new BearerIdentity({ did: storedDid, metadata: portableIdentity.metadata });
            // Store the Identity metadata in the Agent's Identity store.
            yield this._store.set({
                id: identity.did.uri,
                data: identity.metadata,
                agent: this.agent,
                preventDuplicates: true,
                useCache: true
            });
            return identity;
        });
    }
    delete({ didUri, tenant }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Attempt to retrieve the Identity from the Agent's Identity store.
            const storedIdentity = yield this._store.get({ id: didUri, agent: this.agent, tenant, useCache: true });
            if (!storedIdentity) {
                throw new Error(`AgentIdentityApi: Failed to purge due to Identity not found: ${didUri}`);
            }
            // Delete the Identity from the Agent's Identity store.
            yield this._store.delete({ id: didUri, agent: this.agent, tenant });
        });
    }
    /**
     * Returns the connected Identity, if one is available.
     *
     * Accepts optional `connectedDid` parameter to filter the a specific connected identity,
     * if none is provided the first connected identity is returned.
     */
    connectedIdentity({ connectedDid } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const identities = yield this.list();
            if (identities.length < 1) {
                return undefined;
            }
            // If a specific connected DID is provided, return the first identity that matches it.
            // Otherwise, return the first connected identity.
            return connectedDid ?
                identities.find(identity => identity.metadata.connectedDid === connectedDid) :
                identities.find(identity => identity.metadata.connectedDid !== undefined);
        });
    }
}
//# sourceMappingURL=identity-api.js.map