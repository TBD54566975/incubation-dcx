import type { Jwk } from '@web5/crypto';
import { TtlCache } from '@web5/common';
import type { Web5PlatformAgent } from './types/agent.js';
import { ProtocolDefinition } from '@tbd54566975/dwn-sdk-js';
export type DataStoreTenantParams = {
    agent: Web5PlatformAgent;
    tenant?: string;
};
export type DataStoreListParams = DataStoreTenantParams;
export type DataStoreGetParams = DataStoreTenantParams & {
    id: string;
    useCache?: boolean;
};
export type DataStoreSetParams<TStoreObject> = DataStoreTenantParams & {
    id: string;
    data: TStoreObject;
    preventDuplicates?: boolean;
    useCache?: boolean;
};
export type DataStoreDeleteParams = DataStoreTenantParams & {
    id: string;
};
export interface AgentDataStore<TStoreObject> {
    delete(params: DataStoreDeleteParams): Promise<boolean>;
    get(params: DataStoreGetParams): Promise<TStoreObject | undefined>;
    list(params: DataStoreTenantParams): Promise<TStoreObject[]>;
    set(params: DataStoreSetParams<TStoreObject>): Promise<void>;
}
export declare class DwnDataStore<TStoreObject extends Record<string, any> = Jwk> implements AgentDataStore<TStoreObject> {
    protected name: string;
    /**
       * Cache of Store Objects referenced by DWN record ID to Store Objects.
       *
       * Up to 100 entries are retained for 15 minutes.
       */
    protected _cache: TtlCache<string, TStoreObject>;
    /**
     * Index for mappings from Store Identifier to DWN record ID.
     * Since these values don't change, we can use a long TTL.
     *
     * Up to 1,000 entries are retained for 21 days.
     * NOTE: The maximum number for the ttl is 2^31 - 1 milliseconds (24.8 days), setting to 21 days to be safe.
     */
    protected _index: TtlCache<string, string>;
    /**
     * Cache of tenant DIDs that have been initialized with the protocol.
     * This is used to avoid redundant protocol initialization requests.
     *
     * Since these are default protocols and unlikely to change, we can use a long TTL.
     */
    protected _protocolInitializedCache: TtlCache<string, boolean>;
    /**
     * The protocol assigned to this storage instance.
     */
    protected _recordProtocolDefinition: ProtocolDefinition;
    /**
     * Properties to use when writing and querying records with the DWN store.
     */
    protected _recordProperties: {
        dataFormat: string;
    };
    delete({ id, agent, tenant }: DataStoreDeleteParams): Promise<boolean>;
    get({ id, agent, tenant, useCache }: DataStoreGetParams): Promise<TStoreObject | undefined>;
    list({ agent, tenant }: DataStoreListParams): Promise<TStoreObject[]>;
    set({ id, data, tenant, agent, preventDuplicates, useCache }: DataStoreSetParams<TStoreObject>): Promise<void>;
    /**
     * Initialize the relevant protocol for the given tenant.
     * This confirms that the storage protocol is configured, otherwise it will be installed.
     */
    initialize({ tenant, agent }: DataStoreTenantParams): Promise<void>;
    protected getAllRecords(_params: {
        agent: Web5PlatformAgent;
        tenantDid: string;
    }): Promise<TStoreObject[]>;
    private getRecord;
    /**
     * Install the protocol for the given tenant using a `ProtocolsConfigure` message.
     */
    private installProtocol;
    private lookupRecordId;
}
export declare class InMemoryDataStore<TStoreObject extends Record<string, any> = Jwk> implements AgentDataStore<TStoreObject> {
    protected name: string;
    /**
     * A private field that contains the Map used as the in-memory data store.
     */
    private store;
    delete({ id, agent, tenant }: DataStoreDeleteParams): Promise<boolean>;
    get({ id, agent, tenant }: DataStoreGetParams): Promise<TStoreObject | undefined>;
    list({ agent, tenant }: DataStoreListParams): Promise<TStoreObject[]>;
    set({ id, data, tenant, agent, preventDuplicates }: DataStoreSetParams<TStoreObject>): Promise<void>;
}
//# sourceMappingURL=store-data.d.ts.map