{"version":3,"file":"index.esm.js","sources":["../lib/intrinsicclass.ts","../lib/slots.ts","../lib/regex.ts","../lib/ecmascript.ts","../lib/intl.ts","../lib/instant.ts","../lib/calendar.ts","../lib/plaindate.ts","../lib/plaindatetime.ts","../lib/duration.ts","../lib/plainmonthday.ts","../lib/now.ts","../lib/plaintime.ts","../lib/timezone.ts","../lib/plainyearmonth.ts","../lib/zoneddatetime.ts","../lib/legacydate.ts","../lib/index.ts"],"sourcesContent":["import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\n\nimport { DEBUG } from './debug';\n\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\n\ntype TemporalIntrinsics = Omit<typeof Temporal, 'Now' | 'Instant' | 'ZonedDateTime'> & {\n  Instant: OmitConstructor<Temporal.Instant> &\n    (new (epochNanoseconds: JSBI) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\n  ZonedDateTime: OmitConstructor<Temporal.ZonedDateTime> &\n    (new (\n      epochNanoseconds: JSBI,\n      timeZone: string | Temporal.TimeZoneProtocol,\n      calendar?: string | Temporal.CalendarProtocol\n    ) => Temporal.ZonedDateTime) & {\n      prototype: typeof Temporal.ZonedDateTime.prototype;\n      from: typeof Temporal.ZonedDateTime.from;\n      compare: typeof Temporal.ZonedDateTime.compare;\n    };\n};\ntype TemporalIntrinsicRegistrations = {\n  [key in keyof TemporalIntrinsics as `Temporal.${key}`]: TemporalIntrinsics[key];\n};\ntype TemporalIntrinsicPrototypeRegistrations = {\n  [key in keyof TemporalIntrinsics as `Temporal.${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\n};\ntype TemporalIntrinsicRegisteredKeys = {\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\n};\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\n};\n\ntype CalendarPrototypeKeys = keyof Omit<Temporal.Calendar, typeof Symbol.toStringTag>;\ntype TemporalCalendarIntrinsicRegistrations = {\n  [key in CalendarPrototypeKeys as `Temporal.Calendar.prototype.${key}`]: Temporal.Calendar[key];\n} & {\n  'Temporal.Calendar.from': typeof Temporal.Calendar.from;\n};\ntype TemporalCalendarIntrinsicRegisteredKeys = {\n  [key in keyof TemporalCalendarIntrinsicRegistrations as `%${key}%`]: TemporalCalendarIntrinsicRegistrations[key];\n};\n\ntype TimeZonePrototypeKeys = 'getOffsetNanosecondsFor' | 'getPossibleInstantsFor';\ntype TemporalTimeZoneIntrinsicRegistrations = {\n  [key in TimeZonePrototypeKeys as `Temporal.TimeZone.prototype.${key}`]: Temporal.TimeZone[key];\n} & {\n  'Temporal.TimeZone.from': typeof Temporal.TimeZone.from;\n};\ntype TemporalTimeZoneIntrinsicRegisteredKeys = {\n  [key in keyof TemporalTimeZoneIntrinsicRegistrations as `%${key}%`]: TemporalTimeZoneIntrinsicRegistrations[key];\n};\n\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\n  TemporalIntrinsicPrototypeRegisteredKeys &\n  TemporalTimeZoneIntrinsicRegisteredKeys &\n  TemporalCalendarIntrinsicRegisteredKeys;\n\ntype customFormatFunction<T> = (\n  this: T,\n  depth: number,\n  options: { stylize: (value: unknown, type: 'number' | 'special') => string }\n) => string;\nconst customUtilInspectFormatters: Partial<{\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\n    InstanceType<TemporalIntrinsicRegistrations[key]>\n  >;\n}> = {\n  ['Temporal.Duration'](depth, options) {\n    const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n    if (depth < 1) return descr;\n    const entries = [];\n    for (const prop of [\n      'years',\n      'months',\n      'weeks',\n      'days',\n      'hours',\n      'minutes',\n      'seconds',\n      'milliseconds',\n      'microseconds',\n      'nanoseconds'\n    ] as const) {\n      if (this[prop] !== 0) entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n    }\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n  }\n};\n\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\n  return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\n\nexport function MakeIntrinsicClass(\n  Class: TemporalIntrinsicRegistrations[typeof name],\n  name: keyof TemporalIntrinsicRegistrations\n) {\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  if (DEBUG) {\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  for (const prop of Object.getOwnPropertyNames(Class)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class, prop, desc);\n  }\n  for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class.prototype, prop, desc);\n  }\n\n  DefineIntrinsic(name, Class);\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\n\ntype IntrinsicDefinitionKeys =\n  | keyof TemporalIntrinsicRegistrations\n  | keyof TemporalIntrinsicPrototypeRegistrations\n  | keyof TemporalCalendarIntrinsicRegistrations\n  | keyof TemporalTimeZoneIntrinsicRegistrations;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalCalendarIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalCalendarIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalTimeZoneIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalTimeZoneIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\n  INTRINSICS[key] = value;\n}\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): typeof INTRINSICS[KeyT] {\n  return INTRINSICS[intrinsic];\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { BuiltinCalendarId, AnyTemporalType, CalendarSlot, TimeZoneSlot } from './internaltypes';\n\n// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n\n// TimeZone\nexport const TIMEZONE_ID = 'slot-timezone-identifier';\n\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_YEAR = 'slot-year';\nexport const ISO_MONTH = 'slot-month';\nexport const ISO_DAY = 'slot-day';\nexport const ISO_HOUR = 'slot-hour';\nexport const ISO_MINUTE = 'slot-minute';\nexport const ISO_SECOND = 'slot-second';\nexport const ISO_MILLISECOND = 'slot-millisecond';\nexport const ISO_MICROSECOND = 'slot-microsecond';\nexport const ISO_NANOSECOND = 'slot-nanosecond';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n\n// ZonedDateTime\nexport const INSTANT = 'slot-cached-instant';\nexport const TIME_ZONE = 'slot-time-zone';\n\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n\n// Calendar\nexport const CALENDAR_ID = 'slot-calendar-identifier';\n\ninterface SlotInfo<ValueType, UsedByType extends AnyTemporalType> {\n  value: ValueType;\n  usedBy: UsedByType;\n}\n\ninterface SlotInfoRecord {\n  [k: string]: SlotInfo<unknown, AnyTemporalType>;\n}\n\ninterface Slots extends SlotInfoRecord {\n  // Instant\n  [EPOCHNANOSECONDS]: SlotInfo<JSBI, Temporal.Instant | Temporal.ZonedDateTime>; // number? JSBI?\n\n  // TimeZone\n  [TIMEZONE_ID]: SlotInfo<string, Temporal.TimeZone>;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_YEAR]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MONTH]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_DAY]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_HOUR]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MINUTE]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_SECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MILLISECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MICROSECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_NANOSECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [CALENDAR]: SlotInfo<CalendarSlot, TypesWithCalendarUnits>;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\n\n  // ZonedDateTime\n  [INSTANT]: SlotInfo<Temporal.Instant, Temporal.ZonedDateTime>;\n  [TIME_ZONE]: SlotInfo<TimeZoneSlot, Temporal.ZonedDateTime>;\n\n  // Duration\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\n\n  // Calendar\n  [CALENDAR_ID]: SlotInfo<BuiltinCalendarId, Temporal.Calendar>;\n}\n\ntype TypesWithCalendarUnits =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime;\n\ninterface SlotsToTypes {\n  // Instant\n  [EPOCHNANOSECONDS]: Temporal.Instant;\n\n  // TimeZone\n  [TIMEZONE_ID]: Temporal.TimeZone;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_YEAR]: TypesWithCalendarUnits;\n  [ISO_MONTH]: TypesWithCalendarUnits;\n  [ISO_DAY]: TypesWithCalendarUnits;\n  [ISO_HOUR]: TypesWithCalendarUnits;\n  [ISO_MINUTE]: TypesWithCalendarUnits;\n  [ISO_SECOND]: TypesWithCalendarUnits;\n  [ISO_MILLISECOND]: TypesWithCalendarUnits;\n  [ISO_MICROSECOND]: TypesWithCalendarUnits;\n  [ISO_NANOSECOND]: TypesWithCalendarUnits;\n  [CALENDAR]: TypesWithCalendarUnits;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: Temporal.PlainDate;\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\n\n  // ZonedDateTime\n  [INSTANT]: Temporal.ZonedDateTime;\n  [TIME_ZONE]: Temporal.ZonedDateTime;\n\n  // Duration\n  [YEARS]: Temporal.Duration;\n  [MONTHS]: Temporal.Duration;\n  [WEEKS]: Temporal.Duration;\n  [DAYS]: Temporal.Duration;\n  [HOURS]: Temporal.Duration;\n  [MINUTES]: Temporal.Duration;\n  [SECONDS]: Temporal.Duration;\n  [MILLISECONDS]: Temporal.Duration;\n  [MICROSECONDS]: Temporal.Duration;\n  [NANOSECONDS]: Temporal.Duration;\n\n  // Calendar\n  [CALENDAR_ID]: Temporal.Calendar;\n}\n\ntype SlotKey = keyof SlotsToTypes;\n\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\n\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\n  return globalSlots.get(container);\n}\n\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\n\n// expose GetSlots to avoid dual package hazards\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\n\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\n\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\n  globalSlots.set(container, Object.create(null));\n}\n\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\n\n// expose CreateSlots to avoid dual package hazards\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\n\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\n\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\n// guard that takes a variable number of parameters?\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey,\n  ID9 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8,\n  id9: ID9\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\n  if (!container || 'object' !== typeof container) return false;\n  const myslots = GetSlots(container as AnyTemporalType);\n  return !!myslots && ids.every((id) => id in myslots);\n}\nexport function GetSlot<KeyT extends keyof Slots>(\n  container: Slots[typeof id]['usedBy'],\n  id: KeyT\n): Slots[KeyT]['value'] {\n  const value = GetSlots(container)?.[id];\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\n  return value;\n}\nexport function SetSlot<KeyT extends SlotKey>(\n  container: Slots[KeyT]['usedBy'],\n  id: KeyT,\n  value: Slots[KeyT]['value']\n): void {\n  const slots = GetSlots(container);\n\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\n\n  const existingSlot = slots[id];\n\n  if (existingSlot) throw new TypeError(`${id} already has set`);\n\n  slots[id] = value;\n}\n","const tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nexport const timeZoneID = new RegExp(\n  '(?:' +\n    [\n      `(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*`,\n      'Etc/GMT(?:0|[-+]\\\\d{1,2})',\n      'GMT[-+]?0',\n      'EST5EDT',\n      'CST6CDT',\n      'MST7MDT',\n      'PST8PDT',\n      offsetNoCapture.source\n    ].join('|') +\n    ')'\n);\n\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\n);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\n\nexport const zoneddatetime = new RegExp(\n  [\n    `^${datesplit.source}`,\n    `(?:(?:T|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join(''),\n  'i'\n);\n\nexport const time = new RegExp(\n  [\n    `^T?${timesplit.source}`,\n    `(?:${offsetpart.source})?`,\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join(''),\n  'i'\n);\n\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\n// annotations are still allowed, and will throw if the calendar annotation is\n// not ISO.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\n// UTC offsets are not allowed, because they are not allowed with any date-only\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\nexport const yearmonth = new RegExp(\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\nexport const monthday = new RegExp(\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\n\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\n\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n","const ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nconst ReflectApply = Reflect.apply;\nconst ReflectOwnKeys = Reflect.ownKeys;\n\nimport { DEBUG } from './debug';\nimport JSBI from 'jsbi';\n\nimport type { Temporal } from '..';\nimport type {\n  AnyTemporalLikeType,\n  UnitSmallerThanOrEqualTo,\n  CalendarProtocolParams,\n  TimeZoneProtocolParams,\n  InstantParams,\n  PlainMonthDayParams,\n  ZonedDateTimeParams,\n  CalendarParams,\n  TimeZoneParams,\n  PlainDateParams,\n  PlainTimeParams,\n  DurationParams,\n  PlainDateTimeParams,\n  PlainYearMonthParams,\n  PrimitiveFieldsOf,\n  BuiltinCalendarId,\n  Keys,\n  AnyTemporalKey,\n  CalendarSlot,\n  TimeZoneSlot\n} from './internaltypes';\nimport { GetIntrinsic } from './intrinsicclass';\nimport {\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot,\n  EPOCHNANOSECONDS,\n  TIMEZONE_ID,\n  CALENDAR_ID,\n  INSTANT,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  DATE_BRAND,\n  YEAR_MONTH_BRAND,\n  MONTH_DAY_BRAND,\n  TIME_ZONE,\n  CALENDAR,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS\n} from './slots';\n\nexport const ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst SIXTY = JSBI.BigInt(60);\nconst TWENTY_FOUR = JSBI.BigInt(24);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst NEGATIVE_ONE = JSBI.BigInt(-1);\nconst HOUR_SECONDS = 3600;\nexport const HOUR_NANOS = JSBI.multiply(JSBI.BigInt(HOUR_SECONDS), BILLION);\nconst MINUTE_NANOS = JSBI.multiply(SIXTY, BILLION);\nconst DAY_NANOS = JSBI.multiply(HOUR_NANOS, TWENTY_FOUR);\nconst NS_MIN = JSBI.multiply(JSBI.BigInt(-86400), JSBI.BigInt(1e17));\nconst NS_MAX = JSBI.multiply(JSBI.BigInt(86400), JSBI.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = JSBI.multiply(JSBI.BigInt(-388152), JSBI.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(2 * 7));\n\nconst BUILTIN_CALENDAR_IDS = [\n  'iso8601',\n  'hebrew',\n  'islamic',\n  'islamic-umalqura',\n  'islamic-tbla',\n  'islamic-civil',\n  'islamic-rgsa',\n  'islamicc',\n  'persian',\n  'ethiopic',\n  'ethioaa',\n  'coptic',\n  'chinese',\n  'dangi',\n  'roc',\n  'indian',\n  'buddhist',\n  'japanese',\n  'gregory'\n];\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\n/**\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\n * the type parameter. This should only be used to help TS understand when variables change types,\n * but TS can't or won't infer this automatically. They should be used sparingly, because\n * if used incorrectly can lead to difficult-to-diagnose problems.\n * */\nexport function uncheckedAssertNarrowedType<T = unknown>(\n  arg: unknown,\n  justification: string\n): asserts arg is T extends typeof arg ? T : never {}\n/* eslint-enable */\n\ntype ArrayElement<ArrayType> = ArrayType extends readonly (infer ElementType)[] ? ElementType : never;\ntype ArrayWithNewKeys<T, Keys> = Array<ArrayElement<T> | Keys>;\n\n/**\n * In debug builds, this function verifies that the given argument \"exists\" (is not\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\n * @param arg\n */\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\n  if (DEBUG) {\n    if (arg != null) {\n      throw new Error('Expected arg to be set.');\n    }\n  }\n}\n\nfunction isZero(value: JSBI): boolean {\n  return JSBI.equal(value, ZERO);\n}\n\ntype Stringless<T> = Exclude<T, string>;\n\nfunction GetMethod<T extends { [s in M]?: (...args: any[]) => unknown }, M extends string & keyof T>(\n  obj: T,\n  methodName: M\n): T[M];\nfunction GetMethod<\n  T extends string | { [s in M]?: (...args: any[]) => unknown },\n  M extends string & keyof Stringless<T>\n>(obj: T, methodName: M): Stringless<T>[M] | undefined;\nfunction GetMethod<\n  T extends string | { [s in M]?: undefined | ((...args: any[]) => unknown) },\n  M extends string & keyof T\n>(obj: T, methodName: M): T[M] | undefined {\n  const result = obj[methodName];\n  if (result === undefined) return undefined;\n  if (DEBUG) {\n    if (typeof result !== 'function') throw new TypeError(`'${methodName}' must be a function`);\n  }\n  return result;\n}\n\nexport function Call<T, A extends readonly any[], R>(\n  target: (this: T, ...args: A) => R,\n  thisArgument: T,\n  argumentsList: Readonly<A>\n): R {\n  const args = arguments.length > 2 ? argumentsList : [];\n  if (DEBUG) {\n    if (!Array.isArray(argumentsList)) {\n      throw new TypeError('Assertion failed: optional `argumentsList`, if provided, must be an array');\n    }\n  }\n  return ReflectApply(target, thisArgument, args);\n}\n\n// For unknown values, this narrows the result to a Record. But for union types\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\n// leaving the object type(s) unchanged.\nexport function IsObject<T>(\n  value: T\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\n\nexport function ToNumber(value: unknown): number {\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\n  // we'll leave ToNumber as-is.\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\n  return NumberCtor(value);\n}\n\nfunction ToIntegerOrInfinity(value: unknown) {\n  const number = ToNumber(value);\n  if (NumberIsNaN(number) || number === 0) {\n    return 0;\n  }\n  if (!NumberIsFinite(number)) {\n    return number;\n  }\n  const integer = MathFloor(MathAbs(number));\n  if (integer === 0) {\n    return 0;\n  }\n  return MathSign(number) * integer;\n}\n\nfunction IsIntegralNumber(argument: unknown) {\n  if (typeof argument !== 'number' || NumberIsNaN(argument) || !NumberIsFinite(argument)) {\n    return false;\n  }\n  const absValue = MathAbs(argument);\n  return MathFloor(absValue) === absValue;\n}\n\nexport function ToString(value: unknown): string {\n  if (typeof value === 'symbol') {\n    throw new TypeError('Cannot convert a Symbol value to a String');\n  }\n  return StringCtor(value);\n}\n\nexport function ToIntegerWithTruncation(value: unknown): number {\n  const number = ToNumber(value);\n  if (number === 0) return 0;\n  if (NumberIsNaN(number) || !NumberIsFinite(number)) {\n    throw new RangeError('invalid number value');\n  }\n  const integer = MathTrunc(number);\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return integer;\n}\n\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\n  const integer = ToIntegerWithTruncation(valueParam);\n  if (integer <= 0) {\n    if (property !== undefined) {\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\n    }\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\n  }\n  return integer;\n}\n\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\n  const number = ToNumber(valueParam);\n  if (!NumberIsFinite(number)) throw new RangeError('infinity is out of range');\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return number;\n}\n\nfunction divmod(x: JSBI, y: JSBI): { quotient: JSBI; remainder: JSBI } {\n  const quotient = JSBI.divide(x, y);\n  const remainder = JSBI.remainder(x, y);\n  return { quotient, remainder };\n}\n\nfunction isNegativeJSBI(value: JSBI): boolean {\n  return JSBI.lessThan(value, ZERO);\n}\n\nfunction signJSBI(value: JSBI): 1 | 0 | -1 {\n  if (isZero(value)) return 0;\n  if (isNegativeJSBI(value)) return -1;\n  return 1;\n}\nfunction abs(x: JSBI): JSBI {\n  if (JSBI.lessThan(x, ZERO)) return JSBI.multiply(x, NEGATIVE_ONE);\n  return x;\n}\n\ntype BuiltinCastFunction = (v: unknown) => string | number;\nconst BUILTIN_CASTS = new Map<AnyTemporalKey, BuiltinCastFunction>([\n  ['year', ToIntegerWithTruncation],\n  ['month', ToPositiveIntegerWithTruncation],\n  ['monthCode', ToString],\n  ['day', ToPositiveIntegerWithTruncation],\n  ['hour', ToIntegerWithTruncation],\n  ['minute', ToIntegerWithTruncation],\n  ['second', ToIntegerWithTruncation],\n  ['millisecond', ToIntegerWithTruncation],\n  ['microsecond', ToIntegerWithTruncation],\n  ['nanosecond', ToIntegerWithTruncation],\n  ['years', ToIntegerIfIntegral],\n  ['months', ToIntegerIfIntegral],\n  ['weeks', ToIntegerIfIntegral],\n  ['days', ToIntegerIfIntegral],\n  ['hours', ToIntegerIfIntegral],\n  ['minutes', ToIntegerIfIntegral],\n  ['seconds', ToIntegerIfIntegral],\n  ['milliseconds', ToIntegerIfIntegral],\n  ['microseconds', ToIntegerIfIntegral],\n  ['nanoseconds', ToIntegerIfIntegral],\n  ['era', ToString],\n  ['eraYear', ToIntegerOrInfinity],\n  ['offset', ToString]\n]);\n\nconst BUILTIN_DEFAULTS = new Map([\n  ['hour', 0],\n  ['minute', 0],\n  ['second', 0],\n  ['millisecond', 0],\n  ['microsecond', 0],\n  ['nanosecond', 0]\n]);\n\n// each item is [plural, singular, category]\nconst SINGULAR_PLURAL_UNITS = [\n  ['years', 'year', 'date'],\n  ['months', 'month', 'date'],\n  ['weeks', 'week', 'date'],\n  ['days', 'day', 'date'],\n  ['hours', 'hour', 'time'],\n  ['minutes', 'minute', 'time'],\n  ['seconds', 'second', 'time'],\n  ['milliseconds', 'millisecond', 'time'],\n  ['microseconds', 'microsecond', 'time'],\n  ['nanoseconds', 'nanosecond', 'time']\n] as const;\nconst SINGULAR_FOR = new Map(SINGULAR_PLURAL_UNITS.map((e) => [e[0], e[1]] as const));\nconst PLURAL_FOR = new Map(SINGULAR_PLURAL_UNITS.map(([p, s]) => [s, p]));\nconst UNITS_DESCENDING = SINGULAR_PLURAL_UNITS.map(([, s]) => s);\n\nconst DURATION_FIELDS = Array.from(SINGULAR_FOR.keys()).sort();\n\nimport * as PARSE from './regex';\n\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\n\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\n  let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n  if (instance === undefined) {\n    instance = new IntlDateTimeFormat('en-us', {\n      timeZone: StringCtor(timeZoneIdentifier),\n      hour12: false,\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n  }\n  return instance;\n}\n\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : object {\n  if (typeof value === 'undefined' || value === null) {\n    throw new TypeError(`Expected object not ${value}`);\n  }\n  return Object(value);\n}\n\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\nexport function CopyDataProperties<K extends string | symbol, T extends Record<K, unknown>>(\n  target: T,\n  source: T | undefined,\n  excludedKeys: K[],\n  excludedValues?: unknown[]\n) {\n  if (typeof source === 'undefined' || source === null) return;\n\n  const keys = ReflectOwnKeys(source) as (keyof T)[];\n  for (const nextKey of keys) {\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\n      const propValue = source[nextKey];\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\n\n      target[nextKey] = propValue;\n    }\n  }\n}\n\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\n\nexport function IsTemporalTimeZone(item: unknown): item is Temporal.TimeZone {\n  return HasSlot(item, TIMEZONE_ID);\n}\nexport function IsTemporalCalendar(item: unknown): item is Temporal.Calendar {\n  return HasSlot(item, CALENDAR_ID);\n}\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\n  return HasSlot(item, DATE_BRAND);\n}\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\n  return (\n    HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n    !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY)\n  );\n}\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\n  return HasSlot(\n    item,\n    ISO_YEAR,\n    ISO_MONTH,\n    ISO_DAY,\n    ISO_HOUR,\n    ISO_MINUTE,\n    ISO_SECOND,\n    ISO_MILLISECOND,\n    ISO_MICROSECOND,\n    ISO_NANOSECOND\n  );\n}\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\n  return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\n  return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n    throw new TypeError('with() does not support a calendar or timeZone property');\n  }\n  if (IsTemporalTime(item)) {\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\n  }\n  if ((item as { calendar: unknown }).calendar !== undefined) {\n    throw new TypeError('with() does not support a calendar property');\n  }\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\n    throw new TypeError('with() does not support a timeZone property');\n  }\n}\nfunction ParseTemporalTimeZone(stringIdent: string) {\n  const { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n  if (ianaName) return GetCanonicalTimeZoneIdentifier(ianaName);\n  if (z) return 'UTC';\n  // if !ianaName && !z then offset must be present\n  assertExists(offset);\n  const offsetNs = ParseTimeZoneOffsetString(offset);\n  return FormatTimeZoneOffsetString(offsetNs);\n}\n\nfunction MaybeFormatCalendarAnnotation(\n  calendar: CalendarSlot,\n  showCalendar: Temporal.ShowCalendarOption['calendarName']\n): string {\n  if (showCalendar === 'never') return '';\n  return FormatCalendarAnnotation(ToTemporalCalendarIdentifier(calendar), showCalendar);\n}\n\nfunction FormatCalendarAnnotation(id: string, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\n  if (showCalendar === 'never') return '';\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\n  const flag = showCalendar === 'critical' ? '!' : '';\n  return `[${flag}u-ca=${id}]`;\n}\n\nfunction ParseISODateTime(isoString: string) {\n  // ZDT is the superset of fields for every other Temporal type\n  const match = PARSE.zoneddatetime.exec(isoString);\n  if (!match) throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  let yearString = match[1];\n  if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n  if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  const year = ToIntegerOrInfinity(yearString);\n  const month = ToIntegerOrInfinity(match[2] || match[4]);\n  const day = ToIntegerOrInfinity(match[3] || match[5]);\n  const hour = ToIntegerOrInfinity(match[6]);\n  const hasTime = match[6] !== undefined;\n  const minute = ToIntegerOrInfinity(match[7] || match[10]);\n  let second = ToIntegerOrInfinity(match[8] || match[11]);\n  if (second === 60) second = 59;\n  const fraction = (match[9] || match[12]) + '000000000';\n  const millisecond = ToIntegerOrInfinity(fraction.slice(0, 3));\n  const microsecond = ToIntegerOrInfinity(fraction.slice(3, 6));\n  const nanosecond = ToIntegerOrInfinity(fraction.slice(6, 9));\n  let offset;\n  let z = false;\n  if (match[13]) {\n    offset = undefined;\n    z = true;\n  } else if (match[14] && match[15]) {\n    const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n    const offsetHours = match[15] || '00';\n    const offsetMinutes = match[16] || '00';\n    const offsetSeconds = match[17] || '00';\n    let offsetFraction = match[18] || '0';\n    offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n    if (+offsetFraction) {\n      while (offsetFraction.endsWith('0')) offsetFraction = offsetFraction.slice(0, -1);\n      offset += `:${offsetSeconds}.${offsetFraction}`;\n    } else if (+offsetSeconds) {\n      offset += `:${offsetSeconds}`;\n    }\n    if (offset === '-00:00') offset = '+00:00';\n  }\n  const ianaName = match[19];\n  const annotations = match[20];\n  let calendar;\n  for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n    if (key === 'u-ca') {\n      if (calendar === undefined) calendar = value;\n    } else if (critical === '!') {\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n    }\n  }\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  return {\n    year,\n    month,\n    day,\n    hasTime,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    ianaName,\n    offset,\n    z,\n    calendar\n  };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstantString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.ianaName) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateTimeString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeString(isoString: string) {\n  const match = PARSE.time.exec(isoString);\n  let hour, minute, second, millisecond, microsecond, nanosecond, annotations;\n  if (match) {\n    hour = ToIntegerOrInfinity(match[1]);\n    minute = ToIntegerOrInfinity(match[2] || match[5]);\n    second = ToIntegerOrInfinity(match[3] || match[6]);\n    if (second === 60) second = 59;\n    const fraction = (match[4] || match[7]) + '000000000';\n    millisecond = ToIntegerOrInfinity(fraction.slice(0, 3));\n    microsecond = ToIntegerOrInfinity(fraction.slice(3, 6));\n    nanosecond = ToIntegerOrInfinity(fraction.slice(6, 9));\n    annotations = match[14];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key !== 'u-ca' && critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\n  } else {\n    let z, hasTime;\n    ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, z } = ParseISODateTime(isoString));\n    if (!hasTime) throw new RangeError(`time is missing in string: ${isoString}`);\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\n  }\n  // if it's a date-time string, OK\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n  }\n  try {\n    const { month, day } = ParseTemporalMonthDayString(isoString);\n    RejectISODate(1972, month, day);\n  } catch {\n    try {\n      const { year, month } = ParseTemporalYearMonthString(isoString);\n      RejectISODate(year, month, 1);\n    } catch {\n      return { hour, minute, second, millisecond, microsecond, nanosecond };\n    }\n  }\n  throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalYearMonthString(isoString: string) {\n  const match = PARSE.yearmonth.exec(isoString);\n  let year, month, calendar, referenceISODay;\n  if (match) {\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    year = ToIntegerOrInfinity(yearString);\n    month = ToIntegerOrInfinity(match[2]);\n    const annotations = match[3];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key === 'u-ca') {\n        if (calendar === undefined) calendar = value;\n      } else if (critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\n  }\n  return { year, month, calendar, referenceISODay };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalMonthDayString(isoString: string) {\n  const match = PARSE.monthday.exec(isoString);\n  let month, day, calendar, referenceISOYear;\n  if (match) {\n    month = ToIntegerOrInfinity(match[1]);\n    day = ToIntegerOrInfinity(match[2]);\n    const annotations = match[3];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key === 'u-ca') {\n        if (calendar === undefined) calendar = value;\n      } else if (critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\n  }\n  return { month, day, calendar, referenceISOYear };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeZoneString(stringIdent: string): Partial<{\n  ianaName: string | undefined;\n  offset: string | undefined;\n  z: boolean | undefined;\n}> {\n  const bareID = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\n  if (bareID.test(stringIdent)) return { ianaName: stringIdent };\n  try {\n    // Try parsing ISO string instead\n    const result = ParseISODateTime(stringIdent);\n    if (result.z || result.offset || result.ianaName) {\n      return result;\n    }\n  } catch {\n    // fall through\n  }\n  throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDurationString(isoString: string) {\n  const match = PARSE.duration.exec(isoString);\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\n  if (match.slice(2).every((element) => element === undefined)) {\n    throw new RangeError(`invalid duration: ${isoString}`);\n  }\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\n  const fHours = match[7];\n  const minutesStr = match[8];\n  const fMinutes = match[9];\n  const secondsStr = match[10];\n  const fSeconds = match[11];\n  let minutes = 0;\n  let seconds = 0;\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\n  let excessNanoseconds = 0;\n\n  if (fHours !== undefined) {\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\n      throw new RangeError('only the smallest unit can be fractional');\n    }\n    excessNanoseconds = ToIntegerOrInfinity((fHours + '000000000').slice(0, 9)) * 3600 * sign;\n  } else {\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\n    if (fMinutes !== undefined) {\n      if (secondsStr ?? fSeconds ?? false) {\n        throw new RangeError('only the smallest unit can be fractional');\n      }\n      excessNanoseconds = ToIntegerOrInfinity((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\n    } else {\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\n      if (fSeconds !== undefined) {\n        excessNanoseconds = ToIntegerOrInfinity((fSeconds + '000000000').slice(0, 9)) * sign;\n      }\n    }\n  }\n\n  const nanoseconds = excessNanoseconds % 1000;\n  const microseconds = MathTrunc(excessNanoseconds / 1000) % 1000;\n  const milliseconds = MathTrunc(excessNanoseconds / 1e6) % 1000;\n  seconds += MathTrunc(excessNanoseconds / 1e9) % 60;\n  minutes += MathTrunc(excessNanoseconds / 6e10);\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstant(isoString: string) {\n  let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } =\n    ParseTemporalInstantString(isoString);\n\n  if (!z && !offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  // At least one of z or offset is defined, but TS doesn't seem to understand\n  // that we only use offset if z is not defined (and thus offset must be defined).\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-type-assertion\n  const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset!);\n  ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond - offsetNs\n  ));\n\n  const epochNs = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n  return epochNs;\n}\n\nexport function RegulateISODate(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, day);\n      break;\n    case 'constrain':\n      ({ year, month, day } = ConstrainISODate(year, month, day));\n      break;\n  }\n  return { year, month, day };\n}\n\nexport function RegulateTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  switch (overflow) {\n    case 'reject':\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n      break;\n    case 'constrain':\n      ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n      ));\n      break;\n  }\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RegulateISOYearMonth(\n  yearParam: number,\n  monthParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  const referenceISODay = 1;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, referenceISODay);\n      break;\n    case 'constrain':\n      ({ year, month } = ConstrainISODate(year, month));\n      break;\n  }\n  return { year, month };\n}\n\nfunction ToTemporalDurationRecord(item: Temporal.DurationLike | string) {\n  if (!IsObject(item)) {\n    return ParseTemporalDurationString(ToString(item));\n  }\n  if (IsTemporalDuration(item)) {\n    return {\n      years: GetSlot(item, YEARS),\n      months: GetSlot(item, MONTHS),\n      weeks: GetSlot(item, WEEKS),\n      days: GetSlot(item, DAYS),\n      hours: GetSlot(item, HOURS),\n      minutes: GetSlot(item, MINUTES),\n      seconds: GetSlot(item, SECONDS),\n      milliseconds: GetSlot(item, MILLISECONDS),\n      microseconds: GetSlot(item, MICROSECONDS),\n      nanoseconds: GetSlot(item, NANOSECONDS)\n    };\n  }\n  const result = {\n    years: 0,\n    months: 0,\n    weeks: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n    microseconds: 0,\n    nanoseconds: 0\n  };\n  let partial = ToTemporalPartialDurationRecord(item);\n  for (const property of DURATION_FIELDS) {\n    const value = partial[property];\n    if (value !== undefined) {\n      result[property] = value;\n    }\n  }\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = result;\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\n  if (!IsObject(temporalDurationLike)) {\n    throw new TypeError('invalid duration-like');\n  }\n  const result: Record<typeof DURATION_FIELDS[number], number | undefined> = {\n    years: undefined,\n    months: undefined,\n    weeks: undefined,\n    days: undefined,\n    hours: undefined,\n    minutes: undefined,\n    seconds: undefined,\n    milliseconds: undefined,\n    microseconds: undefined,\n    nanoseconds: undefined\n  };\n  let any = false;\n  for (const property of DURATION_FIELDS) {\n    const value = temporalDurationLike[property];\n    if (value !== undefined) {\n      any = true;\n      result[property] = ToIntegerIfIntegral(value);\n    }\n  }\n  if (!any) {\n    throw new TypeError('invalid duration-like');\n  }\n  return result;\n}\n\nfunction ToLimitedTemporalDuration(\n  item: Temporal.DurationLike | string,\n  disallowedProperties: (keyof Temporal.DurationLike)[]\n) {\n  let record = ToTemporalDurationRecord(item);\n  for (const property of disallowedProperties) {\n    if (record[property] !== 0) {\n      throw new RangeError(\n        `Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\n      );\n    }\n  }\n  return record;\n}\n\nexport function ToTemporalOverflow(options: Temporal.AssignmentOptions | undefined) {\n  if (options === undefined) return 'constrain';\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\n\nexport function ToTemporalDisambiguation(options: Temporal.ToInstantOptions | undefined) {\n  if (options === undefined) return 'compatible';\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\n\nexport function ToTemporalRoundingMode(\n  options: { roundingMode?: Temporal.RoundingMode },\n  fallback: Temporal.RoundingMode\n) {\n  return GetOption(\n    options,\n    'roundingMode',\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\n    fallback\n  );\n}\n\nfunction NegateTemporalRoundingMode(roundingMode: Temporal.RoundingMode) {\n  switch (roundingMode) {\n    case 'ceil':\n      return 'floor';\n    case 'floor':\n      return 'ceil';\n    case 'halfCeil':\n      return 'halfFloor';\n    case 'halfFloor':\n      return 'halfCeil';\n    default:\n      return roundingMode;\n  }\n}\n\nexport function ToTemporalOffset(\n  options: Temporal.OffsetDisambiguationOptions | undefined,\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\n) {\n  if (options === undefined) return fallback;\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\n\nexport function ToCalendarNameOption(options: Temporal.ShowCalendarOption) {\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\n}\n\nexport function ToTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\n}\n\nexport function ToShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\n\nexport function ToTemporalRoundingIncrement(options: { roundingIncrement?: number }) {\n  let increment = options.roundingIncrement;\n  if (increment === undefined) return 1;\n  increment = ToNumber(increment);\n  if (!NumberIsFinite(increment)) {\n    throw new RangeError('roundingIncrement must be finite');\n  }\n  const integerIncrement = MathTrunc(increment);\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\n  }\n  return integerIncrement;\n}\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\n  const maximum = inclusive ? dividend : dividend - 1;\n  if (increment > maximum) {\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\n  }\n  if (dividend % increment !== 0) {\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n  }\n}\n\nexport function ToFractionalSecondDigits(\n  normalizedOptions: Temporal.ToStringPrecisionOptions\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\n  if (digitsValue === undefined) return 'auto';\n  if (typeof digitsValue !== 'number') {\n    if (ToString(digitsValue) !== 'auto') {\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n    }\n    return 'auto';\n  }\n  const digitCount = MathFloor(digitsValue);\n  if (!NumberIsFinite(digitCount) || digitCount < 0 || digitCount > 9) {\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n  }\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\n}\n\nexport function ToSecondsStringPrecisionRecord(\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\n): {\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\n  increment: number;\n} {\n  switch (smallestUnit) {\n    case 'minute':\n      return { precision: 'minute', unit: 'minute', increment: 1 };\n    case 'second':\n      return { precision: 0, unit: 'second', increment: 1 };\n    case 'millisecond':\n      return { precision: 3, unit: 'millisecond', increment: 1 };\n    case 'microsecond':\n      return { precision: 6, unit: 'microsecond', increment: 1 };\n    case 'nanosecond':\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\n    default: // fall through if option not given\n  }\n  switch (precision) {\n    case 'auto':\n      return { precision, unit: 'nanosecond', increment: 1 };\n    case 0:\n      return { precision, unit: 'second', increment: 1 };\n    case 1:\n    case 2:\n    case 3:\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n    case 4:\n    case 5:\n    case 6:\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n    case 7:\n    case 8:\n    case 9:\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n    default:\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\n  }\n}\n\nexport const REQUIRED = Symbol('~required~');\n\ninterface TemporalUnitOptionsBag {\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n}\ntype UnitTypeMapping = {\n  date: Temporal.DateUnit;\n  time: Temporal.TimeUnit;\n  datetime: Temporal.DateTimeUnit;\n};\n// This type specifies the allowed defaults for each unit key type.\ntype AllowedGetTemporalUnitDefaultValues = {\n  smallestUnit: undefined;\n  largestUnit: 'auto' | undefined;\n  unit: undefined;\n};\n\nexport function GetTemporalUnit<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\nexport function GetTemporalUnit<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\n// This signature of the function is NOT used in type-checking, so restricting\n// the default value via generic binding like the other overloads isn't\n// necessary.\nexport function GetTemporalUnit<\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(\n  options: TemporalUnitOptionsBag,\n  key: keyof typeof options,\n  unitGroup: T,\n  requiredOrDefault: D,\n  extraValues: ReadonlyArray<E> | never[] = []\n): R {\n  const allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\n  for (const [, singular, category] of SINGULAR_PLURAL_UNITS) {\n    if (unitGroup === 'datetime' || unitGroup === category) {\n      allowedSingular.push(singular);\n    }\n  }\n  allowedSingular.push(...extraValues);\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\n  if (defaultVal === REQUIRED) {\n    defaultVal = undefined;\n  } else if (defaultVal !== undefined) {\n    allowedSingular.push(defaultVal);\n  }\n  const allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [\n    ...allowedSingular\n  ];\n  for (const singular of allowedSingular) {\n    const plural = PLURAL_FOR.get(singular as Parameters<typeof PLURAL_FOR.get>[0]);\n    if (plural !== undefined) allowedValues.push(plural);\n  }\n  let retval = GetOption(options, key, allowedValues, defaultVal);\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\n    throw new RangeError(`${key} is required`);\n  }\n  // Coerce any plural units into their singular form\n  if (SINGULAR_FOR.has(retval as Temporal.PluralUnit<Temporal.DateTimeUnit>)) {\n    // We just has-checked this, but tsc doesn't understand that.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return SINGULAR_FOR.get(retval as Temporal.PluralUnit<Temporal.DateTimeUnit>)! as R;\n  }\n  return retval as R;\n}\n\nexport function ToRelativeTemporalObject(options: {\n  relativeTo?:\n    | Temporal.ZonedDateTime\n    | Temporal.PlainDateTime\n    | Temporal.ZonedDateTimeLike\n    | Temporal.PlainDateTimeLike\n    | string\n    | undefined;\n}): Temporal.ZonedDateTime | Temporal.PlainDate | undefined {\n  const relativeTo = options.relativeTo;\n  if (relativeTo === undefined) return relativeTo;\n\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  let matchMinutes = false;\n  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n  if (IsObject(relativeTo)) {\n    if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo)) return relativeTo;\n    if (IsTemporalDateTime(relativeTo)) return TemporalDateTimeToDate(relativeTo);\n    calendar = GetTemporalCalendarSlotValueWithISODefault(relativeTo);\n    const fieldNames = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    type FieldNamesWithTimeZoneAndOffset = ArrayWithNewKeys<typeof fieldNames, 'timeZone' | 'offset'>;\n    (fieldNames as FieldNamesWithTimeZoneAndOffset).push('timeZone', 'offset');\n    const fields = PrepareTemporalFields(relativeTo, fieldNames, []);\n    const dateOptions = ObjectCreate(null) as Temporal.AssignmentOptions;\n    dateOptions.overflow = 'constrain';\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      dateOptions\n    ));\n    offset = fields.offset;\n    if (offset === undefined) offsetBehaviour = 'wall';\n    timeZone = fields.timeZone;\n    if (timeZone !== undefined) timeZone = ToTemporalTimeZoneSlotValue(timeZone);\n  } else {\n    let ianaName, z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n      ParseISODateTime(ToString(relativeTo)));\n    if (ianaName) {\n      timeZone = ToTemporalTimeZoneSlotValue(ianaName);\n      if (z) {\n        offsetBehaviour = 'exact';\n      } else if (!offset) {\n        offsetBehaviour = 'wall';\n      }\n      matchMinutes = true;\n    } else if (z) {\n      throw new RangeError(\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\n      );\n    }\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n  }\n  if (timeZone === undefined) return CreateTemporalDate(year, month, day, calendar);\n  // If offset is missing here, then offsetBehavior will never be be 'option'.\n  assertExists(offset);\n  const offsetNs = offsetBehaviour === 'option' ? ParseTimeZoneOffsetString(offset) : 0;\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    'compatible',\n    'reject',\n    matchMinutes\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function DefaultTemporalLargestUnit(\n  years: number,\n  months: number,\n  weeks: number,\n  days: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number\n): Temporal.DateTimeUnit {\n  for (const [prop, v] of [\n    ['years', years],\n    ['months', months],\n    ['weeks', weeks],\n    ['days', days],\n    ['hours', hours],\n    ['minutes', minutes],\n    ['seconds', seconds],\n    ['milliseconds', milliseconds],\n    ['microseconds', microseconds],\n    ['nanoseconds', nanoseconds]\n  ] as const) {\n    if (v !== 0) {\n      // All the above keys are definitely in SINGULAR_FOR\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return SINGULAR_FOR.get(prop)!;\n    }\n  }\n  return 'nanosecond';\n}\n\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\n  unit1: T1,\n  unit2: T2\n) {\n  if (UNITS_DESCENDING.indexOf(unit1) > UNITS_DESCENDING.indexOf(unit2)) return unit2;\n  return unit1;\n}\n\ntype FieldCompleteness = 'complete' | 'partial';\ninterface FieldPrepareOptions {\n  emptySourceErrorMessage: string;\n}\n\n// Returns all potential owners from all Temporal Like-types for a given union\n// of keys in K.\n// e.g.\n// Owner<'nanosecond'> => PlainDateTimeLike | ZonedDateTimeLike | PlainDateTimeLike | ZonedDateTimeLike\n// Owner<'nanoseconds'> => Duration (the only type with plural keys)\ntype Owner<K extends AnyTemporalKey> =\n  // Conditional typing maps over all of the types given in AnyTemporalLikeType\n  // union\n  K extends unknown ? OwnerOf<K, AnyTemporalLikeType> : 'ThisShouldNeverHappen';\n\n// Returns T iff T has K as all of the key(s) (even if those keys are optional\n// in T), never otherwise. This is a private type for use only in the Owner type\n// above.\ntype OwnerOf<K extends AnyTemporalKey, T> =\n  // Distribute the union before passing to Required\n  // Without distributing, this is\n  // Required<ZonedDateTimeLike | DurationLike> extends Record\n  // vs (with distribution)\n  // Required<ZonedDateTimeLike> extends Record<....> | Required<DurationLike> extends Record<....>\n  T extends unknown\n    ? // All the keys in the Like-types are optional, so in order for them to\n      // 'extend Record<K,...>', where K indicates the required fields, we pass T\n      // through Required to make all the keys non-optional.\n      // Note this doesn't work the other way around: using Partial<Record<K, ..>>\n      // will always be extended by any object (as all the keys are optional).\n      Required<T> extends Record<K, unknown>\n      ? T\n      : // never is the 'identity' type for unions - nothing will be added or\n        // removed from the union.\n        never\n    : 'ThisShouldNeverHappen';\n\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\n\n// Resolve copies the keys and values of a given object type so that TS will\n// stop using type names in error messages / autocomplete. Generally, those\n// names can be more useful, but sometimes having the primitive object shape is\n// significantly easier to reason about (e.g. deeply-nested types).\n// Resolve is an identity function for function types.\ntype Resolve<T> =\n  // Re-mapping doesn't work very well for functions, so exclude them\n  T extends (...args: never[]) => unknown\n    ? T\n    : // Re-map all the keys in T to the same value. This forces TS into no longer\n      // using type aliases, etc.\n      { [K in keyof T]: T[K] };\n\ntype FieldObjectFromOwners<OwnerT, FieldKeys extends AnyTemporalKey> = Resolve<\n  // The resulting object type contains:\n  // - All keys in FieldKeys, which are required properties and their values\n  //   don't include undefined.\n  // - All the other keys in OwnerT that aren't in FieldKeys, which are optional\n  //   properties and their value types explicitly include undefined.\n  {\n    -readonly [k in FieldKeys]: Exclude<Prop<OwnerT, k>, undefined>;\n  } & {\n    -readonly [k in Exclude<Keys<OwnerT>, FieldKeys>]?: Prop<OwnerT, k> | undefined;\n  }\n>;\n\ntype PrepareTemporalFieldsReturn<\n  FieldKeys extends AnyTemporalKey,\n  RequiredFieldsOpt extends ReadonlyArray<FieldKeys> | FieldCompleteness,\n  OwnerT extends Owner<FieldKeys>\n> = RequiredFieldsOpt extends 'partial' ? Partial<OwnerT> : FieldObjectFromOwners<OwnerT, FieldKeys>;\nexport function PrepareTemporalFields<\n  FieldKeys extends AnyTemporalKey,\n  // Constrains the Required keys to be a subset of the given field keys\n  // This could have been written directly into the parameter type, but that\n  // causes an unintended effect where the required fields are added to the list\n  // of field keys, even if that key isn't present in 'fields'.\n  // RequiredFieldKeys extends FieldKeys,\n  RequiredFields extends ReadonlyArray<FieldKeys> | FieldCompleteness\n>(\n  bag: Partial<Record<FieldKeys, unknown>>,\n  fields: Array<FieldKeys>,\n  requiredFields: RequiredFields,\n  { emptySourceErrorMessage }: FieldPrepareOptions = { emptySourceErrorMessage: 'no supported properties found' }\n): PrepareTemporalFieldsReturn<FieldKeys, RequiredFields, Owner<FieldKeys>> {\n  const result: Partial<Record<AnyTemporalKey, unknown>> = ObjectCreate(null);\n  let any = false;\n  fields.sort();\n  for (const property of fields) {\n    let value = bag[property];\n    if (value !== undefined) {\n      any = true;\n      if (BUILTIN_CASTS.has(property)) {\n        // We just has-checked this map access, so there will definitely be a\n        // value.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        value = BUILTIN_CASTS.get(property)!(value);\n      }\n      result[property] = value;\n    } else if (requiredFields !== 'partial') {\n      // TODO: using .call in this way is not correctly type-checked by tsc.\n      // We might need a type-safe Call wrapper?\n      if (ArrayIncludes.call(requiredFields, property)) {\n        throw new TypeError(`required property '${property}' missing or undefined`);\n      }\n      value = BUILTIN_DEFAULTS.get(property);\n      result[property] = value;\n    }\n  }\n  if (requiredFields === 'partial' && !any) {\n    throw new TypeError(emptySourceErrorMessage);\n  }\n  return result as unknown as PrepareTemporalFieldsReturn<FieldKeys, RequiredFields, Owner<FieldKeys>>;\n}\n\ninterface TimeRecord {\n  hour?: number;\n  minute?: number;\n  second?: number;\n  microsecond?: number;\n  millisecond?: number;\n  nanosecond?: number;\n}\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): Required<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: 'partial'\n): Partial<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\n  completeness: 'complete'\n): Required<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: FieldCompleteness = 'complete'\n): Partial<TimeRecord> {\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\n  const partial = PrepareTemporalFields(bag, fields, 'partial', { emptySourceErrorMessage: 'invalid time-like' });\n  const result: Partial<TimeRecord> = {};\n  for (const field of fields) {\n    const valueDesc = ObjectGetOwnPropertyDescriptor(partial, field);\n    if (valueDesc !== undefined) {\n      result[field] = valueDesc.value;\n    } else if (completeness === 'complete') {\n      result[field] = 0;\n    }\n  }\n  return result;\n}\n\nexport function ToTemporalDate(\n  itemParam: PlainDateParams['from'][0],\n  options?: PlainDateParams['from'][1]\n): Temporal.PlainDate {\n  let item = itemParam;\n  if (IsObject(item)) {\n    if (IsTemporalDate(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      item = GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return CreateTemporalDate(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    const calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    return CalendarDateFromFields(calendar, fields, options);\n  }\n  ToTemporalOverflow(options); // validate and ignore\n  let { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\n  if (!calendar) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n  return CreateTemporalDate(year, month, day, calendar);\n}\n\nexport function InterpretTemporalDateTimeFields(\n  calendar: CalendarSlot,\n  fields: PrimitiveFieldsOf<Temporal.PlainDateTimeLike> & Parameters<typeof CalendarDateFromFields>[1],\n  options?: Temporal.AssignmentOptions\n) {\n  let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n  const overflow = ToTemporalOverflow(options);\n  const date = CalendarDateFromFields(calendar, fields, options);\n  const year = GetSlot(date, ISO_YEAR);\n  const month = GetSlot(date, ISO_MONTH);\n  const day = GetSlot(date, ISO_DAY);\n  ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    overflow\n  ));\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\n  let year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    millisecond: number,\n    microsecond: number,\n    nanosecond: number,\n    calendar;\n  if (IsObject(item)) {\n    if (IsTemporalDateTime(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDate(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return CreateTemporalDateTime(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        GetSlot(item, CALENDAR)\n      );\n    }\n\n    calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      options\n    ));\n  } else {\n    ToTemporalOverflow(options); // validate and ignore\n    let z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n      ParseTemporalDateTimeString(ToString(item)));\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\n    RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n  }\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\n  if (IsTemporalDuration(item)) return item;\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(item);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n}\n\nexport function ToTemporalInstant(item: InstantParams['from'][0]) {\n  if (IsTemporalInstant(item)) return item;\n  if (IsTemporalZonedDateTime(item)) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n  }\n  const ns = ParseTemporalInstant(ToString(item));\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  return new TemporalInstant(ns);\n}\n\nexport function ToTemporalMonthDay(\n  itemParam: PlainMonthDayParams['from'][0],\n  options?: PlainMonthDayParams['from'][1]\n) {\n  let item = itemParam;\n  if (IsObject(item)) {\n    if (IsTemporalMonthDay(item)) return item;\n    let calendar: CalendarSlot, calendarAbsent: boolean;\n    if (HasSlot(item, CALENDAR)) {\n      calendar = GetSlot(item, CALENDAR);\n      calendarAbsent = false;\n    } else {\n      let calendarFromItem = item.calendar;\n      calendarAbsent = calendarFromItem === undefined;\n      if (calendarFromItem === undefined) calendarFromItem = 'iso8601';\n      calendar = ToTemporalCalendarSlotValue(calendarFromItem);\n    }\n    // HasSlot above adjusts the type of 'item' to include\n    // TypesWithCalendarUnits, which causes type-inference failures below.\n    // This is probably indicative of problems with HasSlot's typing.\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    // Callers who omit the calendar are not writing calendar-independent\n    // code. In that case, `monthCode`/`year` can be omitted; `month` and\n    // `day` are sufficient. Add a `year` to satisfy calendar validation.\n    if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n      fields.year = 1972;\n    }\n    return CalendarMonthDayFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(ToString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n\n  if (referenceISOYear === undefined) {\n    RejectISODate(1972, month, day);\n    return CreateTemporalMonthDay(month, day, calendar);\n  }\n  const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n  return CalendarMonthDayFromFields(calendar, result);\n}\n\nexport function ToTemporalTime(\n  itemParam: PlainTimeParams['from'][0],\n  overflow: NonNullable<PlainTimeParams['from'][1]>['overflow'] = 'constrain'\n) {\n  let item = itemParam;\n  let hour, minute, second, millisecond, microsecond, nanosecond;\n  if (IsObject(item)) {\n    if (IsTemporalTime(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      item = GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n      return new TemporalPlainTime(\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND)\n      );\n    }\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n  } else {\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ParseTemporalTimeString(ToString(item)));\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function ToTemporalYearMonth(\n  item: PlainYearMonthParams['from'][0],\n  options?: PlainYearMonthParams['from'][1]\n): Temporal.PlainYearMonth {\n  if (IsObject(item)) {\n    if (IsTemporalYearMonth(item)) return item;\n    const calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    return CalendarYearMonthFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(ToString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n\n  if (referenceISODay === undefined) {\n    RejectISODate(year, month, 1);\n    return CreateTemporalYearMonth(year, month, calendar);\n  }\n  const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n  return CalendarYearMonthFromFields(calendar, result);\n}\n\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\n\nexport function InterpretISODateTimeOffset(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  offsetBehaviour: OffsetBehaviour,\n  offsetNs: number,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\n  matchMinute: boolean\n) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\n    // the offset), so just convert DateTime to Instant in the given time zone\n    const instant = GetInstantFor(timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n  }\n\n  // The caller wants the offset to always win ('use') OR the caller is OK\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\n  // for this timezone and date/time.\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n    // Calculate the instant for the input's date/time and offset\n    const epochNs = GetUTCEpochNanoseconds(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    );\n    if (epochNs === null) throw new RangeError('ZonedDateTime outside of supported range');\n    return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n  }\n\n  // \"prefer\" or \"reject\"\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n  for (const candidate of possibleInstants) {\n    const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n    const roundedCandidateOffset = JSBI.toNumber(\n      RoundNumberToIncrement(JSBI.BigInt(candidateOffset), MINUTE_NANOS, 'halfExpand')\n    );\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n      return GetSlot(candidate, EPOCHNANOSECONDS);\n    }\n  }\n\n  // the user-provided offset doesn't match any instants for this time\n  // zone and date/time.\n  if (offsetOpt === 'reject') {\n    const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n    const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n    // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n    // toString (which is invoked by Node when using template literals directly).\n    // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n  }\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\n  // so fall back to use the time zone instead.\n  const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n  return GetSlot(instant, EPOCHNANOSECONDS);\n}\n\nexport function ToTemporalZonedDateTime(\n  item: ZonedDateTimeParams['from'][0],\n  options?: ZonedDateTimeParams['from'][1]\n) {\n  let year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    millisecond: number,\n    microsecond: number,\n    nanosecond: number,\n    timeZone,\n    offset: string | undefined,\n    calendar: string | Temporal.CalendarProtocol | undefined;\n  let disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>;\n  let offsetOpt: NonNullable<Temporal.OffsetDisambiguationOptions['offset']>;\n  let matchMinute = false;\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  if (IsObject(item)) {\n    if (IsTemporalZonedDateTime(item)) return item;\n    calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames: (keyof Temporal.ZonedDateTimeLike)[] = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    fieldNames.push('timeZone', 'offset');\n    const fields = PrepareTemporalFields(item, fieldNames, ['timeZone']);\n    timeZone = ToTemporalTimeZoneSlotValue(fields.timeZone);\n    offset = fields.offset;\n    if (offset === undefined) {\n      offsetBehaviour = 'wall';\n    }\n    disambiguation = ToTemporalDisambiguation(options);\n    offsetOpt = ToTemporalOffset(options, 'reject');\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      options\n    ));\n  } else {\n    let ianaName, z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n      ParseTemporalZonedDateTimeString(ToString(item)));\n    timeZone = ToTemporalTimeZoneSlotValue(ianaName);\n    if (z) {\n      offsetBehaviour = 'exact';\n    } else if (!offset) {\n      offsetBehaviour = 'wall';\n    }\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n    matchMinute = true; // ISO strings may specify offset with less precision\n    disambiguation = ToTemporalDisambiguation(options);\n    offsetOpt = ToTemporalOffset(options, 'reject');\n    ToTemporalOverflow(options); // validate and ignore\n  }\n  let offsetNs = 0;\n  // The code above guarantees that if offsetBehaviour === 'option', then\n  // `offset` is not undefined.\n  if (offsetBehaviour === 'option') offsetNs = ParseTimeZoneOffsetString(offset as string);\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    disambiguation,\n    offsetOpt,\n    matchMinute\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function CreateTemporalDateSlots(\n  result: Temporal.PlainDate,\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot\n) {\n  RejectISODate(isoYear, isoMonth, isoDay);\n  RejectDateRange(isoYear, isoMonth, isoDay);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, DATE_BRAND, true);\n\n  if (DEBUG) {\n    ObjectDefineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDate(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n  const result = ObjectCreate(TemporalPlainDate.prototype);\n  CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n  return result;\n}\n\nexport function CreateTemporalDateTimeSlots(\n  result: Temporal.PlainDateTime,\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number,\n  calendar: CalendarSlot\n) {\n  RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n  RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_HOUR, h);\n  SetSlot(result, ISO_MINUTE, min);\n  SetSlot(result, ISO_SECOND, s);\n  SetSlot(result, ISO_MILLISECOND, ms);\n  SetSlot(result, ISO_MICROSECOND, µs);\n  SetSlot(result, ISO_NANOSECOND, ns);\n  SetSlot(result, CALENDAR, calendar);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDateTime(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const result = ObjectCreate(TemporalPlainDateTime.prototype);\n  CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar);\n  return result as Temporal.PlainDateTime;\n}\n\nexport function CreateTemporalMonthDaySlots(\n  result: Temporal.PlainMonthDay,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot,\n  referenceISOYear: number\n) {\n  RejectISODate(referenceISOYear, isoMonth, isoDay);\n  RejectDateRange(referenceISOYear, isoMonth, isoDay);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_YEAR, referenceISOYear);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, MONTH_DAY_BRAND, true);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalMonthDay(\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot = 'iso8601',\n  referenceISOYear = 1972\n) {\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n  const result = ObjectCreate(TemporalPlainMonthDay.prototype);\n  CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n  return result;\n}\n\nexport function CreateTemporalYearMonthSlots(\n  result: Temporal.PlainYearMonth,\n  isoYear: number,\n  isoMonth: number,\n  calendar: CalendarSlot,\n  referenceISODay: number\n) {\n  RejectISODate(isoYear, isoMonth, referenceISODay);\n  RejectYearMonthRange(isoYear, isoMonth);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, referenceISODay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, YEAR_MONTH_BRAND, true);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalYearMonth(\n  isoYear: number,\n  isoMonth: number,\n  calendar: CalendarSlot = 'iso8601',\n  referenceISODay = 1\n) {\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n  const result = ObjectCreate(TemporalPlainYearMonth.prototype);\n  CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n  return result;\n}\n\nexport function CreateTemporalZonedDateTimeSlots(\n  result: Temporal.ZonedDateTime,\n  epochNanoseconds: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot\n) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n  SetSlot(result, TIME_ZONE, timeZone);\n  SetSlot(result, CALENDAR, calendar);\n\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n  SetSlot(result, INSTANT, instant);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalZonedDateTime(\n  epochNanoseconds: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n  const result = ObjectCreate(TemporalZonedDateTime.prototype);\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n  return result;\n}\n\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nexport function CalendarFields<K extends AnyTemporalKey>(calendar: CalendarSlot, fieldNamesParam: ReadonlyArray<K>) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.fields%'), calendarObj, [fieldNamesParam]) as K[];\n  }\n  const fields = GetMethod(calendar, 'fields');\n  const fieldNames = Call(fields, calendar, [fieldNamesParam]);\n  const result: K[] = [];\n  for (const name of fieldNames) {\n    if (typeof name !== 'string') throw new TypeError('bad return from calendar.fields()');\n    ArrayPrototypePush.call(result, name);\n  }\n  return result;\n}\n\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\n  calendar: CalendarSlot,\n  fields: Base,\n  additionalFields: ToAdd\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.mergeFields%'), calendarObj, [\n      fields,\n      additionalFields\n    ]) as Base & ToAdd;\n  }\n  const mergeFields = GetMethod(calendar, 'mergeFields');\n  const result = Call(mergeFields, calendar, [fields, additionalFields]);\n  if (!IsObject(result)) throw new TypeError('bad return from calendar.mergeFields()');\n  return result as Base & ToAdd;\n}\n\nexport function CalendarDateAdd(\n  calendar: CalendarSlot,\n  date: CalendarProtocolParams['dateAdd'][0],\n  duration: CalendarProtocolParams['dateAdd'][1],\n  options: CalendarProtocolParams['dateAdd'][2],\n  dateAddParam?: Temporal.CalendarProtocol['dateAdd'] | undefined\n) {\n  let dateAdd = dateAddParam;\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateAdd%'), calendarObj, [date, duration, options]);\n  }\n  if (dateAdd === undefined) {\n    dateAdd = GetMethod(calendar, 'dateAdd');\n  }\n  const result = ReflectApply(dateAdd, calendar, [date, duration, options]);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction CalendarDateUntil(\n  calendar: CalendarSlot,\n  date: CalendarProtocolParams['dateUntil'][0],\n  otherDate: CalendarProtocolParams['dateUntil'][1],\n  options: CalendarProtocolParams['dateUntil'][2],\n  dateUntilParam?: Temporal.CalendarProtocol['dateUntil'] | undefined\n) {\n  let dateUntil = dateUntilParam;\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateUntil%'), calendarObj, [date, otherDate, options]);\n  }\n  if (dateUntil === undefined) {\n    dateUntil = GetMethod(calendar, 'dateUntil');\n  }\n  const result = ReflectApply(dateUntil, calendar, [date, otherDate, options]);\n  if (!IsTemporalDuration(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['year'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.year%'), calendarObj, [dateLike]);\n  }\n  const year = GetMethod(calendar, 'year');\n  let result = Call(year, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar year result must be an integer');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar year result must be an integer');\n  }\n  return result;\n}\n\nexport function CalendarMonth(calendar: CalendarSlot, dateLike: CalendarProtocolParams['month'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.month%'), calendarObj, [dateLike]);\n  }\n  const month = GetMethod(calendar, 'month');\n  let result = Call(month, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar month result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar month result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarMonthCode(calendar: CalendarSlot, dateLike: CalendarProtocolParams['monthCode'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthCode%'), calendarObj, [dateLike]);\n  }\n  const monthCode = GetMethod(calendar, 'monthCode');\n  let result = Call(monthCode, calendar, [dateLike]);\n  if (typeof result !== 'string') {\n    throw new TypeError('calendar monthCode result must be a string');\n  }\n  return result;\n}\n\nexport function CalendarDay(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.day%'), calendarObj, [dateLike]);\n  }\n  const day = GetMethod(calendar, 'day');\n  const result = Call(day, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar day result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar day result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarEra(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.era%'), calendarObj, [dateLike]);\n  }\n  const era = GetMethod(calendar, 'era');\n  let result = Call(era, calendar, [dateLike]);\n  if (result === undefined) {\n    return result;\n  }\n  if (typeof result !== 'string') {\n    throw new TypeError('calendar era result must be a string or undefined');\n  }\n  return result;\n}\n\nexport function CalendarEraYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.eraYear%'), calendarObj, [dateLike]);\n  }\n  const eraYear = GetMethod(calendar, 'eraYear');\n  let result = Call(eraYear, calendar, [dateLike]);\n  if (result === undefined) {\n    return result;\n  }\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar eraYear result must be an integer or undefined');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar eraYear result must be an integer or undefined');\n  }\n  return result;\n}\n\nexport function CalendarDayOfWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dayOfWeek%'), calendarObj, [dateLike]);\n  }\n  const dayOfWeek = GetMethod(calendar, 'dayOfWeek');\n  const result = Call(dayOfWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar dayOfWeek result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar dayOfWeek result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDayOfYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dayOfYear%'), calendarObj, [dateLike]);\n  }\n  const dayOfYear = GetMethod(calendar, 'dayOfYear');\n  const result = Call(dayOfYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar dayOfYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar dayOfYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarWeekOfYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.weekOfYear%'), calendarObj, [dateLike]);\n  }\n  const weekOfYear = GetMethod(calendar, 'weekOfYear');\n  const result = Call(weekOfYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar weekOfYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar weekOfYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarYearOfWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.yearOfWeek%'), calendarObj, [dateLike]);\n  }\n  const yearOfWeek = GetMethod(calendar, 'yearOfWeek');\n  const result = Call(yearOfWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar yearOfWeek result must be an integer');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar yearOfWeek result must be an integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInWeek%'), calendarObj, [dateLike]);\n  }\n  const daysInWeek = GetMethod(calendar, 'daysInWeek');\n  const result = Call(daysInWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInWeek result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInWeek result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInMonth(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInMonth%'), calendarObj, [dateLike]);\n  }\n  const daysInMonth = GetMethod(calendar, 'daysInMonth');\n  const result = Call(daysInMonth, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInMonth result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInMonth result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInYear%'), calendarObj, [dateLike]);\n  }\n  const daysInYear = GetMethod(calendar, 'daysInYear');\n  const result = Call(daysInYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarMonthsInYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthsInYear%'), calendarObj, [dateLike]);\n  }\n  const monthsInYear = GetMethod(calendar, 'monthsInYear');\n  const result = Call(monthsInYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar monthsInYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar monthsInYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarInLeapYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.inLeapYear%'), calendarObj, [dateLike]);\n  }\n  const inLeapYear = GetMethod(calendar, 'inLeapYear');\n  const result = Call(inLeapYear, calendar, [dateLike]);\n  if (typeof result !== 'boolean') {\n    throw new TypeError('calendar inLeapYear result must be a boolean');\n  }\n  return result;\n}\n\ntype MaybeCalendarProtocol = Partial<Omit<Temporal.CalendarProtocol, 'toString' | 'toJSON'>>;\nfunction ObjectImplementsTemporalCalendarProtocol(object: MaybeCalendarProtocol) {\n  if (IsTemporalCalendar(object)) return true;\n  return (\n    'dateAdd' in object &&\n    'dateFromFields' in object &&\n    'dateUntil' in object &&\n    'day' in object &&\n    'dayOfWeek' in object &&\n    'dayOfYear' in object &&\n    'daysInMonth' in object &&\n    'daysInWeek' in object &&\n    'daysInYear' in object &&\n    'fields' in object &&\n    'id' in object &&\n    'inLeapYear' in object &&\n    'mergeFields' in object &&\n    'month' in object &&\n    'monthCode' in object &&\n    'monthDayFromFields' in object &&\n    'monthsInYear' in object &&\n    'weekOfYear' in object &&\n    'year' in object &&\n    'yearMonthFromFields' in object &&\n    'yearOfWeek' in object\n  );\n}\n\nexport function ToTemporalCalendarSlotValue(calendarLike: string): string;\nexport function ToTemporalCalendarSlotValue(calendarLike: Temporal.CalendarProtocol): Temporal.CalendarProtocol;\nexport function ToTemporalCalendarSlotValue(calendarLike: Temporal.CalendarLike): string | Temporal.CalendarProtocol;\nexport function ToTemporalCalendarSlotValue(calendarLike: CalendarParams['from'][0]) {\n  if (IsObject(calendarLike)) {\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\n    if (!ObjectImplementsTemporalCalendarProtocol(calendarLike)) {\n      throw new TypeError('expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol');\n    }\n    return calendarLike;\n  }\n  const identifier = ToString(calendarLike);\n  if (IsBuiltinCalendar(identifier)) return ASCIILowercase(identifier);\n  let calendar;\n  try {\n    ({ calendar } = ParseISODateTime(identifier));\n  } catch {\n    try {\n      ({ calendar } = ParseTemporalYearMonthString(identifier));\n    } catch {\n      ({ calendar } = ParseTemporalMonthDayString(identifier));\n    }\n  }\n  if (!calendar) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  return ASCIILowercase(calendar);\n}\n\nfunction GetTemporalCalendarSlotValueWithISODefault(item: { calendar?: Temporal.CalendarLike }): CalendarSlot {\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\n  const { calendar } = item;\n  if (calendar === undefined) return 'iso8601';\n  return ToTemporalCalendarSlotValue(calendar);\n}\n\nexport function ToTemporalCalendarIdentifier(slotValue: CalendarSlot) {\n  if (typeof slotValue === 'string') return slotValue;\n  const result = slotValue.id;\n  if (typeof result !== 'string') throw new TypeError('calendar.id should be a string');\n  return result;\n}\n\nexport function ToTemporalCalendarObject(slotValue: CalendarSlot) {\n  if (IsObject(slotValue)) return slotValue;\n  const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n  return new TemporalCalendar(slotValue);\n}\n\nexport function CalendarEquals(one: CalendarSlot, two: CalendarSlot) {\n  if (one === two) return true;\n  const cal1 = ToTemporalCalendarIdentifier(one);\n  const cal2 = ToTemporalCalendarIdentifier(two);\n  return cal1 === cal2;\n}\n\n// This operation is not in the spec, it implements the following:\n// \"If ? CalendarEquals(one, two) is false, throw a RangeError exception.\"\n// This is so that we can build an informative error message without\n// re-getting the .id properties.\nfunction ThrowIfCalendarsNotEqual(one: CalendarSlot, two: CalendarSlot, errorMessageAction: string) {\n  if (one === two) return;\n  const cal1 = ToTemporalCalendarIdentifier(one);\n  const cal2 = ToTemporalCalendarIdentifier(two);\n  if (cal1 !== cal2) {\n    throw new RangeError(`cannot ${errorMessageAction} of ${cal1} and ${cal2} calendars`);\n  }\n}\n\nexport function ConsolidateCalendars(one: CalendarSlot, two: CalendarSlot) {\n  if (one === two) return two;\n  const sOne = ToTemporalCalendarIdentifier(one);\n  const sTwo = ToTemporalCalendarIdentifier(two);\n  if (sOne === sTwo || sOne === 'iso8601') {\n    return two;\n  } else if (sTwo === 'iso8601') {\n    return one;\n  } else {\n    throw new RangeError('irreconcilable calendars');\n  }\n}\n\nexport function CalendarDateFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['dateFromFields'][0],\n  options?: Partial<CalendarProtocolParams['dateFromFields'][1]>,\n  dateFromFieldsParam?: Temporal.CalendarProtocol['dateFromFields']\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateFromFields%'), calendarObj, [fields, options]);\n  }\n  const dateFromFields = dateFromFieldsParam ?? GetMethod(calendar, 'dateFromFields');\n  const result = Call(dateFromFields, calendar, [fields, options]);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarYearMonthFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['yearMonthFromFields'][0],\n  options?: CalendarProtocolParams['yearMonthFromFields'][1]\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.yearMonthFromFields%'), calendarObj, [fields, options]);\n  }\n  const yearMonthFromFields = GetMethod(calendar, 'yearMonthFromFields');\n  let result = Call(yearMonthFromFields, calendar, [fields, options]);\n  if (!IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarMonthDayFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['monthDayFromFields'][0],\n  options?: CalendarProtocolParams['monthDayFromFields'][1]\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthDayFromFields%'), calendarObj, [fields, options]);\n  }\n  const monthDayFromFields = GetMethod(calendar, 'monthDayFromFields');\n  let result = Call(monthDayFromFields, calendar, [fields, options]);\n  if (!IsTemporalMonthDay(result)) throw new TypeError('invalid result');\n  return result;\n}\n\ntype MaybeTimeZoneProtocol = Partial<\n  Pick<Temporal.TimeZoneProtocol, 'getOffsetNanosecondsFor' | 'getPossibleInstantsFor'>\n>;\nfunction ObjectImplementsTemporalTimeZoneProtocol(object: MaybeTimeZoneProtocol) {\n  if (IsTemporalTimeZone(object)) return true;\n  return 'getOffsetNanosecondsFor' in object && 'getPossibleInstantsFor' in object && 'id' in object;\n}\n\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: string): string;\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: Temporal.TimeZoneProtocol): Temporal.TimeZoneProtocol;\nexport function ToTemporalTimeZoneSlotValue(\n  temporalTimeZoneLike: Temporal.TimeZoneLike\n): string | Temporal.TimeZoneProtocol;\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: TimeZoneParams['from'][0]) {\n  if (IsObject(temporalTimeZoneLike)) {\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n    if (!ObjectImplementsTemporalTimeZoneProtocol(temporalTimeZoneLike)) {\n      throw new TypeError('expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol');\n    }\n    return temporalTimeZoneLike;\n  }\n  const identifier = ToString(temporalTimeZoneLike);\n  return ParseTemporalTimeZone(identifier);\n}\n\nexport function ToTemporalTimeZoneIdentifier(slotValue: TimeZoneSlot) {\n  if (typeof slotValue === 'string') return slotValue;\n  const result = slotValue.id;\n  if (typeof result !== 'string') throw new TypeError('timeZone.id should be a string');\n  return result;\n}\n\nexport function ToTemporalTimeZoneObject(slotValue: TimeZoneSlot) {\n  if (IsObject(slotValue)) return slotValue;\n  const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n  return new TemporalTimeZone(slotValue);\n}\n\nexport function TimeZoneEquals(one: string | Temporal.TimeZoneProtocol, two: string | Temporal.TimeZoneProtocol) {\n  if (one === two) return true;\n  const tz1 = ToTemporalTimeZoneIdentifier(one);\n  const tz2 = ToTemporalTimeZoneIdentifier(two);\n  return tz1 === tz2;\n}\n\nexport function TemporalDateTimeToDate(dateTime: Temporal.PlainDateTime) {\n  return CreateTemporalDate(\n    GetSlot(dateTime, ISO_YEAR),\n    GetSlot(dateTime, ISO_MONTH),\n    GetSlot(dateTime, ISO_DAY),\n    GetSlot(dateTime, CALENDAR)\n  );\n}\n\nexport function TemporalDateTimeToTime(dateTime: Temporal.PlainDateTime) {\n  const Time = GetIntrinsic('%Temporal.PlainTime%');\n  return new Time(\n    GetSlot(dateTime, ISO_HOUR),\n    GetSlot(dateTime, ISO_MINUTE),\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND)\n  );\n}\n\nexport function GetOffsetNanosecondsFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  instant: TimeZoneProtocolParams['getOffsetNanosecondsFor'][0],\n  getOffsetNanosecondsForParam?: Temporal.TimeZoneProtocol['getOffsetNanosecondsFor']\n) {\n  if (typeof timeZone === 'string') {\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    const timeZoneObject = new TemporalTimeZone(timeZone);\n    return Call(GetIntrinsic('%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%'), timeZoneObject, [instant]);\n  }\n  const getOffsetNanosecondsFor = getOffsetNanosecondsForParam ?? GetMethod(timeZone, 'getOffsetNanosecondsFor');\n  const offsetNs = Call(getOffsetNanosecondsFor, timeZone, [instant]);\n  if (typeof offsetNs !== 'number') {\n    throw new TypeError('bad return from getOffsetNanosecondsFor');\n  }\n  if (!IsIntegralNumber(offsetNs) || MathAbs(offsetNs) >= 86400e9) {\n    throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n  }\n  return offsetNs;\n}\n\nexport function GetOffsetStringFor(timeZone: string | Temporal.TimeZoneProtocol, instant: Temporal.Instant) {\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  return FormatTimeZoneOffsetString(offsetNs);\n}\n\nexport function GetPlainDateTimeFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  instant: Temporal.Instant,\n  calendar: CalendarSlot\n) {\n  const ns = GetSlot(instant, EPOCHNANOSECONDS);\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n  ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond + offsetNs\n  ));\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function GetInstantFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: Temporal.PlainDateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n  return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\n\nfunction DisambiguatePossibleInstants(\n  possibleInstants: Temporal.Instant[],\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: Temporal.PlainDateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  const numInstants = possibleInstants.length;\n\n  if (numInstants === 1) return possibleInstants[0];\n  if (numInstants) {\n    switch (disambiguation) {\n      case 'compatible':\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n      case 'earlier':\n        return possibleInstants[0];\n      case 'later':\n        return possibleInstants[numInstants - 1];\n      case 'reject': {\n        throw new RangeError('multiple instants found');\n      }\n    }\n  }\n\n  const year = GetSlot(dateTime, ISO_YEAR);\n  const month = GetSlot(dateTime, ISO_MONTH);\n  const day = GetSlot(dateTime, ISO_DAY);\n  const hour = GetSlot(dateTime, ISO_HOUR);\n  const minute = GetSlot(dateTime, ISO_MINUTE);\n  const second = GetSlot(dateTime, ISO_SECOND);\n  const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n  const utcns = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (utcns === null) throw new RangeError('DateTime outside of supported range');\n  const dayBefore = new Instant(JSBI.subtract(utcns, DAY_NANOS));\n  const dayAfter = new Instant(JSBI.add(utcns, DAY_NANOS));\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n  const nanoseconds = offsetAfter - offsetBefore;\n  switch (disambiguation) {\n    case 'earlier': {\n      const calendar = GetSlot(dateTime, CALENDAR);\n      const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n      const earlier = AddDateTime(\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        calendar,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -nanoseconds,\n        undefined\n      );\n      const earlierPlainDateTime = new PlainDateTime(\n        earlier.year,\n        earlier.month,\n        earlier.day,\n        earlier.hour,\n        earlier.minute,\n        earlier.second,\n        earlier.millisecond,\n        earlier.microsecond,\n        earlier.nanosecond,\n        calendar\n      );\n      return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n    }\n    case 'compatible':\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n    case 'later': {\n      const calendar = GetSlot(dateTime, CALENDAR);\n      const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n      const later = AddDateTime(\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        calendar,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        nanoseconds,\n        undefined\n      );\n      const laterPlainDateTime = new PlainDateTime(\n        later.year,\n        later.month,\n        later.day,\n        later.hour,\n        later.minute,\n        later.second,\n        later.millisecond,\n        later.microsecond,\n        later.nanosecond,\n        calendar\n      );\n      const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n      return possible[possible.length - 1];\n    }\n    case 'reject': {\n      throw new RangeError('no such instant found');\n    }\n  }\n}\n\nfunction GetPossibleInstantsFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: TimeZoneProtocolParams['getPossibleInstantsFor'][0],\n  getPossibleInstantsForParam?: Temporal.TimeZoneProtocol['getPossibleInstantsFor']\n) {\n  if (typeof timeZone === 'string') {\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    const timeZoneObject = new TemporalTimeZone(timeZone);\n    return Call(GetIntrinsic('%Temporal.TimeZone.prototype.getPossibleInstantsFor%'), timeZoneObject, [dateTime]);\n  }\n  const getPossibleInstantsFor = getPossibleInstantsForParam ?? GetMethod(timeZone, 'getPossibleInstantsFor');\n  const possibleInstants = Call(getPossibleInstantsFor, timeZone, [dateTime]);\n  const result: Temporal.Instant[] = [];\n  for (const instant of possibleInstants) {\n    if (!IsTemporalInstant(instant)) {\n      throw new TypeError('bad return from getPossibleInstantsFor');\n    }\n    ArrayPrototypePush.call(result, instant);\n  }\n  return result;\n}\n\nexport function ISOYearString(year: number) {\n  let yearString;\n  if (year < 0 || year > 9999) {\n    const sign = year < 0 ? '-' : '+';\n    const yearNumber = MathAbs(year);\n    yearString = sign + `000000${yearNumber}`.slice(-6);\n  } else {\n    yearString = `0000${year}`.slice(-4);\n  }\n  return yearString;\n}\n\nexport function ISODateTimePartString(part: number) {\n  return `00${part}`.slice(-2);\n}\nexport function FormatSecondsStringPart(\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision']\n) {\n  if (precision === 'minute') return '';\n\n  const secs = `:${ISODateTimePartString(second)}`;\n  let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  let fraction: string;\n\n  if (precision === 'auto') {\n    if (fractionNumber === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0');\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n  } else {\n    if (precision === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n  }\n  return `${secs}.${fraction}`;\n}\n\nexport function TemporalInstantToString(\n  instant: Temporal.Instant,\n  timeZone: string | Temporal.TimeZoneProtocol | undefined,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision']\n) {\n  let outputTimeZone = timeZone;\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\n  const dateTime = GetPlainDateTimeFor(outputTimeZone, instant, 'iso8601');\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    precision\n  );\n  let timeZoneString = 'Z';\n  if (timeZone !== undefined) {\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n    timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n  }\n  return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\n\ninterface ToStringOptions {\n  unit: ReturnType<typeof ToSecondsStringPrecisionRecord>['unit'];\n  increment: number;\n  roundingMode: ReturnType<typeof ToTemporalRoundingMode>;\n}\n\nexport function TemporalDurationToString(\n  duration: Temporal.Duration,\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  function formatNumber(num: number) {\n    if (num <= NumberMaxSafeInteger) return num.toString(10);\n    return JSBI.BigInt(num).toString(10);\n  }\n\n  const years = GetSlot(duration, YEARS);\n  const months = GetSlot(duration, MONTHS);\n  const weeks = GetSlot(duration, WEEKS);\n  const days = GetSlot(duration, DAYS);\n  const hours = GetSlot(duration, HOURS);\n  const minutes = GetSlot(duration, MINUTES);\n  let seconds = GetSlot(duration, SECONDS);\n  let ms = GetSlot(duration, MILLISECONDS);\n  let µs = GetSlot(duration, MICROSECONDS);\n  let ns = GetSlot(duration, NANOSECONDS);\n  const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, µs, ns);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({\n      seconds,\n      milliseconds: ms,\n      microseconds: µs,\n      nanoseconds: ns\n    } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, µs, ns, increment, unit, roundingMode));\n  }\n\n  const dateParts: string[] = [];\n  if (years) dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n  if (months) dateParts.push(`${formatNumber(MathAbs(months))}M`);\n  if (weeks) dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n  if (days) dateParts.push(`${formatNumber(MathAbs(days))}D`);\n\n  const timeParts: string[] = [];\n  if (hours) timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n  if (minutes) timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n\n  const secondParts: string[] = [];\n  let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, µs, ns, 0);\n  let nsBigInt: JSBI, µsBigInt: JSBI, msBigInt: JSBI, secondsBigInt: JSBI;\n  ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n  ({ quotient: total, remainder: µsBigInt } = divmod(total, THOUSAND));\n  ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n  const fraction =\n    MathAbs(JSBI.toNumber(msBigInt)) * 1e6 + MathAbs(JSBI.toNumber(µsBigInt)) * 1e3 + MathAbs(JSBI.toNumber(nsBigInt));\n  let decimalPart;\n  if (precision === 'auto') {\n    if (fraction !== 0) {\n      decimalPart = `${fraction}`.padStart(9, '0');\n      while (decimalPart[decimalPart.length - 1] === '0') {\n        decimalPart = decimalPart.slice(0, -1);\n      }\n    }\n  } else if (precision !== 0) {\n    decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n  }\n  if (decimalPart) secondParts.unshift('.', decimalPart);\n  if (!JSBI.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n    secondParts.unshift(abs(secondsBigInt).toString());\n  }\n  if (secondParts.length) timeParts.push(`${secondParts.join('')}S`);\n  if (timeParts.length) timeParts.unshift('T');\n  if (!dateParts.length && !timeParts.length) return 'PT0S';\n  return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\n\nexport function TemporalDateToString(\n  date: Temporal.PlainDate,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const year = ISOYearString(GetSlot(date, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n  const calendar = MaybeFormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\n  return `${year}-${month}-${day}${calendar}`;\n}\n\nexport function TemporalDateTimeToString(\n  dateTime: Temporal.PlainDateTime,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision'],\n  showCalendar: ReturnType<typeof ToCalendarNameOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let year = GetSlot(dateTime, ISO_YEAR);\n  let month = GetSlot(dateTime, ISO_MONTH);\n  let day = GetSlot(dateTime, ISO_DAY);\n  let hour = GetSlot(dateTime, ISO_HOUR);\n  let minute = GetSlot(dateTime, ISO_MINUTE);\n  let second = GetSlot(dateTime, ISO_SECOND);\n  let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      increment,\n      unit,\n      roundingMode\n    ));\n  }\n\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const hourString = ISODateTimePartString(hour);\n  const minuteString = ISODateTimePartString(minute);\n  const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  const calendar = MaybeFormatCalendarAnnotation(GetSlot(dateTime, CALENDAR), showCalendar);\n  return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\n\nexport function TemporalMonthDayToString(\n  monthDay: Temporal.PlainMonthDay,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n  let resultString = `${month}-${day}`;\n  const calendar = GetSlot(monthDay, CALENDAR);\n  const calendarID = ToTemporalCalendarIdentifier(calendar);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendarID !== 'iso8601') {\n    const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n    resultString = `${year}-${resultString}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalYearMonthToString(\n  yearMonth: Temporal.PlainYearMonth,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n  let resultString = `${year}-${month}`;\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const calendarID = ToTemporalCalendarIdentifier(calendar);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendarID !== 'iso8601') {\n    const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n    resultString += `-${day}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalZonedDateTimeToString(\n  zdt: Temporal.ZonedDateTime,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision'],\n  showCalendar: ReturnType<typeof ToCalendarNameOption> = 'auto',\n  showTimeZone: ReturnType<typeof ToTimeZoneNameOption> = 'auto',\n  showOffset: ReturnType<typeof ToShowOffsetOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let instant = GetSlot(zdt, INSTANT);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    instant = new TemporalInstant(ns);\n  }\n\n  const tz = GetSlot(zdt, TIME_ZONE);\n  const dateTime = GetPlainDateTimeFor(tz, instant, 'iso8601');\n\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    precision\n  );\n  let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n  if (showOffset !== 'never') {\n    const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n    result += FormatISOTimeZoneOffsetString(offsetNs);\n  }\n  if (showTimeZone !== 'never') {\n    const identifier = ToTemporalTimeZoneIdentifier(tz);\n    const flag = showTimeZone === 'critical' ? '!' : '';\n    result += `[${flag}${identifier}]`;\n  }\n  result += MaybeFormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\n  return result;\n}\n\nexport function IsTimeZoneOffsetString(string: string) {\n  return OFFSET.test(StringCtor(string));\n}\n\nexport function ParseTimeZoneOffsetString(string: string): number {\n  const match = OFFSET.exec(StringCtor(string));\n  if (!match) {\n    throw new RangeError(`invalid time zone offset: ${string}`);\n  }\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n  const hours = +match[2];\n  const minutes = +(match[3] || 0);\n  const seconds = +(match[4] || 0);\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n  return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\n\nexport function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier: string): string {\n  if (IsTimeZoneOffsetString(timeZoneIdentifier)) {\n    const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n    return FormatTimeZoneOffsetString(offsetNs);\n  }\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n  return formatter.resolvedOptions().timeZone;\n}\n\nexport function GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: JSBI) {\n  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n    GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. To avoid overflowing at the edges of the range, we reduce the year\n  // to the remainder after dividing by 400, and then add back all the\n  // nanoseconds from the multiples of 400 years at the end.\n  const reducedYear = year % 400;\n  const yearCycles = (year - reducedYear) / 400;\n  const nsIn400YearCycle = JSBI.multiply(JSBI.BigInt(400 * 365 + 97), DAY_NANOS);\n\n  const reducedUTC = GetUTCEpochNanoseconds(\n    reducedYear,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  );\n  assertExists(reducedUTC);\n  const utc = JSBI.add(reducedUTC, JSBI.multiply(nsIn400YearCycle, JSBI.BigInt(yearCycles)));\n  return JSBI.toNumber(JSBI.subtract(utc, epochNanoseconds));\n}\n\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam: number): string {\n  const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n  const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n  const nanoseconds = offsetNanoseconds % 1e9;\n  const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n  const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  const secondString = ISODateTimePartString(seconds);\n  let post = '';\n  if (nanoseconds) {\n    let fraction = `${nanoseconds}`.padStart(9, '0');\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n    post = `:${secondString}.${fraction}`;\n  } else if (seconds) {\n    post = `:${secondString}`;\n  }\n  return `${sign}${hourString}:${minuteString}${post}`;\n}\n\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam: number): string {\n  let offsetNanoseconds = JSBI.toNumber(\n    RoundNumberToIncrement(JSBI.BigInt(offsetNanosecondsParam), MINUTE_NANOS, 'halfExpand')\n  );\n  const sign = offsetNanoseconds < 0 ? '-' : '+';\n  offsetNanoseconds = MathAbs(offsetNanoseconds);\n  const minutes = (offsetNanoseconds / 60e9) % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  return `${sign}${hourString}:${minuteString}`;\n}\nexport function GetUTCEpochNanoseconds(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  // Note: Date.UTC() interprets one and two-digit years as being in the\n  // 20th century, so don't use it\n  const legacyDate = new Date();\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\n  legacyDate.setUTCFullYear(year, month - 1, day);\n  const ms = legacyDate.getTime();\n  if (NumberIsNaN(ms)) return null;\n  let ns = JSBI.multiply(JSBI.BigInt(ms), MILLION);\n  ns = JSBI.add(ns, JSBI.multiply(JSBI.BigInt(microsecond), THOUSAND));\n  ns = JSBI.add(ns, JSBI.BigInt(nanosecond));\n  if (JSBI.lessThan(ns, NS_MIN) || JSBI.greaterThan(ns, NS_MAX)) return null;\n  return ns;\n}\n\nfunction GetISOPartsFromEpoch(epochNanoseconds: JSBI) {\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n  let epochMilliseconds = JSBI.toNumber(quotient);\n  let nanos = JSBI.toNumber(remainder);\n  if (nanos < 0) {\n    nanos += 1e6;\n    epochMilliseconds -= 1;\n  }\n  const microsecond = MathFloor(nanos / 1e3) % 1e3;\n  const nanosecond = nanos % 1e3;\n\n  const item = new Date(epochMilliseconds);\n  const year = item.getUTCFullYear();\n  const month = item.getUTCMonth() + 1;\n  const day = item.getUTCDate();\n  const hour = item.getUTCHours();\n  const minute = item.getUTCMinutes();\n  const second = item.getUTCSeconds();\n  const millisecond = item.getUTCMilliseconds();\n\n  return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: JSBI) {\n  const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction maxJSBI(one: JSBI, two: JSBI) {\n  return JSBI.lessThan(one, two) ? two : one;\n}\n\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n  return JSBI.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\n\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  if (JSBI.lessThan(epochNanoseconds, BEFORE_FIRST_OFFSET_TRANSITION)) {\n    return GetNamedTimeZoneNextTransition(id, BEFORE_FIRST_OFFSET_TRANSITION);\n  }\n  // Decide how far in the future after `epochNanoseconds` we'll look for an\n  // offset change. There are two cases:\n  // 1. If it's a past date (or a date in the near future) then it's possible\n  //    that the time zone may have newly added DST in the next few years. So\n  //    we'll have to look from the provided time until a few years after the\n  //    current system time. (Changes to DST policy are usually announced a few\n  //    years in the future.) Note that the first DST anywhere started in 1847,\n  //    so we'll start checks in 1847 instead of wasting cycles on years where\n  //    there will never be transitions.\n  // 2. If it's a future date beyond the next few years, then we'll just assume\n  //    that the latest DST policy in TZDB will still be in effect.  In this\n  //    case, we only need to look one year in the future to see if there are\n  //    any DST transitions.  We actually only need to look 9-10 months because\n  //    DST has two transitions per year, but we'll use a year just to be safe.\n  const oneYearLater = JSBI.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n  const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n  // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n  // start there if an earlier date is supplied.\n  let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n  const leftOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, leftNanos);\n  let rightNanos = leftNanos;\n  let rightOffsetNs = leftOffsetNs;\n  while (leftOffsetNs === rightOffsetNs && JSBI.lessThan(JSBI.BigInt(leftNanos), uppercap)) {\n    rightNanos = JSBI.add(leftNanos, TWO_WEEKS_NANOS);\n    if (JSBI.greaterThan(rightNanos, NS_MAX)) return null;\n    rightOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, rightNanos);\n    if (leftOffsetNs === rightOffsetNs) {\n      leftNanos = rightNanos;\n    }\n  }\n  if (leftOffsetNs === rightOffsetNs) return null;\n  const result = bisect(\n    (epochNs: JSBI) => GetNamedTimeZoneOffsetNanoseconds(id, epochNs),\n    leftNanos,\n    rightNanos,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return result;\n}\n\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n  // have to look back one year to find a transition. But if it doesn't use DST,\n  // then we need to look all the way back to 1847 (the earliest rule in the\n  // TZDB) to see if it had other offset transitions in the past. Looping back\n  // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n  // also unnecessary because DST rules aren't put into the TZDB more than a few\n  // years in the future because the political changes in time zones happen with\n  // only a few years' warning. Therefore, if a far-future date is provided,\n  // then we'll run the check in two parts:\n  // 1. First, we'll look back for up to one year to see if the latest TZDB\n  //    rules have DST.\n  // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n  //    current system time, and then look back to 1847. This reduces the\n  //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n  //    in worst-case perf.\n  const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n  const isFarFuture = JSBI.greaterThan(epochNanoseconds, afterLatestRule);\n  const lowercap = isFarFuture ? JSBI.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n\n  // TODO: proposal-temporal polyfill has different code for very similar\n  // optimizations as above, as well as in GetNamedTimeZonePreviousTransition.\n  // We should figure out if we should change one polyfill to match the other.\n\n  // We assume most time zones either have regular DST rules that extend\n  // indefinitely into the future, or they have no DST transitions between now\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\n  // that fit neither of these. Their irregular DST transitions are\n  // precomputed until 2087 in the current time zone database, so requesting\n  // the previous transition for an instant far in the future may take an\n  // extremely long time as it loops backward 2 weeks at a time.\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\n    const lastPrecomputed = GetSlot(ToTemporalInstant('2088-01-01T00Z'), EPOCHNANOSECONDS);\n    if (JSBI.lessThan(lastPrecomputed, epochNanoseconds)) {\n      return GetNamedTimeZonePreviousTransition(id, lastPrecomputed);\n    }\n  }\n\n  let rightNanos = JSBI.subtract(epochNanoseconds, ONE);\n  if (JSBI.lessThan(rightNanos, BEFORE_FIRST_OFFSET_TRANSITION)) return null;\n  const rightOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, rightNanos);\n  let leftNanos = rightNanos;\n  let leftOffsetNs = rightOffsetNs;\n  while (rightOffsetNs === leftOffsetNs && JSBI.greaterThan(rightNanos, lowercap)) {\n    leftNanos = JSBI.subtract(rightNanos, TWO_WEEKS_NANOS);\n    if (JSBI.lessThan(leftNanos, BEFORE_FIRST_OFFSET_TRANSITION)) return null;\n    leftOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, leftNanos);\n    if (rightOffsetNs === leftOffsetNs) {\n      rightNanos = leftNanos;\n    }\n  }\n  if (rightOffsetNs === leftOffsetNs) {\n    if (isFarFuture) {\n      // There was no DST after looking back one year, which means that the most\n      // recent TZDB rules don't have any recurring transitions. To check for\n      // transitions in older rules, back up to a few years after the current\n      // date and then look all the way back to 1847. Note that we move back one\n      // day from the latest possible rule so that when the recursion runs it\n      // won't consider the new time to be \"far future\" because the system clock\n      // has advanced in the meantime.\n      const newTimeToCheck = JSBI.subtract(afterLatestRule, DAY_NANOS);\n      return GetNamedTimeZonePreviousTransition(id, newTimeToCheck);\n    }\n    return null;\n  }\n  const result = bisect(\n    (epochNs: JSBI) => GetNamedTimeZoneOffsetNanoseconds(id, epochNs),\n    leftNanos,\n    rightNanos,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime: string) {\n  const parts = datetime.split(/[^\\w]+/);\n\n  if (parts.length !== 7) {\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\n  }\n\n  const month = +parts[0];\n  const day = +parts[1];\n  let year = +parts[2];\n  const era = parts[3].toUpperCase();\n  if (era === 'B' || era === 'BC') {\n    year = -year + 1;\n  } else if (era !== 'A' && era !== 'AD') {\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n  }\n  let hour = +parts[4];\n  if (hour === 24) {\n    // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n    hour = 0;\n  }\n  const minute = +parts[5];\n  const second = +parts[6];\n\n  if (\n    !NumberIsFinite(year) ||\n    !NumberIsFinite(month) ||\n    !NumberIsFinite(day) ||\n    !NumberIsFinite(hour) ||\n    !NumberIsFinite(minute) ||\n    !NumberIsFinite(second)\n  ) {\n    throw new RangeError(`Invalid number in \"${datetime}`);\n  }\n\n  return { year, month, day, hour, minute, second };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n  // Using `format` instead of `formatToParts` for compatibility with older clients\n  const datetime = formatter.format(new Date(epochMilliseconds));\n  return parseFromEnUsFormat(datetime);\n}\n\nexport function GetNamedTimeZoneEpochNanoseconds(\n  id: string,\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  const ns = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (ns === null) throw new RangeError('DateTime outside of supported range');\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS);\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\n  let nsLater = JSBI.add(ns, DAY_NANOS);\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\n  const earliest = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\n  const latest = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\n  const found = earliest === latest ? [earliest] : [earliest, latest];\n  return found\n    .map((offsetNanoseconds) => {\n      const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n      const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n      if (\n        year !== parts.year ||\n        month !== parts.month ||\n        day !== parts.day ||\n        hour !== parts.hour ||\n        minute !== parts.minute ||\n        second !== parts.second ||\n        millisecond !== parts.millisecond ||\n        microsecond !== parts.microsecond ||\n        nanosecond !== parts.nanosecond\n      ) {\n        return undefined;\n      }\n      return epochNanoseconds;\n    })\n    .filter((x) => x !== undefined) as JSBI[];\n}\n\nexport function LeapYear(year: number) {\n  if (undefined === year) return false;\n  const isDiv4 = year % 4 === 0;\n  const isDiv100 = year % 100 === 0;\n  const isDiv400 = year % 400 === 0;\n  return isDiv4 && (!isDiv100 || isDiv400);\n}\n\nexport function ISODaysInMonth(year: number, month: number) {\n  const DoM = {\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  };\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\n\nexport function DayOfWeek(year: number, month: number, day: number) {\n  const m = month + (month < 3 ? 10 : -2);\n  const Y = year - (month < 3 ? 1 : 0);\n\n  const c = MathFloor(Y / 100);\n  const y = Y - c * 100;\n  const d = day;\n\n  const pD = d;\n  const pM = MathFloor(2.6 * m - 0.2);\n  const pY = y + MathFloor(y / 4);\n  const pC = MathFloor(c / 4) - 2 * c;\n\n  const dow = (pD + pM + pY + pC) % 7;\n\n  return dow + (dow <= 0 ? 7 : 0);\n}\n\nexport function DayOfYear(year: number, month: number, day: number) {\n  let days = day;\n  for (let m = month - 1; m > 0; m--) {\n    days += ISODaysInMonth(year, m);\n  }\n  return days;\n}\n\nexport function WeekOfYear(year: number, month: number, day: number) {\n  const doy = DayOfYear(year, month, day);\n  const dow = DayOfWeek(year, month, day) || 7;\n  const doj = DayOfWeek(year, 1, 1);\n\n  const week = MathFloor((doy - dow + 10) / 7);\n\n  if (week < 1) {\n    if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n      return { week: 53, year: year - 1 };\n    } else {\n      return { week: 52, year: year - 1 };\n    }\n  }\n  if (week === 53) {\n    if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n      return { week: 1, year: year + 1 };\n    }\n  }\n\n  return { week, year };\n}\n\nexport function DurationSign(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n  return 0;\n}\n\nfunction BalanceISOYearMonth(yearParam: number, monthParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  if (!NumberIsFinite(year) || !NumberIsFinite(month)) throw new RangeError('infinity is out of range');\n  month -= 1;\n  year += MathFloor(month / 12);\n  month %= 12;\n  if (month < 0) month += 12;\n  month += 1;\n  return { year, month };\n}\n\nfunction BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  if (!NumberIsFinite(day)) throw new RangeError('infinity is out of range');\n  ({ year, month } = BalanceISOYearMonth(year, month));\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. So if we have more than 400 years in days, there's no need to\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\n  // once.\n  const daysIn400YearCycle = 400 * 365 + 97;\n  if (MathAbs(day) > daysIn400YearCycle) {\n    const nCycles = MathTrunc(day / daysIn400YearCycle);\n    year += 400 * nCycles;\n    day -= nCycles * daysIn400YearCycle;\n  }\n\n  let daysInYear = 0;\n  let testYear = month > 2 ? year : year - 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n    year -= 1;\n    testYear -= 1;\n    day += daysInYear;\n  }\n  testYear += 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n    year += 1;\n    testYear += 1;\n    day -= daysInYear;\n  }\n\n  while (day < 1) {\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\n    day += ISODaysInMonth(year, month);\n  }\n  while (day > ISODaysInMonth(year, month)) {\n    day -= ISODaysInMonth(year, month);\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\n  }\n\n  return { year, month, day };\n}\n\nfunction BalanceISODateTime(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam\n  );\n  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nfunction BalanceTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  let hour = JSBI.BigInt(hourParam);\n  let minute = JSBI.BigInt(minuteParam);\n  let second = JSBI.BigInt(secondParam);\n  let millisecond = JSBI.BigInt(millisecondParam);\n  let microsecond = JSBI.BigInt(microsecondParam);\n  let nanosecond = JSBI.BigInt(nanosecondParam);\n  let quotient;\n\n  ({ quotient, remainder: nanosecond } = NonNegativeBigIntDivmod(nanosecond, THOUSAND));\n  microsecond = JSBI.add(microsecond, quotient);\n\n  ({ quotient, remainder: microsecond } = NonNegativeBigIntDivmod(microsecond, THOUSAND));\n  millisecond = JSBI.add(millisecond, quotient);\n\n  ({ quotient, remainder: millisecond } = NonNegativeBigIntDivmod(millisecond, THOUSAND));\n  second = JSBI.add(second, quotient);\n\n  ({ quotient, remainder: second } = NonNegativeBigIntDivmod(second, SIXTY));\n  minute = JSBI.add(minute, quotient);\n\n  ({ quotient, remainder: minute } = NonNegativeBigIntDivmod(minute, SIXTY));\n  hour = JSBI.add(hour, quotient);\n\n  ({ quotient, remainder: hour } = NonNegativeBigIntDivmod(hour, TWENTY_FOUR));\n\n  return {\n    deltaDays: JSBI.toNumber(quotient),\n    hour: JSBI.toNumber(hour),\n    minute: JSBI.toNumber(minute),\n    second: JSBI.toNumber(second),\n    millisecond: JSBI.toNumber(millisecond),\n    microsecond: JSBI.toNumber(microsecond),\n    nanosecond: JSBI.toNumber(nanosecond)\n  };\n}\n\nexport function TotalDurationNanoseconds(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  offsetShift: number\n) {\n  const days: JSBI = JSBI.BigInt(daysParam);\n  let nanoseconds: JSBI = JSBI.BigInt(nanosecondsParam);\n  if (daysParam !== 0) nanoseconds = JSBI.subtract(JSBI.BigInt(nanosecondsParam), JSBI.BigInt(offsetShift));\n  const hours = JSBI.add(JSBI.BigInt(hoursParam), JSBI.multiply(days, JSBI.BigInt(24)));\n  const minutes = JSBI.add(JSBI.BigInt(minutesParam), JSBI.multiply(hours, SIXTY));\n  const seconds = JSBI.add(JSBI.BigInt(secondsParam), JSBI.multiply(minutes, SIXTY));\n  const milliseconds = JSBI.add(JSBI.BigInt(millisecondsParam), JSBI.multiply(seconds, THOUSAND));\n  const microseconds = JSBI.add(JSBI.BigInt(microsecondsParam), JSBI.multiply(milliseconds, THOUSAND));\n  return JSBI.add(JSBI.BigInt(nanoseconds), JSBI.multiply(microseconds, THOUSAND));\n}\n\nfunction NanosecondsToDays(nanosecondsParam: JSBI, relativeTo: ReturnType<typeof ToRelativeTemporalObject>) {\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const sign = MathSign(JSBI.toNumber(nanosecondsParam));\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  let dayLengthNs = 86400e9;\n  if (sign === 0) return { days: 0, nanoseconds: ZERO, dayLengthNs };\n  if (!IsTemporalZonedDateTime(relativeTo)) {\n    let days: JSBI;\n    ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, JSBI.BigInt(dayLengthNs)));\n    return { days: JSBI.toNumber(days), nanoseconds, dayLengthNs };\n  }\n\n  const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n  const start = GetSlot(relativeTo, INSTANT);\n  const endNs = JSBI.add(startNs, nanoseconds);\n  const end = new TemporalInstant(endNs);\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n\n  // Find the difference in days only.\n  const dtStart = GetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = GetPlainDateTimeFor(timeZone, end, calendar);\n  let { days: daysNumber } = DifferenceISODateTime(\n    GetSlot(dtStart, ISO_YEAR),\n    GetSlot(dtStart, ISO_MONTH),\n    GetSlot(dtStart, ISO_DAY),\n    GetSlot(dtStart, ISO_HOUR),\n    GetSlot(dtStart, ISO_MINUTE),\n    GetSlot(dtStart, ISO_SECOND),\n    GetSlot(dtStart, ISO_MILLISECOND),\n    GetSlot(dtStart, ISO_MICROSECOND),\n    GetSlot(dtStart, ISO_NANOSECOND),\n    GetSlot(dtEnd, ISO_YEAR),\n    GetSlot(dtEnd, ISO_MONTH),\n    GetSlot(dtEnd, ISO_DAY),\n    GetSlot(dtEnd, ISO_HOUR),\n    GetSlot(dtEnd, ISO_MINUTE),\n    GetSlot(dtEnd, ISO_SECOND),\n    GetSlot(dtEnd, ISO_MILLISECOND),\n    GetSlot(dtEnd, ISO_MICROSECOND),\n    GetSlot(dtEnd, ISO_NANOSECOND),\n    calendar,\n    'day',\n    ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n  );\n  let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, daysNumber, 0, 0, 0, 0, 0, 0);\n  // may disambiguate\n\n  // If clock time after addition was in the middle of a skipped period, the\n  // endpoint was disambiguated to a later clock time. So it's possible that\n  // the resulting disambiguated result is later than endNs. If so, then back\n  // up one day and try again. Repeat if necessary (some transitions are\n  // > 24 hours) until either there's zero days left or the date duration is\n  // back inside the period where it belongs. Note that this case only can\n  // happen for positive durations because the only direction that\n  // `disambiguation: 'compatible'` can change clock time is forwards.\n  let daysBigInt = JSBI.BigInt(daysNumber);\n  if (sign === 1) {\n    while (JSBI.greaterThan(daysBigInt, ZERO) && JSBI.greaterThan(intermediateNs, endNs)) {\n      daysBigInt = JSBI.subtract(daysBigInt, ONE);\n      intermediateNs = AddZonedDateTime(\n        start,\n        timeZone,\n        calendar,\n        0,\n        0,\n        0,\n        JSBI.toNumber(daysBigInt),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      );\n      // may do disambiguation\n    }\n  }\n  nanoseconds = JSBI.subtract(endNs, intermediateNs);\n\n  let isOverflow = false;\n  let relativeInstant = new TemporalInstant(intermediateNs);\n  do {\n    // calculate length of the next day (day that contains the time remainder)\n    const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n    const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n    dayLengthNs = JSBI.toNumber(JSBI.subtract(oneDayFartherNs, relativeNs));\n    isOverflow = JSBI.greaterThanOrEqual(\n      JSBI.multiply(JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs)), JSBI.BigInt(sign)),\n      ZERO\n    );\n    if (isOverflow) {\n      nanoseconds = JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs));\n      relativeInstant = new TemporalInstant(oneDayFartherNs);\n      daysBigInt = JSBI.add(daysBigInt, JSBI.BigInt(sign));\n    }\n  } while (isOverflow);\n  if (!isZero(daysBigInt) && signJSBI(daysBigInt) !== sign) {\n    throw new RangeError('Time zone or calendar converted nanoseconds into a number of days with the opposite sign');\n  }\n  if (!isZero(nanoseconds) && signJSBI(nanoseconds) !== sign) {\n    if (isNegativeJSBI(nanoseconds) && sign === 1) {\n      throw new Error('assert not reached');\n    }\n    throw new RangeError('Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign');\n  }\n  if (JSBI.greaterThanOrEqual(abs(nanoseconds), abs(JSBI.BigInt(dayLengthNs)))) {\n    throw new Error('assert not reached');\n  }\n  return { days: JSBI.toNumber(daysBigInt), nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\n\nexport function BalanceDuration(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let result = BalancePossiblyInfiniteDuration(\n    daysParam,\n    hoursParam,\n    minutesParam,\n    secondsParam,\n    millisecondsParam,\n    microsecondsParam,\n    nanosecondsParam,\n    largestUnit,\n    relativeTo\n  );\n  if (result === 'positive overflow' || result === 'negative overflow') {\n    throw new RangeError('Duration out of range');\n  } else {\n    return result;\n  }\n}\n\nexport function BalancePossiblyInfiniteDuration(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let days = daysParam;\n  let nanosecondsBigInt: JSBI,\n    microsecondsBigInt: JSBI,\n    millisecondsBigInt: JSBI,\n    secondsBigInt: JSBI,\n    minutesBigInt: JSBI,\n    hoursBigInt: JSBI;\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const endNs = AddZonedDateTime(\n      GetSlot(relativeTo, INSTANT),\n      GetSlot(relativeTo, TIME_ZONE),\n      GetSlot(relativeTo, CALENDAR),\n      0,\n      0,\n      0,\n      days,\n      hoursParam,\n      minutesParam,\n      secondsParam,\n      millisecondsParam,\n      microsecondsParam,\n      nanosecondsParam\n    );\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    nanosecondsBigInt = JSBI.subtract(endNs, startNs);\n  } else {\n    nanosecondsBigInt = TotalDurationNanoseconds(\n      days,\n      hoursParam,\n      minutesParam,\n      secondsParam,\n      millisecondsParam,\n      microsecondsParam,\n      nanosecondsParam,\n      0\n    );\n  }\n  if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n    ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n  } else {\n    days = 0;\n  }\n\n  const sign = JSBI.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n  nanosecondsBigInt = abs(nanosecondsBigInt);\n  microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n\n  switch (largestUnit) {\n    case 'year':\n    case 'month':\n    case 'week':\n    case 'day':\n    case 'hour':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n      ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n      break;\n    case 'minute':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n      break;\n    case 'second':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      break;\n    case 'millisecond':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      break;\n    case 'microsecond':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      break;\n    case 'nanosecond':\n      break;\n    default:\n      throw new Error('assert not reached');\n  }\n\n  const hours = JSBI.toNumber(hoursBigInt) * sign;\n  const minutes = JSBI.toNumber(minutesBigInt) * sign;\n  const seconds = JSBI.toNumber(secondsBigInt) * sign;\n  const milliseconds = JSBI.toNumber(millisecondsBigInt) * sign;\n  const microseconds = JSBI.toNumber(microsecondsBigInt) * sign;\n  const nanoseconds = JSBI.toNumber(nanosecondsBigInt) * sign;\n\n  for (const prop of [days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n    if (!NumberIsFinite(prop)) {\n      if (sign === 1) {\n        return 'positive overflow' as const;\n      } else {\n        return 'negative overflow' as const;\n      }\n    }\n  }\n\n  return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nexport function UnbalanceDurationRelative(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject>\n): {\n  years: number;\n  months: number;\n  weeks: number;\n  days: number;\n} {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(yearsParam, monthsParam, weeksParam, daysParam, 0, 0, 0, 0, 0, 0);\n  if (sign === 0) return { years: yearsParam, months: monthsParam, weeks: weeksParam, days: daysParam };\n  const signBI = JSBI.BigInt(sign);\n\n  let years = JSBI.BigInt(yearsParam);\n  let months = JSBI.BigInt(monthsParam);\n  let weeks = JSBI.BigInt(weeksParam);\n  let days = JSBI.BigInt(daysParam);\n\n  let calendar;\n  let relativeTo: Temporal.PlainDate | undefined;\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year':\n      // no-op\n      break;\n    case 'month':\n      {\n        if (!calendar) throw new RangeError('a starting point is required for months balancing');\n        assertExists(relativeTo);\n        // balance years down to months\n        let dateAdd, dateUntil;\n        if (typeof calendar !== 'string') {\n          dateAdd = GetMethod(calendar, 'dateAdd');\n          dateUntil = GetMethod(calendar, 'dateUntil');\n        }\n        while (!isZero(years)) {\n          const newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n          const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<typeof largestUnit>;\n          untilOptions.largestUnit = 'month';\n          const untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n          const oneYearMonths = JSBI.BigInt(GetSlot(untilResult, MONTHS));\n          relativeTo = newRelativeTo;\n          months = JSBI.add(months, oneYearMonths);\n          years = JSBI.subtract(years, signBI);\n        }\n      }\n      break;\n    case 'week': {\n      if (!calendar) throw new RangeError('a starting point is required for weeks balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance years down to days\n      while (!isZero(years)) {\n        let oneYearDays;\n        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.subtract(years, signBI);\n      }\n\n      // balance months down to days\n      while (!isZero(months)) {\n        let oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.subtract(months, signBI);\n      }\n      break;\n    }\n    default: {\n      // balance years down to days\n      if (isZero(years) && isZero(months) && isZero(weeks)) break;\n      if (!calendar) throw new RangeError('a starting point is required for balancing calendar units');\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      while (!isZero(years)) {\n        assertExists(relativeTo);\n        let oneYearDays;\n        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.subtract(years, signBI);\n      }\n\n      // balance months down to days\n      while (!isZero(months)) {\n        assertExists(relativeTo);\n        let oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.subtract(months, signBI);\n      }\n\n      // balance weeks down to days\n      while (!isZero(weeks)) {\n        assertExists(relativeTo);\n        let oneWeekDays;\n        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneWeekDays));\n        weeks = JSBI.subtract(weeks, signBI);\n      }\n      break;\n    }\n  }\n\n  return {\n    years: JSBI.toNumber(years),\n    months: JSBI.toNumber(months),\n    weeks: JSBI.toNumber(weeks),\n    days: JSBI.toNumber(days)\n  };\n}\n\nexport function BalanceDurationRelative(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject>\n): {\n  years: number;\n  months: number;\n  weeks: number;\n  days: number;\n} {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(yearsParam, monthsParam, weeksParam, daysParam, 0, 0, 0, 0, 0, 0);\n  if (sign === 0) return { years: yearsParam, months: monthsParam, weeks: weeksParam, days: daysParam };\n  const signBI = JSBI.BigInt(sign);\n\n  let years = JSBI.BigInt(yearsParam);\n  let months = JSBI.BigInt(monthsParam);\n  let weeks = JSBI.BigInt(weeksParam);\n  let days = JSBI.BigInt(daysParam);\n\n  let calendar;\n  let relativeTo: Temporal.PlainDate | undefined;\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year': {\n      if (!calendar) throw new RangeError('a starting point is required for years balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to years\n      let newRelativeTo, oneYearDays;\n      ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneYearDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.add(years, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n      }\n\n      // balance days up to months\n      let oneMonthDays;\n      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneMonthDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.add(months, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n\n      // balance months up to years\n      newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n      const dateUntil = typeof calendar !== 'string' ? GetMethod(calendar, 'dateUntil') : undefined;\n      const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<'month'>;\n      untilOptions.largestUnit = 'month';\n      let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n      let oneYearMonths = GetSlot(untilResult, MONTHS);\n      while (JSBI.greaterThanOrEqual(abs(months), JSBI.BigInt(MathAbs(oneYearMonths)))) {\n        months = JSBI.subtract(months, JSBI.BigInt(oneYearMonths));\n        years = JSBI.add(years, signBI);\n        relativeTo = newRelativeTo;\n        newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n        const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<'month'>;\n        untilOptions.largestUnit = 'month';\n        untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n        oneYearMonths = GetSlot(untilResult, MONTHS);\n      }\n      break;\n    }\n    case 'month': {\n      if (!calendar) throw new RangeError('a starting point is required for months balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to months\n      let newRelativeTo, oneMonthDays;\n      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneMonthDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.add(months, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n      break;\n    }\n    case 'week': {\n      if (!calendar) throw new RangeError('a starting point is required for weeks balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to weeks\n      let newRelativeTo, oneWeekDays;\n      ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneWeekDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneWeekDays));\n        weeks = JSBI.add(weeks, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      }\n      break;\n    }\n    default:\n      // no-op\n      break;\n  }\n\n  return {\n    years: JSBI.toNumber(years),\n    months: JSBI.toNumber(months),\n    weeks: JSBI.toNumber(weeks),\n    days: JSBI.toNumber(days)\n  };\n}\n\nexport function CalculateOffsetShift(\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>,\n  y: number,\n  mon: number,\n  w: number,\n  d: number\n) {\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const instant = GetSlot(relativeTo, INSTANT);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n    const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instantAfter = new TemporalInstant(after);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n    return offsetAfter - offsetBefore;\n  }\n  return 0;\n}\n\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    -GetSlot(duration, YEARS),\n    -GetSlot(duration, MONTHS),\n    -GetSlot(duration, WEEKS),\n    -GetSlot(duration, DAYS),\n    -GetSlot(duration, HOURS),\n    -GetSlot(duration, MINUTES),\n    -GetSlot(duration, SECONDS),\n    -GetSlot(duration, MILLISECONDS),\n    -GetSlot(duration, MICROSECONDS),\n    -GetSlot(duration, NANOSECONDS)\n  );\n}\n\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\n  // used for optional params in the method below.\n  return MathMin(max, MathMax(min, value as number));\n}\nfunction ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\n  const month = ConstrainToRange(monthParam, 1, 12);\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n  return { year, month, day };\n}\n\nfunction ConstrainTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  const hour = ConstrainToRange(hourParam, 0, 23);\n  const minute = ConstrainToRange(minuteParam, 0, 59);\n  const second = ConstrainToRange(secondParam, 0, 59);\n  const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n  const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n  const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RejectToRange(value: number, min: number, max: number) {\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\n\nfunction RejectISODate(year: number, month: number, day: number) {\n  RejectToRange(month, 1, 12);\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\n\nfunction RejectDateRange(year: number, month: number, day: number) {\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\n  RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\n\nexport function RejectTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(hour, 0, 23);\n  RejectToRange(minute, 0, 59);\n  RejectToRange(second, 0, 59);\n  RejectToRange(millisecond, 0, 999);\n  RejectToRange(microsecond, 0, 999);\n  RejectToRange(nanosecond, 0, 999);\n}\n\nfunction RejectDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectISODate(year, month, day);\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction RejectDateTimeRange(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  // Reject any DateTime 24 hours or more outside the Instant range\n  if (\n    (year === YEAR_MIN &&\n      null ==\n        GetUTCEpochNanoseconds(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n    (year === YEAR_MAX &&\n      null ==\n        GetUTCEpochNanoseconds(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))\n  ) {\n    throw new RangeError('DateTime outside of supported range');\n  }\n}\n\nexport function ValidateEpochNanoseconds(epochNanoseconds: JSBI) {\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n    throw new RangeError('Instant outside of supported range');\n  }\n}\n\nfunction RejectYearMonthRange(year: number, month: number) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  if (year === YEAR_MIN) {\n    RejectToRange(month, 4, 12);\n  } else if (year === YEAR_MAX) {\n    RejectToRange(month, 1, 9);\n  }\n}\n\nexport function RejectDuration(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  const sign = DurationSign(y, mon, w, d, h, min, s, ms, µs, ns);\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (!NumberIsFinite(prop)) throw new RangeError('infinite values not allowed as duration fields');\n    const propSign = MathSign(prop);\n    if (propSign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\n  }\n}\n\nexport function DifferenceISODate<Allowed extends Temporal.DateTimeUnit>(\n  y1: number,\n  m1: number,\n  d1: number,\n  y2: number,\n  m2: number,\n  d2: number,\n  largestUnit: Allowed\n) {\n  switch (largestUnit) {\n    case 'year':\n    case 'month': {\n      const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n      if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\n\n      const start = { year: y1, month: m1, day: d1 };\n      const end = { year: y2, month: m2, day: d2 };\n\n      let years = end.year - start.year;\n      let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n      let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n      if (midSign === 0) {\n        return largestUnit === 'year'\n          ? { years, months: 0, weeks: 0, days: 0 }\n          : { years: 0, months: years * 12, weeks: 0, days: 0 };\n      }\n      let months = end.month - start.month;\n      if (midSign !== sign) {\n        years -= sign;\n        months += sign * 12;\n      }\n      mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n      midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n      if (midSign === 0) {\n        return largestUnit === 'year'\n          ? { years, months, weeks: 0, days: 0 }\n          : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n      }\n      if (midSign !== sign) {\n        // The end date is later in the month than mid date (or earlier for\n        // negative durations). Back up one month.\n        months -= sign;\n        if (months === -sign) {\n          years -= sign;\n          months = 11 * sign;\n        }\n        mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n      }\n\n      let days = 0;\n      // If we get here, months and years are correct (no overflow), and `mid`\n      // is within the range from `start` to `end`. To count the days between\n      // `mid` and `end`, there are 3 cases:\n      // 1) same month: use simple subtraction\n      // 2) end is previous month from intermediate (negative duration)\n      // 3) end is next month from intermediate (positive duration)\n      if (mid.month === end.month) {\n        // 1) same month: use simple subtraction\n        days = end.day - mid.day;\n      } else if (sign < 0) {\n        // 2) end is previous month from intermediate (negative duration)\n        // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n        days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n      } else {\n        // 3) end is next month from intermediate (positive duration)\n        // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n        days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n      }\n\n      if (largestUnit === 'month') {\n        months += years * 12;\n        years = 0;\n      }\n      return { years, months, weeks: 0, days };\n    }\n    case 'week':\n    case 'day': {\n      let larger, smaller, sign;\n      if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n        smaller = { year: y1, month: m1, day: d1 };\n        larger = { year: y2, month: m2, day: d2 };\n        sign = 1;\n      } else {\n        smaller = { year: y2, month: m2, day: d2 };\n        larger = { year: y1, month: m1, day: d1 };\n        sign = -1;\n      }\n      let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n      for (let year = smaller.year; year < larger.year; ++year) {\n        days += LeapYear(year) ? 366 : 365;\n      }\n      let weeks = 0;\n      if (largestUnit === 'week') {\n        weeks = MathFloor(days / 7);\n        days %= 7;\n      }\n      weeks *= sign;\n      days *= sign;\n      return { years: 0, months: 0, weeks, days };\n    }\n    default:\n      throw new Error('assert not reached');\n  }\n}\n\nfunction DifferenceTime(\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number\n) {\n  let hours = h2 - h1;\n  let minutes = min2 - min1;\n  let seconds = s2 - s1;\n  let milliseconds = ms2 - ms1;\n  let microseconds = µs2 - µs1;\n  let nanoseconds = ns2 - ns1;\n\n  const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n\n  let deltaDays = 0;\n  ({\n    deltaDays,\n    hour: hours,\n    minute: minutes,\n    second: seconds,\n    millisecond: milliseconds,\n    microsecond: microseconds,\n    nanosecond: nanoseconds\n  } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n\n  if (deltaDays != 0) throw new Error('assertion failure in DifferenceTime: _bt_.[[Days]] should be 0');\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n\n  return { hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction DifferenceInstant(\n  ns1: JSBI,\n  ns2: JSBI,\n  increment: number,\n  smallestUnit: keyof typeof nsPerTimeUnit,\n  largestUnit: keyof typeof nsPerTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  const diff = JSBI.subtract(ns2, ns1);\n\n  let hours = 0;\n  let minutes = 0;\n  let nanoseconds = JSBI.toNumber(JSBI.remainder(diff, THOUSAND));\n  let microseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(diff, THOUSAND), THOUSAND));\n  let milliseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(diff, MILLION), THOUSAND));\n  let seconds = JSBI.toNumber(JSBI.divide(diff, BILLION));\n\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    increment,\n    smallestUnit,\n    roundingMode\n  ));\n  return BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit);\n}\n\nfunction DifferenceISODateTime(\n  y1Param: number,\n  mon1Param: number,\n  d1Param: number,\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  y2: number,\n  mon2: number,\n  d2: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number,\n  calendar: CalendarSlot,\n  largestUnit: Temporal.DateTimeUnit,\n  options: Temporal.DifferenceOptions<Temporal.DateTimeUnit> | undefined\n) {\n  let y1 = y1Param;\n  let mon1 = mon1Param;\n  let d1 = d1Param;\n\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(\n    h1,\n    min1,\n    s1,\n    ms1,\n    µs1,\n    ns1,\n    h2,\n    min2,\n    s2,\n    ms2,\n    µs2,\n    ns2\n  );\n\n  const timeSign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n  if (dateSign === -timeSign) {\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      -timeSign,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      largestUnit\n    ));\n  }\n\n  const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n  const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n  const untilOptions = CopyOptions(options);\n  untilOptions.largestUnit = dateLargestUnit;\n  // TODO untilOptions doesn't want to compile as it seems that smallestUnit is not clamped?\n  // Type 'SmallestUnit<DateTimeUnit> | undefined' is not assignable to type\n  //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.\n  // Type '\"hour\"' is not assignable to type\n  //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.ts(2345)\n  let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions as any);\n  // Signs of date part and time part may not agree; balance them together\n  ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    largestUnit\n  ));\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction DifferenceZonedDateTime(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot,\n  largestUnit: Temporal.DateTimeUnit,\n  options: Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n) {\n  const nsDiff = JSBI.subtract(ns2, ns1);\n  if (JSBI.equal(nsDiff, ZERO)) {\n    return {\n      years: 0,\n      months: 0,\n      weeks: 0,\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0,\n      microseconds: 0,\n      nanoseconds: 0\n    };\n  }\n\n  // Find the difference in dates only.\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const start = new TemporalInstant(ns1);\n  const end = new TemporalInstant(ns2);\n  const dtStart = GetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = GetPlainDateTimeFor(timeZone, end, calendar);\n  let { years, months, weeks, days } = DifferenceISODateTime(\n    GetSlot(dtStart, ISO_YEAR),\n    GetSlot(dtStart, ISO_MONTH),\n    GetSlot(dtStart, ISO_DAY),\n    GetSlot(dtStart, ISO_HOUR),\n    GetSlot(dtStart, ISO_MINUTE),\n    GetSlot(dtStart, ISO_SECOND),\n    GetSlot(dtStart, ISO_MILLISECOND),\n    GetSlot(dtStart, ISO_MICROSECOND),\n    GetSlot(dtStart, ISO_NANOSECOND),\n    GetSlot(dtEnd, ISO_YEAR),\n    GetSlot(dtEnd, ISO_MONTH),\n    GetSlot(dtEnd, ISO_DAY),\n    GetSlot(dtEnd, ISO_HOUR),\n    GetSlot(dtEnd, ISO_MINUTE),\n    GetSlot(dtEnd, ISO_SECOND),\n    GetSlot(dtEnd, ISO_MILLISECOND),\n    GetSlot(dtEnd, ISO_MICROSECOND),\n    GetSlot(dtEnd, ISO_NANOSECOND),\n    calendar,\n    largestUnit,\n    options\n  );\n  const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n  // may disambiguate\n  let timeRemainderNs = JSBI.subtract(ns2, intermediateNs);\n  const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n  ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n\n  // Finally, merge the date and time durations and return the merged result.\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    JSBI.toNumber(timeRemainderNs),\n    'hour'\n  );\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\ntype DifferenceOperation = 'since' | 'until';\n\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\n  op: DifferenceOperation,\n  options: Temporal.DifferenceOptions<T>,\n  group: 'datetime' | 'date' | 'time',\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\n  fallbackSmallest: T,\n  smallestLargestDefaultUnit: T\n) {\n  const ALLOWED_UNITS = SINGULAR_PLURAL_UNITS.reduce((allowed, unitInfo) => {\n    const p = unitInfo[0];\n    const s = unitInfo[1];\n    const c = unitInfo[2];\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\n      allowed.push(s, p);\n    }\n    return allowed;\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\n\n  let largestUnit = GetTemporalUnit(options, 'largestUnit', group, 'auto');\n  if (disallowed.includes(largestUnit)) {\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\n  }\n\n  const roundingIncrement = ToTemporalRoundingIncrement(options);\n\n  let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n  if (op === 'since') roundingMode = NegateTemporalRoundingMode(roundingMode);\n\n  const smallestUnit = GetTemporalUnit(options, 'smallestUnit', group, fallbackSmallest);\n  if (disallowed.includes(smallestUnit)) {\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\n  }\n\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n  }\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n  };\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\n}\n\nexport function DifferenceTemporalInstant(\n  operation: DifferenceOperation,\n  instant: Temporal.Instant,\n  otherParam: InstantParams['until'][0],\n  options: InstantParams['until'][1] | undefined\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalInstant(otherParam);\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\n\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n    onens,\n    twons,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.largestUnit,\n    settings.roundingMode\n  );\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    0,\n    0,\n    0,\n    0,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainDate(\n  operation: DifferenceOperation,\n  plainDate: Temporal.PlainDate,\n  otherParam: PlainDateParams['until'][0],\n  options: PlainDateParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalDate(otherParam);\n  const calendar = GetSlot(plainDate, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  let { years, months, weeks, days } = CalendarDateUntil(calendar, plainDate, other, resolvedOptions);\n\n  if (settings.smallestUnit !== 'day' || settings.roundingIncrement !== 1) {\n    ({ years, months, weeks, days } = RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      plainDate\n    ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(sign * years, sign * months, sign * weeks, sign * days, 0, 0, 0, 0, 0, 0);\n}\n\nexport function DifferenceTemporalPlainDateTime(\n  operation: DifferenceOperation,\n  plainDateTime: Temporal.PlainDateTime,\n  otherParam: PlainDateTimeParams['until'][0],\n  options: PlainDateTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalDateTime(otherParam);\n  const calendar = GetSlot(plainDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\n\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    DifferenceISODateTime(\n      GetSlot(plainDateTime, ISO_YEAR),\n      GetSlot(plainDateTime, ISO_MONTH),\n      GetSlot(plainDateTime, ISO_DAY),\n      GetSlot(plainDateTime, ISO_HOUR),\n      GetSlot(plainDateTime, ISO_MINUTE),\n      GetSlot(plainDateTime, ISO_SECOND),\n      GetSlot(plainDateTime, ISO_MILLISECOND),\n      GetSlot(plainDateTime, ISO_MICROSECOND),\n      GetSlot(plainDateTime, ISO_NANOSECOND),\n      GetSlot(other, ISO_YEAR),\n      GetSlot(other, ISO_MONTH),\n      GetSlot(other, ISO_DAY),\n      GetSlot(other, ISO_HOUR),\n      GetSlot(other, ISO_MINUTE),\n      GetSlot(other, ISO_SECOND),\n      GetSlot(other, ISO_MILLISECOND),\n      GetSlot(other, ISO_MICROSECOND),\n      GetSlot(other, ISO_NANOSECOND),\n      calendar,\n      settings.largestUnit,\n      resolvedOptions\n    );\n\n  const relativeTo = TemporalDateTimeToDate(plainDateTime);\n  ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode,\n    relativeTo\n  ));\n  ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.largestUnit\n  ));\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainTime(\n  operation: DifferenceOperation,\n  plainTime: Temporal.PlainTime,\n  otherParam: PlainTimeParams['until'][0],\n  options: PlainTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalTime(otherParam);\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\n\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(\n    GetSlot(plainTime, ISO_HOUR),\n    GetSlot(plainTime, ISO_MINUTE),\n    GetSlot(plainTime, ISO_SECOND),\n    GetSlot(plainTime, ISO_MILLISECOND),\n    GetSlot(plainTime, ISO_MICROSECOND),\n    GetSlot(plainTime, ISO_NANOSECOND),\n    GetSlot(other, ISO_HOUR),\n    GetSlot(other, ISO_MINUTE),\n    GetSlot(other, ISO_SECOND),\n    GetSlot(other, ISO_MILLISECOND),\n    GetSlot(other, ISO_MICROSECOND),\n    GetSlot(other, ISO_NANOSECOND)\n  );\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    0,\n    0,\n    0,\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  ));\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.largestUnit\n  ));\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    0,\n    0,\n    0,\n    0,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainYearMonth(\n  operation: DifferenceOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  otherParam: PlainYearMonthParams['until'][0],\n  options: PlainYearMonthParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalYearMonth(otherParam);\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between months');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  const fieldNames = CalendarFields(calendar, ['monthCode', 'year']) as AnyTemporalKey[];\n  const thisFields = PrepareTemporalFields(yearMonth, fieldNames, []);\n  thisFields.day = 1;\n  const thisDate = CalendarDateFromFields(calendar, thisFields);\n  const otherFields = PrepareTemporalFields(other, fieldNames, []);\n  otherFields.day = 1;\n  const otherDate = CalendarDateFromFields(calendar, otherFields);\n\n  let { years, months } = CalendarDateUntil(calendar, thisDate, otherDate, resolvedOptions);\n\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\n    ({ years, months } = RoundDuration(\n      years,\n      months,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      thisDate\n    ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(sign * years, sign * months, 0, 0, 0, 0, 0, 0, 0, 0);\n}\n\nexport function DifferenceTemporalZonedDateTime(\n  operation: DifferenceOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  otherParam: ZonedDateTimeParams['until'][0],\n  options: ZonedDateTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalZonedDateTime(otherParam);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n  if (\n    settings.largestUnit !== 'year' &&\n    settings.largestUnit !== 'month' &&\n    settings.largestUnit !== 'week' &&\n    settings.largestUnit !== 'day'\n  ) {\n    // The user is only asking for a time difference, so return difference of instants.\n    years = 0;\n    months = 0;\n    weeks = 0;\n    days = 0;\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n      ns1,\n      ns2,\n      settings.roundingIncrement,\n      settings.smallestUnit as Temporal.TimeUnit,\n      settings.largestUnit as Temporal.TimeUnit,\n      settings.roundingMode\n    ));\n  } else {\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n      throw new RangeError(\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\n      );\n    }\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, settings.largestUnit, resolvedOptions));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      zonedDateTime\n    ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      AdjustRoundedDurationDays(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        settings.roundingIncrement,\n        settings.smallestUnit,\n        settings.roundingMode,\n        zonedDateTime\n      ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function AddISODate(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n\n  year += years;\n  month += months;\n  ({ year, month } = BalanceISOYearMonth(year, month));\n  ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n  days += 7 * weeks;\n  day += days;\n  ({ year, month, day } = BalanceISODate(year, month, day));\n  return { year, month, day };\n}\n\nfunction AddTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  hour += hours;\n  minute += minutes;\n  second += seconds;\n  millisecond += milliseconds;\n  microsecond += microseconds;\n  nanosecond += nanoseconds;\n  let deltaDays = 0;\n  ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  ));\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nfunction AddDuration(\n  y1: number,\n  mon1: number,\n  w1: number,\n  d1: number,\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  y2: number,\n  mon2: number,\n  w2: number,\n  d2: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>\n) {\n  const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n  const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n  if (!relativeTo) {\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n      throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n    }\n    years = months = weeks = 0;\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      d1 + d2,\n      JSBI.add(JSBI.BigInt(h1), JSBI.BigInt(h2)),\n      JSBI.add(JSBI.BigInt(min1), JSBI.BigInt(min2)),\n      JSBI.add(JSBI.BigInt(s1), JSBI.BigInt(s2)),\n      JSBI.add(JSBI.BigInt(ms1), JSBI.BigInt(ms2)),\n      JSBI.add(JSBI.BigInt(µs1), JSBI.BigInt(µs2)),\n      JSBI.add(JSBI.BigInt(ns1), JSBI.BigInt(ns2)),\n      largestUnit\n    ));\n  } else if (IsTemporalDate(relativeTo)) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const calendar = GetSlot(relativeTo, CALENDAR);\n\n    const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n    const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n    const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n    const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, undefined, dateAdd);\n    const end = CalendarDateAdd(calendar, intermediate, dateDuration2, undefined, dateAdd);\n\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\n    const differenceOptions = ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateUnit>;\n    differenceOptions.largestUnit = dateLargestUnit;\n    ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      days,\n      JSBI.add(JSBI.BigInt(h1), JSBI.BigInt(h2)),\n      JSBI.add(JSBI.BigInt(min1), JSBI.BigInt(min2)),\n      JSBI.add(JSBI.BigInt(s1), JSBI.BigInt(s2)),\n      JSBI.add(JSBI.BigInt(ms1), JSBI.BigInt(ms2)),\n      JSBI.add(JSBI.BigInt(µs1), JSBI.BigInt(µs2)),\n      JSBI.add(JSBI.BigInt(ns1), JSBI.BigInt(ns2)),\n      largestUnit\n    ));\n  } else {\n    // relativeTo is a ZonedDateTime\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(\n      GetSlot(relativeTo, INSTANT),\n      timeZone,\n      calendar,\n      y1,\n      mon1,\n      w1,\n      d1,\n      h1,\n      min1,\n      s1,\n      ms1,\n      µs1,\n      ns1\n    );\n    const endNs = AddZonedDateTime(\n      new TemporalInstant(intermediateNs),\n      timeZone,\n      calendar,\n      y2,\n      mon2,\n      w2,\n      d2,\n      h2,\n      min2,\n      s2,\n      ms2,\n      µs2,\n      ns2\n    );\n    if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n      // The user is only asking for a time difference, so return difference of instants.\n      years = 0;\n      months = 0;\n      weeks = 0;\n      days = 0;\n      ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n        GetSlot(relativeTo, EPOCHNANOSECONDS),\n        endNs,\n        1,\n        'nanosecond',\n        largestUnit,\n        'halfExpand'\n      ));\n    } else {\n      ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n        DifferenceZonedDateTime(\n          GetSlot(relativeTo, EPOCHNANOSECONDS),\n          endNs,\n          timeZone,\n          calendar,\n          largestUnit,\n          ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n        ));\n    }\n  }\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction AddInstant(\n  epochNanoseconds: JSBI,\n  h: number | JSBI,\n  min: number | JSBI,\n  s: number | JSBI,\n  ms: number | JSBI,\n  µs: number | JSBI,\n  ns: number | JSBI\n) {\n  let sum = ZERO;\n  sum = JSBI.add(sum, JSBI.BigInt(ns));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(µs), THOUSAND));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(ms), MILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(s), BILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(min), JSBI.BigInt(60 * 1e9)));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(60 * 60 * 1e9)));\n\n  const result = JSBI.add(epochNanoseconds, sum);\n  ValidateEpochNanoseconds(result);\n  return result;\n}\n\nfunction AddDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  calendar: CalendarSlot,\n  years: number,\n  months: number,\n  weeks: number,\n  daysParam: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number,\n  options?: Temporal.ArithmeticOptions\n) {\n  let days = daysParam;\n  // Add the time part\n  let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n  days += deltaDays;\n\n  // Delegate the date part addition to the calendar\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const datePart = CreateTemporalDate(year, month, day, calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n\n  return {\n    year: GetSlot(addedDate, ISO_YEAR),\n    month: GetSlot(addedDate, ISO_MONTH),\n    day: GetSlot(addedDate, ISO_DAY),\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nexport function AddZonedDateTime(\n  instant: Temporal.Instant,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot,\n  years: number,\n  months: number,\n  weeks: number,\n  days: number,\n  h: number | JSBI,\n  min: number | JSBI,\n  s: number | JSBI,\n  ms: number | JSBI,\n  µs: number | JSBI,\n  ns: number | JSBI,\n  options?: Temporal.ArithmeticOptions\n) {\n  // If only time is to be added, then use Instant math. It's not OK to fall\n  // through to the date/time code below because compatible disambiguation in\n  // the PlainDateTime=>Instant conversion will change the offset of any\n  // ZonedDateTime in the repeated clock time after a backwards transition.\n  // When adding/subtracting time units and not dates, this disambiguation is\n  // not expected and so is avoided below via a fast path for time-only\n  // arithmetic.\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n    return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n  }\n\n  // RFC 5545 requires the date portion to be added in calendar days and the\n  // time portion to be added in exact time.\n  const dt = GetPlainDateTimeFor(timeZone, instant, calendar);\n  const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n  const dtIntermediate = CreateTemporalDateTime(\n    GetSlot(addedDate, ISO_YEAR),\n    GetSlot(addedDate, ISO_MONTH),\n    GetSlot(addedDate, ISO_DAY),\n    GetSlot(dt, ISO_HOUR),\n    GetSlot(dt, ISO_MINUTE),\n    GetSlot(dt, ISO_SECOND),\n    GetSlot(dt, ISO_MILLISECOND),\n    GetSlot(dt, ISO_MICROSECOND),\n    GetSlot(dt, ISO_NANOSECOND),\n    calendar\n  );\n\n  // Note that 'compatible' is used below because this disambiguation behavior\n  // is required by RFC 5545.\n  const instantIntermediate = GetInstantFor(timeZone, dtIntermediate, 'compatible');\n  return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n}\n\ntype AddSubtractOperation = 'add' | 'subtract';\n\nexport function AddDurationToOrSubtractDurationFromDuration(\n  operation: AddSubtractOperation,\n  duration: Temporal.Duration,\n  other: DurationParams['add'][0],\n  optionsParam: DurationParams['add'][1]\n): Temporal.Duration {\n  const sign = operation === 'subtract' ? -1 : 1;\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(other);\n  const options = GetOptionsObject(optionsParam);\n  const relativeTo = ToRelativeTemporalObject(options);\n  ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(\n    GetSlot(duration, YEARS),\n    GetSlot(duration, MONTHS),\n    GetSlot(duration, WEEKS),\n    GetSlot(duration, DAYS),\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS),\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    relativeTo\n  ));\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\n\nexport function AddDurationToOrSubtractDurationFromInstant(\n  operation: AddSubtractOperation,\n  instant: Temporal.Instant,\n  durationLike: InstantParams['add'][0]\n): Temporal.Instant {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(durationLike, [\n    'years',\n    'months',\n    'weeks',\n    'days'\n  ]);\n  const ns = AddInstant(\n    GetSlot(instant, EPOCHNANOSECONDS),\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  return new Instant(ns);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainDateTime(\n  operation: AddSubtractOperation,\n  dateTime: Temporal.PlainDateTime,\n  durationLike: PlainDateTimeParams['add'][0],\n  optionsParam: PlainDateTimeParams['add'][1]\n): Temporal.PlainDateTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(durationLike);\n  const options = GetOptionsObject(optionsParam);\n  const calendar = GetSlot(dateTime, CALENDAR);\n  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(\n    GetSlot(dateTime, ISO_YEAR),\n    GetSlot(dateTime, ISO_MONTH),\n    GetSlot(dateTime, ISO_DAY),\n    GetSlot(dateTime, ISO_HOUR),\n    GetSlot(dateTime, ISO_MINUTE),\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    calendar,\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    options\n  );\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainTime(\n  operation: AddSubtractOperation,\n  temporalTime: Temporal.PlainTime,\n  durationLike: PlainTimeParams['add'][0]\n): Temporal.PlainTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(durationLike);\n  let { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    GetSlot(temporalTime, ISO_HOUR),\n    GetSlot(temporalTime, ISO_MINUTE),\n    GetSlot(temporalTime, ISO_SECOND),\n    GetSlot(temporalTime, ISO_MILLISECOND),\n    GetSlot(temporalTime, ISO_MICROSECOND),\n    GetSlot(temporalTime, ISO_NANOSECOND),\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n  ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    'reject'\n  ));\n  const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainYearMonth(\n  operation: AddSubtractOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  durationLike: PlainYearMonthParams['add'][0],\n  optionsParam: PlainYearMonthParams['add'][1]\n): Temporal.PlainYearMonth {\n  let duration = ToTemporalDurationRecord(durationLike);\n  if (operation === 'subtract') {\n    duration = {\n      years: -duration.years,\n      months: -duration.months,\n      weeks: -duration.weeks,\n      days: -duration.days,\n      hours: -duration.hours,\n      minutes: -duration.minutes,\n      seconds: -duration.seconds,\n      milliseconds: -duration.milliseconds,\n      microseconds: -duration.microseconds,\n      nanoseconds: -duration.nanoseconds\n    };\n  }\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n  ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n\n  const options = GetOptionsObject(optionsParam);\n\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const fieldNames = CalendarFields(calendar, ['monthCode', 'year'] as const);\n  const fields = PrepareTemporalFields(yearMonth, fieldNames, []);\n  const fieldsCopy = ObjectCreate(null);\n  CopyDataProperties(fieldsCopy, fields, []);\n  fields.day = 1;\n  // PrepareTemporalFields returns a type where 'day' is potentially undefined,\n  // but TS doesn't narrow the type as a result of the assignment above.\n  uncheckedAssertNarrowedType<typeof fields & { day: number }>(fields, '`day` is guaranteed to be non-undefined');\n  let startDate = CalendarDateFromFields(calendar, fields);\n  const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const dateAdd = GetMethod(calendar, 'dateAdd');\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  if (sign < 0) {\n    const oneMonthDuration = new Duration(0, 1, 0, 0, 0, 0, 0, 0, 0, 0);\n    const nextMonth = CalendarDateAdd(calendar, startDate, oneMonthDuration, undefined, dateAdd);\n    const minusDayDuration = new Duration(0, 0, 0, -1, 0, 0, 0, 0, 0, 0);\n    const endOfMonth = CalendarDateAdd(calendar, nextMonth, minusDayDuration, undefined, dateAdd);\n    fieldsCopy.day = CalendarDay(calendar, endOfMonth);\n    startDate = CalendarDateFromFields(calendar, fieldsCopy);\n  }\n  const durationToAdd = new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const optionsCopy = CopyOptions(options);\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, options, dateAdd);\n  const addedDateFields = PrepareTemporalFields(addedDate, fieldNames, []);\n\n  return CalendarYearMonthFromFields(calendar, addedDateFields, optionsCopy);\n}\n\nexport function AddDurationToOrSubtractDurationFromZonedDateTime(\n  operation: AddSubtractOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  durationLike: ZonedDateTimeParams['add'][0],\n  optionsParam: ZonedDateTimeParams['add'][1]\n): Temporal.ZonedDateTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(durationLike);\n  const options = GetOptionsObject(optionsParam);\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const epochNanoseconds = AddZonedDateTime(\n    GetSlot(zonedDateTime, INSTANT),\n    timeZone,\n    calendar,\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    options\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nfunction RoundNumberToIncrement(quantity: JSBI, increment: JSBI, mode: Temporal.RoundingMode) {\n  if (JSBI.equal(increment, ONE)) return quantity;\n  let { quotient, remainder } = divmod(quantity, increment);\n  if (JSBI.equal(remainder, ZERO)) return quantity;\n  const sign = JSBI.lessThan(remainder, ZERO) ? -1 : 1;\n  const tiebreaker = abs(JSBI.multiply(remainder, JSBI.BigInt(2)));\n  const tie = JSBI.equal(tiebreaker, increment);\n  const expandIsNearer = JSBI.greaterThan(tiebreaker, increment);\n  switch (mode) {\n    case 'ceil':\n      if (sign > 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'floor':\n      if (sign < 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'expand':\n      // always expand if there is a remainder\n      quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'trunc':\n      // no change needed, because divmod is a truncation\n      break;\n    case 'halfCeil':\n      if (expandIsNearer || (tie && sign > 0)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfFloor':\n      if (expandIsNearer || (tie && sign < 0)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfExpand':\n      // \"half up away from zero\"\n      if (expandIsNearer || tie) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfTrunc':\n      if (expandIsNearer) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfEven':\n      if (expandIsNearer || (tie && JSBI.toNumber(JSBI.remainder(abs(quotient), JSBI.BigInt(2))) === 1)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n  }\n  return JSBI.multiply(quotient, increment);\n}\n\nexport function RoundInstant(\n  epochNs: JSBI,\n  increment: number,\n  unit: keyof typeof nsPerTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  let { remainder } = NonNegativeBigIntDivmod(epochNs, DAY_NANOS);\n  const wholeDays = JSBI.subtract(epochNs, remainder);\n  const roundedRemainder = RoundNumberToIncrement(\n    remainder,\n    JSBI.BigInt(nsPerTimeUnit[unit] * increment),\n    roundingMode\n  );\n  return JSBI.add(wholeDays, roundedRemainder);\n}\n\nexport function RoundISODateTime(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  increment: number,\n  unit: UnitSmallerThanOrEqualTo<'day'>,\n  roundingMode: Temporal.RoundingMode,\n  dayLengthNs = 86400e9\n) {\n  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam,\n    increment,\n    unit,\n    roundingMode,\n    dayLengthNs\n  );\n  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RoundTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  increment: number,\n  unit: keyof typeof nsPerTimeUnit | 'day',\n  roundingMode: Temporal.RoundingMode,\n  dayLengthNs = 86400e9\n) {\n  let quantity = ZERO;\n  switch (unit) {\n    case 'day':\n    case 'hour':\n      quantity = JSBI.BigInt(hour);\n    // fall through\n    case 'minute':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(minute));\n    // fall through\n    case 'second':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(second));\n    // fall through\n    case 'millisecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(millisecond));\n    // fall through\n    case 'microsecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(microsecond));\n    // fall through\n    case 'nanosecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(nanosecond));\n  }\n  const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n  const rounded = RoundNumberToIncrement(quantity, JSBI.BigInt(nsPerUnit * increment), roundingMode);\n  const result = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(nsPerUnit)));\n  switch (unit) {\n    case 'day':\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n    case 'hour':\n      return BalanceTime(result, 0, 0, 0, 0, 0);\n    case 'minute':\n      return BalanceTime(hour, result, 0, 0, 0, 0);\n    case 'second':\n      return BalanceTime(hour, minute, result, 0, 0, 0);\n    case 'millisecond':\n      return BalanceTime(hour, minute, second, result, 0, 0);\n    case 'microsecond':\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\n    case 'nanosecond':\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n    default:\n      throw new Error(`Invalid unit ${unit}`);\n  }\n}\n\nfunction DaysUntil(\n  earlier: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.ZonedDateTime,\n  later: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.ZonedDateTime\n) {\n  return DifferenceISODate(\n    GetSlot(earlier, ISO_YEAR),\n    GetSlot(earlier, ISO_MONTH),\n    GetSlot(earlier, ISO_DAY),\n    GetSlot(later, ISO_YEAR),\n    GetSlot(later, ISO_MONTH),\n    GetSlot(later, ISO_DAY),\n    'day'\n  ).days;\n}\n\nfunction MoveRelativeDate(\n  calendar: CalendarSlot,\n  relativeToParam: NonNullable<ReturnType<typeof ToRelativeTemporalObject>>,\n  duration: Temporal.Duration,\n  dateAdd: Temporal.CalendarProtocol['dateAdd'] | undefined\n) {\n  const later = CalendarDateAdd(calendar, relativeToParam, duration, undefined, dateAdd);\n  const days = DaysUntil(relativeToParam, later);\n  return { relativeTo: later, days };\n}\n\nexport function MoveRelativeZonedDateTime(\n  relativeTo: Temporal.ZonedDateTime,\n  years: number,\n  months: number,\n  weeks: number,\n  days: number\n) {\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const intermediateNs = AddZonedDateTime(\n    GetSlot(relativeTo, INSTANT),\n    timeZone,\n    calendar,\n    years,\n    months,\n    weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\n\nexport function AdjustRoundedDurationDays(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  hoursParam: number,\n  minutesParam: number,\n  secondsParam: number,\n  millisecondsParam: number,\n  microsecondsParam: number,\n  nanosecondsParam: number,\n  increment: number,\n  unit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>\n) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = nanosecondsParam;\n  if (\n    !IsTemporalZonedDateTime(relativeTo) ||\n    unit === 'year' ||\n    unit === 'month' ||\n    unit === 'week' ||\n    unit === 'day' ||\n    (unit === 'nanosecond' && increment === 1)\n  ) {\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n  }\n\n  // There's one more round of rounding possible: if relativeTo is a\n  // ZonedDateTime, the time units could have rounded up into enough hours\n  // to exceed the day length. If this happens, grow the date part by a\n  // single day and re-run exact time rounding on the smaller remainder. DO\n  // NOT RECURSE, because once the extra hours are sucked up into the date\n  // duration, there's no way for another full day to come from the next\n  // round of rounding. And if it were possible (e.g. contrived calendar\n  // with 30-minute-long \"days\") then it'd risk an infinite loop.\n  let timeRemainderNs = TotalDurationNanoseconds(\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    0\n  );\n  const direction = MathSign(JSBI.toNumber(timeRemainderNs));\n\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const dayStart = AddZonedDateTime(\n    GetSlot(relativeTo, INSTANT),\n    timeZone,\n    calendar,\n    years,\n    months,\n    weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const dayEnd = AddZonedDateTime(\n    new TemporalInstant(dayStart),\n    timeZone,\n    calendar,\n    0,\n    0,\n    0,\n    direction,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  const dayLengthNs = JSBI.subtract(dayEnd, dayStart);\n\n  if (\n    JSBI.greaterThanOrEqual(JSBI.multiply(JSBI.subtract(timeRemainderNs, dayLengthNs), JSBI.BigInt(direction)), ZERO)\n  ) {\n    ({ years, months, weeks, days } = AddDuration(\n      years,\n      months,\n      weeks,\n      days,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      direction,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      relativeTo\n    ));\n    timeRemainderNs = RoundInstant(JSBI.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      JSBI.toNumber(timeRemainderNs),\n      'hour'\n    ));\n  }\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nexport function RoundDuration(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  hoursParam: number,\n  minutesParam: number,\n  secondsParam: number,\n  millisecondsParam: number,\n  microsecondsParam: number,\n  nanosecondsParam: number,\n  increment: number,\n  unit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  let calendar, zdtRelative;\n  // A cast is used below because relativeTo will be either PlainDate or\n  // undefined for the rest of this long method (after any ZDT=>PlainDate\n  // conversion below), and TS isn't smart enough to know that the type has\n  // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n  let relativeTo = relativeToParam as Temporal.PlainDate | undefined;\n  if (relativeTo) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      zdtRelative = relativeTo;\n      relativeTo = ToTemporalDate(relativeTo);\n    } else if (!IsTemporalDate(relativeTo)) {\n      throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n    }\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  // First convert time units up to days, if rounding to days or higher units.\n  // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n  // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n  // larger. We'll cast away `undefined` when it's used lower down below.\n  let dayLengthNs: JSBI | undefined;\n  if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n    nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n    let intermediate;\n    if (zdtRelative) {\n      intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n    }\n    let deltaDays;\n    let dayLength: number;\n    ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n    dayLengthNs = JSBI.BigInt(dayLength);\n    days += deltaDays;\n    hours = minutes = seconds = milliseconds = microseconds = 0;\n  }\n\n  let total: number;\n  switch (unit) {\n    case 'year': {\n      if (!calendar) throw new RangeError('A starting point is required for years rounding');\n      assertExists(relativeTo);\n\n      // convert months and weeks to days by calculating difference(\n      // relativeTo + years, relativeTo + { years, months, weeks })\n      const yearsDuration = new TemporalDuration(years);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, undefined, dateAdd);\n      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n      const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n      const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n      relativeTo = yearsLater;\n      days += monthsWeeksInDays;\n\n      const wholeDays = new TemporalDuration(0, 0, 0, days);\n      const wholeDaysLater = CalendarDateAdd(calendar, relativeTo, wholeDays, undefined, dateAdd);\n      const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<typeof unit>;\n      untilOptions.largestUnit = 'year';\n      const yearsPassed = CalendarDateUntil(calendar, relativeTo, wholeDaysLater, untilOptions).years;\n      years += yearsPassed;\n      const oldRelativeTo = relativeTo;\n      const yearsPassedDuration = new TemporalDuration(yearsPassed);\n      relativeTo = CalendarDateAdd(calendar, relativeTo, yearsPassedDuration, undefined, dateAdd);\n      const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n      days -= daysPassed;\n      const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n      let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd);\n\n      // Note that `nanoseconds` below (here and in similar code for months,\n      // weeks, and days further below) isn't actually nanoseconds for the\n      // full date range.  Instead, it's a BigInt representation of total\n      // days multiplied by the number of nanoseconds in the last day of\n      // the duration. This lets us do days-or-larger rounding using BigInt\n      // math which reduces precision loss.\n      oneYearDays = MathAbs(oneYearDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneYearDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(years)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      years = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      months = weeks = days = 0;\n      break;\n    }\n    case 'month': {\n      if (!calendar) throw new RangeError('A starting point is required for months rounding');\n      assertExists(relativeTo);\n\n      // convert weeks to days by calculating difference(relativeTo +\n      //   { years, months }, relativeTo + { years, months, weeks })\n      const yearsMonths = new TemporalDuration(years, months);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, undefined, dateAdd);\n      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n      const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n      const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n      relativeTo = yearsMonthsLater;\n      days += weeksInDays;\n\n      // Months may be different lengths of days depending on the calendar,\n      // convert days to months in a loop as described above under 'years'.\n      const sign = MathSign(days);\n      const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n      let oneMonthDays: number;\n      ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n        months += sign;\n        days -= oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n      oneMonthDays = MathAbs(oneMonthDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneMonthDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(months)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      months = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      weeks = days = 0;\n      break;\n    }\n    case 'week': {\n      if (!calendar) throw new RangeError('A starting point is required for weeks rounding');\n      assertExists(relativeTo);\n\n      // Weeks may be different lengths of days depending on the calendar,\n      // convert days to weeks in a loop as described above under 'years'.\n      const sign = MathSign(days);\n      const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      let oneWeekDays;\n      ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n        weeks += sign;\n        days -= oneWeekDays;\n        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      }\n      oneWeekDays = MathAbs(oneWeekDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneWeekDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(weeks)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      weeks = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      days = 0;\n      break;\n    }\n    case 'day': {\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = dayLengthNs;\n      nanoseconds = JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(days)), nanoseconds);\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      days = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      break;\n    }\n    case 'hour': {\n      const divisor = 3600e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(hours), JSBI.BigInt(3600e9));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9)));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      hours = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      minutes = seconds = milliseconds = microseconds = 0;\n      break;\n    }\n    case 'minute': {\n      const divisor = 60e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      minutes = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      seconds = milliseconds = microseconds = 0;\n      break;\n    }\n    case 'second': {\n      const divisor = 1e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(seconds), BILLION);\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      seconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      milliseconds = microseconds = 0;\n      break;\n    }\n    case 'millisecond': {\n      const divisor = 1e6;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(milliseconds), MILLION);\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      milliseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      microseconds = 0;\n      break;\n    }\n    case 'microsecond': {\n      const divisor = 1e3;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND);\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      microseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      break;\n    }\n    case 'nanosecond': {\n      total = JSBI.toNumber(nanoseconds);\n      nanoseconds = RoundNumberToIncrement(JSBI.BigInt(nanoseconds), JSBI.BigInt(increment), roundingMode);\n      break;\n    }\n  }\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds: JSBI.toNumber(nanoseconds),\n    total\n  };\n}\n\nexport function CompareISODate(y1: number, m1: number, d1: number, y2: number, m2: number, d2: number) {\n  for (const [x, y] of [\n    [y1, y2],\n    [m1, m2],\n    [d1, d2]\n  ]) {\n    if (x !== y) return ComparisonResult(x - y);\n  }\n  return 0;\n}\n\n// Not abstract operations from the spec\n\nfunction NonNegativeBigIntDivmod(x: JSBI, y: JSBI) {\n  let { quotient, remainder } = divmod(x, y);\n  if (JSBI.lessThan(remainder, ZERO)) {\n    quotient = JSBI.subtract(quotient, ONE);\n    remainder = JSBI.add(remainder, y);\n  }\n  return { quotient, remainder };\n}\n\nexport function BigIntFloorDiv(left: JSBI, right: JSBI) {\n  const { quotient, remainder } = divmod(left, right);\n  if (!isZero(remainder) && !isNegativeJSBI(left) != !isNegativeJSBI(right)) {\n    return JSBI.subtract(quotient, ONE);\n  }\n  return quotient;\n}\n\n/** Divide two JSBIs, and return the result as a Number, including the remainder. */\nexport function BigIntDivideToNumber(dividend: JSBI, divisor: JSBI) {\n  const { quotient, remainder } = divmod(dividend, divisor);\n  const result = JSBI.toNumber(quotient) + JSBI.toNumber(remainder) / JSBI.toNumber(divisor);\n  return result;\n}\n\n// Defaults to native bigint, or something \"native bigint-like\".\n// For users of Temporal that are running in environments without native BigInt,\n// the only guarantee we should give is that the returned object's toString will\n// return a string containing an accurate base 10 value of this bigint. This\n// form factor should correctly interop with other bigint compat libraries\n// easily.\ntype ExternalBigInt = bigint;\n\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\n  const jsbiBI = ToBigInt(arg);\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\n  return jsbiBI as unknown as ExternalBigInt;\n}\n\nexport function ToBigInt(arg: unknown): JSBI {\n  let prim = arg;\n  if (typeof arg === 'object') {\n    const toPrimFn = (arg as { [Symbol.toPrimitive]: unknown })[Symbol.toPrimitive];\n    if (toPrimFn && typeof toPrimFn === 'function') {\n      prim = ReflectApply(toPrimFn, arg, ['number']);\n    }\n  }\n\n  // The AO ToBigInt throws on numbers because it does not allow implicit\n  // conversion between number and bigint (unlike the bigint constructor).\n  if (typeof prim === 'number') {\n    throw new TypeError('cannot convert number to bigint');\n  }\n  if (typeof prim === 'bigint') {\n    // JSBI doesn't know anything about the bigint type, and intentionally\n    // assumes it doesn't exist. Passing one to the BigInt function will throw\n    // an error.\n    return JSBI.BigInt(prim.toString(10));\n  }\n  // JSBI will properly coerce types into a BigInt the same as the native BigInt\n  // constructor will, with the exception of native bigint which is handled\n  // above.\n  // As of 2023-04-07, the only runtime type that neither of those can handle is\n  // 'symbol', and both native bigint and the JSBI.BigInt function will throw an\n  // error if they are given a Symbol.\n  return JSBI.BigInt(prim as string | boolean | object);\n}\n\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds: () => JSBI = (() => {\n  let ns = JSBI.BigInt(Date.now() % 1e6);\n  return () => {\n    const ms = JSBI.BigInt(Date.now());\n    const result = JSBI.add(JSBI.multiply(ms, MILLION), ns);\n    ns = JSBI.remainder(ms, MILLION);\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\n    return result;\n  };\n})();\n\nexport function DefaultTimeZone() {\n  return new IntlDateTimeFormat().resolvedOptions().timeZone;\n}\n\nexport function ComparisonResult(value: number) {\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\n}\n\nexport function GetOptionsObject<T>(options: T) {\n  if (options === undefined) return ObjectCreate(null) as NonNullable<T>;\n  if (IsObject(options) && options !== null) return options;\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\n\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\n  const o = ObjectCreate(null);\n  o[propName] = propValue;\n  return o;\n}\n\nfunction CopyOptions<T extends { [s in K]?: unknown }, K extends string & keyof T>(options: T | undefined) {\n  const optionsCopy = ObjectCreate(null) as T;\n  CopyDataProperties(optionsCopy, GetOptionsObject(options), []);\n  return optionsCopy;\n}\n\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: undefined\n): O[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: Fallback\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: O[P]\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\n  let value = options[property];\n  if (value !== undefined) {\n    value = ToString(value) as O[P];\n    if (!allowedValues.includes(value)) {\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n    }\n    return value;\n  }\n  return fallback;\n}\n\nexport function IsBuiltinCalendar(id: string): id is BuiltinCalendarId {\n  return BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id));\n}\n\nexport function ASCIILowercase<T extends string>(str: T): T {\n  // The spec defines this operation distinct from String.prototype.lowercase,\n  // so we'll follow the spec here. Note that nasty security issues that can\n  // happen for some use cases if you're comparing case-modified non-ASCII\n  // values. For example, Turkish's \"I\" character was the source of a security\n  // issue involving \"file://\" URLs. See\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\n  return str.replace(/[A-Z]/g, (l) => {\n    const code = l.charCodeAt(0);\n    return String.fromCharCode(code + 0x20);\n  }) as T;\n}\n\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\n\nfunction bisect(\n  getState: (epochNs: JSBI) => number,\n  leftParam: JSBI,\n  rightParam: JSBI,\n  lstateParam: number = getState(leftParam),\n  rstateParam: number = getState(rightParam)\n) {\n  // This doesn't make much sense - why do these get converted unnecessarily?\n  let left = JSBI.BigInt(leftParam);\n  let right = JSBI.BigInt(rightParam);\n  let lstate = lstateParam;\n  let rstate = rstateParam;\n  while (JSBI.greaterThan(JSBI.subtract(right, left), ONE)) {\n    const middle = JSBI.divide(JSBI.add(left, right), JSBI.BigInt(2));\n    const mstate = getState(middle);\n    if (mstate === lstate) {\n      left = middle;\n      lstate = mstate;\n    } else if (mstate === rstate) {\n      right = middle;\n      rstate = mstate;\n    } else {\n      throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n    }\n  }\n  return right;\n}\n\nconst nsPerTimeUnit = {\n  hour: 3600e9,\n  minute: 60e9,\n  second: 1e9,\n  millisecond: 1e6,\n  microsecond: 1e3,\n  nanosecond: 1\n};\n","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport {\n  GetSlot,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR\n} from './slots';\nimport type { Temporal, Intl } from '..';\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\n\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\n\nconst descriptor = <T extends (...args: any[]) => any>(value: T) => {\n  return {\n    value,\n    enumerable: true,\n    writable: false,\n    configurable: true\n  };\n};\n\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n\ninterface CustomFormatters {\n  [DATE]: typeof dateAmend | globalThis.Intl.DateTimeFormat;\n  [YM]: typeof yearMonthAmend | typeof globalThis.Intl.DateTimeFormat;\n  [MD]: typeof monthDayAmend | typeof globalThis.Intl.DateTimeFormat;\n  [TIME]: typeof timeAmend | typeof globalThis.Intl.DateTimeFormat;\n  [DATETIME]: typeof datetimeAmend | typeof globalThis.Intl.DateTimeFormat;\n  [INST]: typeof instantAmend | typeof globalThis.Intl.DateTimeFormat;\n}\n\ninterface PrivateProps extends CustomFormatters {\n  [ORIGINAL]: globalThis.Intl.DateTimeFormat;\n  [TZ_RESOLVED]: string | Temporal.TimeZoneProtocol;\n  [CAL_ID]: globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'];\n  [LOCALE]: globalThis.Intl.ResolvedDateTimeFormatOptions['locale'];\n  [OPTIONS]: Intl.DateTimeFormatOptions;\n}\n\ntype OptionsAmenderFunction = (options: Intl.DateTimeFormatOptions) => globalThis.Intl.DateTimeFormatOptions;\ntype FormatterOrAmender = globalThis.Intl.DateTimeFormat | OptionsAmenderFunction;\n\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy<T extends PrivateProps, P extends keyof CustomFormatters>(\n  obj: T,\n  prop: P\n): globalThis.Intl.DateTimeFormat {\n  let val = obj[prop] as FormatterOrAmender;\n  if (typeof val === 'function') {\n    // If we get here, `val` is an \"amender function\". It will take the user's\n    // options and transform them into suitable options to be passed into the\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n    // will vary depending on the Temporal type, so that's why we store separate\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\n    // The efficiency happens because we don't create an (expensive) formatter\n    // until the user calls toLocaleString for that Temporal type.\n    val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n    // TODO: can this be typed more cleanly?\n    (obj[prop] as globalThis.Intl.DateTimeFormat) = val;\n  }\n  return val;\n}\n\ntype DateTimeFormatImpl = Intl.DateTimeFormat & PrivateProps;\n\nfunction DateTimeFormatImpl(\n  this: Intl.DateTimeFormat & PrivateProps,\n  locale: Params['constructor'][0] = undefined,\n  optionsParam: Params['constructor'][1] = {}\n) {\n  if (!(this instanceof DateTimeFormatImpl)) {\n    type Construct = new (\n      locale: Params['constructor'][0],\n      optionsParam: Params['constructor'][1]\n    ) => Intl.DateTimeFormat;\n    return new (DateTimeFormatImpl as unknown as Construct)(locale, optionsParam);\n  }\n  const hasOptions = typeof optionsParam !== 'undefined';\n  const options = hasOptions ? ObjectAssign({}, optionsParam) : {};\n  // TODO: remove type assertion after Temporal types land in TS lib types\n  const original = new IntlDateTimeFormat(locale, options as globalThis.Intl.DateTimeFormatOptions);\n  const ro = original.resolvedOptions();\n\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\n  // be lazily created only when needed, using the locale and options provided.\n  // But it's possible for callers to mutate those inputs before lazy creation\n  // happens. For this reason, we clone the inputs instead of caching the\n  // original objects. To avoid the complexity of deep cloning any inputs that\n  // are themselves objects (e.g. the locales array, or options property values\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\n  // options as-is because our options-amending logic adds additional fields if\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\n  // Therefore, we limit the properties in the clone to properties that were\n  // present in the original input.\n  if (hasOptions) {\n    const clonedResolved = ObjectAssign({}, ro);\n    for (const prop in clonedResolved) {\n      if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n        delete clonedResolved[prop as keyof typeof clonedResolved];\n      }\n    }\n    this[OPTIONS] = clonedResolved as Intl.DateTimeFormatOptions;\n  } else {\n    this[OPTIONS] = options;\n  }\n\n  this[LOCALE] = ro.locale;\n  this[ORIGINAL] = original;\n  this[TZ_RESOLVED] = ro.timeZone;\n  this[CAL_ID] = ro.calendar;\n  this[DATE] = dateAmend;\n  this[YM] = yearMonthAmend;\n  this[MD] = monthDayAmend;\n  this[TIME] = timeAmend;\n  this[DATETIME] = datetimeAmend;\n  this[INST] = instantAmend;\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\n\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n  writable: true,\n  value: 'DateTimeFormat'\n});\n\nDateTimeFormatImpl.supportedLocalesOf = function (\n  locales: Params['supportedLocalesOf'][0],\n  options: Params['supportedLocalesOf'][1]\n) {\n  return IntlDateTimeFormat.supportedLocalesOf(locales, options as globalThis.Intl.DateTimeFormatOptions);\n};\n\nconst propertyDescriptors: Partial<Record<keyof Intl.DateTimeFormat, PropertyDescriptor>> = {\n  resolvedOptions: descriptor(resolvedOptions),\n  format: descriptor(format),\n  formatRange: descriptor(formatRange)\n};\n\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n  propertyDescriptors.formatToParts = descriptor(formatToParts);\n}\n\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n  propertyDescriptors.formatRangeToParts = descriptor(formatRangeToParts);\n}\n\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, propertyDescriptors);\n\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nexport const DateTimeFormat = DateTimeFormatImpl as unknown as typeof Intl.DateTimeFormat;\n\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\n  return this[ORIGINAL].resolvedOptions();\n}\n\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['format'][0],\n  ...rest: P\n): Return['format'] {\n  let { instant, formatter } = extractOverrides(datetime, this);\n  if (instant && formatter) {\n    return formatter.format(instant.epochMilliseconds);\n  }\n  // Support spreading additional args for future expansion of this Intl method\n  type AllowExtraParams = (datetime: Parameters<Intl.DateTimeFormat['format']>[0], ...rest: P) => Return['format'];\n  return (this[ORIGINAL].format as unknown as AllowExtraParams)(datetime, ...rest);\n}\n\nfunction formatToParts<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['formatToParts'][0],\n  ...rest: P\n): Return['formatToParts'] {\n  let { instant, formatter } = extractOverrides(datetime, this);\n  if (instant && formatter) {\n    return formatter.formatToParts(instant.epochMilliseconds);\n  }\n  // Support spreading additional args for future expansion of this Intl method\n  type AllowExtraParams = (\n    datetime: Parameters<Intl.DateTimeFormat['formatToParts']>[0],\n    ...rest: P\n  ) => Return['formatToParts'];\n  return (this[ORIGINAL].formatToParts as unknown as AllowExtraParams)(datetime, ...rest);\n}\n\nfunction formatRange(this: DateTimeFormatImpl, a: Params['formatRange'][0], b: Params['formatRange'][1]) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n    }\n    const { instant: aa, formatter: aformatter } = extractOverrides(a as unknown as TypesWithToLocaleString, this);\n    const { instant: bb, formatter: bformatter } = extractOverrides(b as unknown as TypesWithToLocaleString, this);\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      // TODO: Remove type assertion after this method lands in TS lib types\n      return (aformatter as Intl.DateTimeFormat).formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  }\n  // TODO: Remove type assertion after this method lands in TS lib types\n  return (this[ORIGINAL] as Intl.DateTimeFormat).formatRange(a, b);\n}\n\nfunction formatRangeToParts(\n  this: DateTimeFormatImpl,\n  a: Params['formatRangeToParts'][0],\n  b: Params['formatRangeToParts'][1]\n) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n    }\n    const { instant: aa, formatter: aformatter } = extractOverrides(a, this);\n    const { instant: bb, formatter: bformatter } = extractOverrides(b, this);\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      // TODO: Remove type assertion after this method lands in TS lib types\n      return (aformatter as Intl.DateTimeFormat).formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  }\n  // TODO: Remove type assertion after this method lands in TS lib types\n  return (this[ORIGINAL] as Intl.DateTimeFormat).formatRangeToParts(a, b);\n}\n\n// \"false\" is a signal to delete this option\ntype MaybeFalseOptions = {\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\n};\n\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\n  const options = ObjectAssign({}, optionsParam);\n  for (const opt of [\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'weekday',\n    'dayPeriod',\n    'timeZoneName',\n    'dateStyle',\n    'timeStyle'\n  ] as const) {\n    // TODO: can this be typed more cleanly?\n    type OptionMaybeFalse = typeof options[typeof opt] | false;\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\n  }\n  return options as globalThis.Intl.DateTimeFormatOptions;\n}\n\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\n\nfunction timeAmend(optionsParam: OptionsType<Temporal.PlainTime>) {\n  let options = amend(optionsParam, {\n    year: false,\n    month: false,\n    day: false,\n    weekday: false,\n    timeZoneName: false,\n    dateStyle: false\n  });\n  if (!hasTimeOptions(options)) {\n    options = ObjectAssign({}, options, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction yearMonthAmend(optionsParam: OptionsType<Temporal.PlainYearMonth>) {\n  let options = amend(optionsParam, {\n    day: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n  if (!('year' in options || 'month' in options)) {\n    options = ObjectAssign(options, { year: 'numeric', month: 'numeric' });\n  }\n  return options;\n}\n\nfunction monthDayAmend(optionsParam: OptionsType<Temporal.PlainMonthDay>) {\n  let options = amend(optionsParam, {\n    year: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n  if (!('month' in options || 'day' in options)) {\n    options = ObjectAssign({}, options, { month: 'numeric', day: 'numeric' });\n  }\n  return options;\n}\n\nfunction dateAmend(optionsParam: OptionsType<Temporal.PlainDate>) {\n  let options = amend(optionsParam, {\n    hour: false,\n    minute: false,\n    second: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if (!hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction datetimeAmend(optionsParam: OptionsType<Temporal.PlainDateTime>) {\n  let options = amend(optionsParam, { timeZoneName: false });\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\n  let options = optionsParam;\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\n\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return (\n    'hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options\n  );\n}\n\nfunction isTemporalObject(\n  obj: unknown\n): obj is\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainDateTime\n  | Temporal.ZonedDateTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.Instant {\n  return (\n    ES.IsTemporalDate(obj) ||\n    ES.IsTemporalTime(obj) ||\n    ES.IsTemporalDateTime(obj) ||\n    ES.IsTemporalZonedDateTime(obj) ||\n    ES.IsTemporalYearMonth(obj) ||\n    ES.IsTemporalMonthDay(obj) ||\n    ES.IsTemporalInstant(obj)\n  );\n}\n\nfunction sameTemporalType(x: unknown, y: unknown) {\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\n  return true;\n}\n\ntype TypesWithToLocaleString =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime\n  | Temporal.Instant;\n\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n\n  if (ES.IsTemporalTime(temporalObj)) {\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, TIME)\n    };\n  }\n\n  if (ES.IsTemporalYearMonth(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, YM)\n    };\n  }\n\n  if (ES.IsTemporalMonthDay(temporalObj)) {\n    const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, MD)\n    };\n  }\n\n  if (ES.IsTemporalDate(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n    const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, DATE)\n    };\n  }\n\n  if (ES.IsTemporalDateTime(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    let datetime = temporalObj;\n    if (calendar === 'iso8601') {\n      datetime = new DateTime(\n        isoYear,\n        isoMonth,\n        isoDay,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        main[CAL_ID]\n      );\n    }\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, DATETIME)\n    };\n  }\n\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\n    throw new TypeError(\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\n    );\n  }\n\n  if (ES.IsTemporalInstant(temporalObj)) {\n    return {\n      instant: temporalObj,\n      formatter: getPropLazy(main, INST)\n    };\n  }\n\n  return {};\n}\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND } from './ecmascript';\n\nexport class Instant implements Temporal.Instant {\n  constructor(epochNanoseconds: bigint | JSBI) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n\n    const ns = ES.ToBigInt(epochNanoseconds);\n    ES.ValidateEpochNanoseconds(ns);\n    CreateSlots(this);\n    SetSlot(this, EPOCHNANOSECONDS, ns);\n\n    if (DEBUG) {\n      const repr = ES.TemporalInstantToString(this, undefined, 'auto');\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${repr}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get epochSeconds(): Return['epochSeconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, BILLION));\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, MILLION));\n  }\n  get epochMicroseconds(): Return['epochMicroseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return ES.ToBigIntExternal(ES.BigIntFloorDiv(value, THOUSAND));\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromInstant('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromInstant('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalInstant('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalInstant('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const maximumIncrements = {\n      hour: 24,\n      minute: 1440,\n      second: 86400,\n      millisecond: 86400e3,\n      microsecond: 86400e6,\n      nanosecond: 86400e9\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n    return new Instant(roundedNs);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalInstant(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    let timeZone = options.timeZone;\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneSlotValue(timeZone);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundInstant(ns, increment, unit, roundingMode);\n    const roundedInstant = new Instant(roundedNs);\n    return ES.TemporalInstantToString(roundedInstant, timeZone as Temporal.TimeZoneProtocol, precision);\n  }\n  toJSON(): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalInstantToString(this, undefined, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) {\n      throw new TypeError('invalid argument in toZonedDateTime');\n    }\n    const calendarLike = item.calendar;\n    if (calendarLike === undefined) {\n      throw new TypeError('missing calendar property in toZonedDateTime');\n    }\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n    const temporalTimeZoneLike = item.timeZone;\n    if (temporalTimeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property in toZonedDateTime');\n    }\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\n  }\n\n  static fromEpochSeconds(epochSecondsParam: Params['fromEpochSeconds'][0]): Return['fromEpochSeconds'] {\n    const epochSeconds = ES.ToNumber(epochSecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochSeconds), BILLION);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochMilliseconds(\n    epochMillisecondsParam: Params['fromEpochMilliseconds'][0]\n  ): Return['fromEpochMilliseconds'] {\n    const epochMilliseconds = ES.ToNumber(epochMillisecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochMicroseconds(\n    epochMicrosecondsParam: Params['fromEpochMicroseconds'][0]\n  ): Return['fromEpochMicroseconds'] {\n    const epochMicroseconds = ES.ToBigInt(epochMicrosecondsParam);\n    const epochNanoseconds = JSBI.multiply(epochMicroseconds, THOUSAND);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochNanoseconds(\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\n  ): Return['fromEpochNanoseconds'] {\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    if (ES.IsTemporalInstant(item)) {\n      return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    return ES.ToTemporalInstant(item);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalInstant(oneParam);\n    const two = ES.ToTemporalInstant(twoParam);\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.Instant';\n}\n\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass, DefineIntrinsic } from './intrinsicclass';\nimport {\n  CALENDAR_ID,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport type {\n  BuiltinCalendarId,\n  CalendarParams as Params,\n  CalendarReturn as Return,\n  AnyTemporalKey,\n  CalendarSlot\n} from './internaltypes';\n\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst ObjectCreate = Object.create;\nconst ObjectEntries = Object.entries;\nconst OriginalSet = Set;\nconst ReflectOwnKeys = Reflect.ownKeys;\nconst SetPrototypeAdd = Set.prototype.add;\nconst SetPrototypeValues = Set.prototype.values;\n\n/**\n * Shape of internal implementation of each built-in calendar. Note that\n * parameter types are simpler than CalendarProtocol because the `Calendar`\n * class performs validation and parameter normalization before handing control\n * over to CalendarImpl.\n *\n * There are two instances of this interface: one for the ISO calendar and\n * another that handles logic that's the same across all non-ISO calendars. The\n * latter is cloned for each non-ISO calendar at the end of this file.\n */\ninterface CalendarImpl {\n  year(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  month(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): number;\n  monthCode(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): string;\n  day(date: Temporal.PlainDate | Temporal.PlainMonthDay): number;\n  era(date: Temporal.PlainDate | Temporal.PlainYearMonth): string | undefined;\n  eraYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number | undefined;\n  dayOfWeek(date: Temporal.PlainDate): number;\n  dayOfYear(date: Temporal.PlainDate): number;\n  weekOfYear(date: Temporal.PlainDate): number;\n  yearOfWeek(date: Temporal.PlainDate): number;\n  daysInWeek(date: Temporal.PlainDate): number;\n  daysInMonth(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  daysInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  monthsInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  inLeapYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): boolean;\n  dateFromFields(\n    fields: Params['dateFromFields'][0],\n    options: NonNullable<Params['dateFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainDate;\n  yearMonthFromFields(\n    fields: Params['yearMonthFromFields'][0],\n    options: NonNullable<Params['yearMonthFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainYearMonth;\n  monthDayFromFields(\n    fields: Params['monthDayFromFields'][0],\n    options: NonNullable<Params['monthDayFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainMonthDay;\n  dateAdd(\n    date: Temporal.PlainDate,\n    years: number,\n    months: number,\n    weeks: number,\n    days: number,\n    overflow: Overflow,\n    calendar: string\n  ): Temporal.PlainDate;\n  dateUntil(\n    one: Temporal.PlainDate,\n    two: Temporal.PlainDate,\n    largestUnit: 'year' | 'month' | 'week' | 'day'\n  ): { years: number; months: number; weeks: number; days: number };\n  fields(fields: string[]): string[];\n  fieldKeysToIgnore(keys: string[]): string[];\n}\n\ntype CalendarImplementations = {\n  [k in BuiltinCalendarId]: CalendarImpl;\n};\n\n/**\n * Implementations for each calendar.\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\n * at the bottom of the file.\n */\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\n\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nexport class Calendar implements Temporal.Calendar {\n  constructor(idParam: Params['constructor'][0]) {\n    // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n    //       exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: id is required');\n    }\n\n    const id = ES.ToString(idParam);\n    if (!ES.IsBuiltinCalendar(id)) throw new RangeError(`invalid calendar identifier ${id}`);\n    CreateSlots(this);\n    SetSlot(this, CALENDAR_ID, ES.ASCIILowercase(id));\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${id}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get id(): Return['id'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  dateFromFields(\n    fields: Params['dateFromFields'][0],\n    optionsParam: Params['dateFromFields'][1] = undefined\n  ): Return['dateFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].dateFromFields(fields, options, id);\n  }\n  yearMonthFromFields(\n    fields: Params['yearMonthFromFields'][0],\n    optionsParam: Params['yearMonthFromFields'][1] = undefined\n  ): Return['yearMonthFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].yearMonthFromFields(fields, options, id);\n  }\n  monthDayFromFields(\n    fields: Params['monthDayFromFields'][0],\n    optionsParam: Params['monthDayFromFields'][1] = undefined\n  ): Return['monthDayFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].monthDayFromFields(fields, options, id);\n  }\n  fields(fields: Params['fields'][0]): Return['fields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const fieldsArray = [] as string[];\n    const allowed = new Set([\n      'year',\n      'month',\n      'monthCode',\n      'day',\n      'hour',\n      'minute',\n      'second',\n      'millisecond',\n      'microsecond',\n      'nanosecond'\n    ]);\n    for (const name of fields) {\n      if (typeof name !== 'string') throw new TypeError('invalid fields');\n      if (!allowed.has(name)) throw new RangeError(`invalid field name ${name}`);\n      allowed.delete(name);\n      ArrayPrototypePush.call(fieldsArray, name);\n    }\n    return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n  }\n  mergeFields(\n    fieldsParam: Params['mergeFields'][0],\n    additionalFieldsParam: Params['mergeFields'][1]\n  ): Return['mergeFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const fields = ES.ToObject(fieldsParam);\n    const fieldsCopy = ObjectCreate(null);\n    ES.CopyDataProperties(fieldsCopy, fields, [], [undefined]);\n    const additionalFields = ES.ToObject(additionalFieldsParam);\n    const additionalFieldsCopy = ObjectCreate(null);\n    ES.CopyDataProperties(additionalFieldsCopy, additionalFields, [], [undefined]);\n    const additionalKeys = ReflectOwnKeys(additionalFieldsCopy) as (keyof typeof additionalFields)[];\n    const overriddenKeys = impl[GetSlot(this, CALENDAR_ID)].fieldKeysToIgnore(additionalKeys);\n    const merged = ObjectCreate(null);\n    const fieldsKeys = ReflectOwnKeys(fieldsCopy);\n    for (const key of fieldsKeys) {\n      let propValue = undefined;\n      if (ES.Call(ArrayIncludes, overriddenKeys, [key])) propValue = additionalFieldsCopy[key];\n      else propValue = fieldsCopy[key];\n      if (propValue !== undefined) merged[key] = propValue;\n    }\n    ES.CopyDataProperties(merged, additionalFieldsCopy, []);\n    return merged;\n  }\n  dateAdd(\n    dateParam: Params['dateAdd'][0],\n    durationParam: Params['dateAdd'][1],\n    optionsParam: Params['dateAdd'][2] = undefined\n  ): Return['dateAdd'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    const duration = ES.ToTemporalDuration(durationParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { days } = ES.BalanceDuration(\n      GetSlot(duration, DAYS),\n      GetSlot(duration, HOURS),\n      GetSlot(duration, MINUTES),\n      GetSlot(duration, SECONDS),\n      GetSlot(duration, MILLISECONDS),\n      GetSlot(duration, MICROSECONDS),\n      GetSlot(duration, NANOSECONDS),\n      'day'\n    );\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].dateAdd(\n      date,\n      GetSlot(duration, YEARS),\n      GetSlot(duration, MONTHS),\n      GetSlot(duration, WEEKS),\n      days,\n      overflow,\n      id\n    );\n  }\n  dateUntil(\n    oneParam: Params['dateUntil'][0],\n    twoParam: Params['dateUntil'][1],\n    optionsParam: Params['dateUntil'][2] = undefined\n  ): Return['dateUntil'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    let largestUnit = ES.GetTemporalUnit(options, 'largestUnit', 'date', 'auto');\n    if (largestUnit === 'auto') largestUnit = 'day';\n    const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  }\n  year(dateParam: Params['year'][0]): Return['year'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].year(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  month(dateParam: Params['month'][0]): Return['month'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (ES.IsTemporalMonthDay(date)) throw new TypeError('use monthCode on PlainMonthDay instead');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].month(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  monthCode(dateParam: Params['monthCode'][0]): Return['monthCode'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date) && !ES.IsTemporalMonthDay(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthCode(\n      date as Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth\n    );\n  }\n  day(dateParam: Params['day'][0]): Return['day'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalMonthDay(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].day(date as Temporal.PlainDate | Temporal.PlainMonthDay);\n  }\n  era(dateParam: Params['era'][0]): Return['era'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].era(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  eraYear(dateParam: Params['eraYear'][0]): Return['eraYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].eraYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  dayOfWeek(dateParam: Params['dayOfWeek'][0]): Return['dayOfWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n  }\n  dayOfYear(dateParam: Params['dayOfYear'][0]): Return['dayOfYear'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n  }\n  weekOfYear(dateParam: Params['weekOfYear'][0]): Return['weekOfYear'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n  }\n  yearOfWeek(dateParam: Params['yearOfWeek'][0]): Return['yearOfWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].yearOfWeek(date);\n  }\n  daysInWeek(dateParam: Params['daysInWeek'][0]): Return['daysInWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n  }\n  daysInMonth(dateParam: Params['daysInMonth'][0]): Return['daysInMonth'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  daysInYear(dateParam: Params['daysInYear'][0]): Return['daysInYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  monthsInYear(dateParam: Params['monthsInYear'][0]): Return['monthsInYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  inLeapYear(dateParam: Params['inLeapYear'][0]): Return['inLeapYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  toString(): string {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    const calendarSlotValue = ES.ToTemporalCalendarSlotValue(item);\n    return ES.ToTemporalCalendarObject(calendarSlotValue);\n  }\n  [Symbol.toStringTag]!: 'Temporal.Calendar';\n}\n\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\nDefineIntrinsic('Temporal.Calendar.prototype.dateAdd', Calendar.prototype.dateAdd);\nDefineIntrinsic('Temporal.Calendar.prototype.dateFromFields', Calendar.prototype.dateFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.dateUntil', Calendar.prototype.dateUntil);\nDefineIntrinsic('Temporal.Calendar.prototype.day', Calendar.prototype.day);\nDefineIntrinsic('Temporal.Calendar.prototype.dayOfWeek', Calendar.prototype.dayOfWeek);\nDefineIntrinsic('Temporal.Calendar.prototype.dayOfYear', Calendar.prototype.dayOfYear);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInMonth', Calendar.prototype.daysInMonth);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInWeek', Calendar.prototype.daysInWeek);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInYear', Calendar.prototype.daysInYear);\nDefineIntrinsic('Temporal.Calendar.prototype.era', Calendar.prototype.era);\nDefineIntrinsic('Temporal.Calendar.prototype.eraYear', Calendar.prototype.eraYear);\nDefineIntrinsic('Temporal.Calendar.prototype.fields', Calendar.prototype.fields);\nDefineIntrinsic('Temporal.Calendar.prototype.inLeapYear', Calendar.prototype.inLeapYear);\nDefineIntrinsic('Temporal.Calendar.prototype.mergeFields', Calendar.prototype.mergeFields);\nDefineIntrinsic('Temporal.Calendar.prototype.month', Calendar.prototype.month);\nDefineIntrinsic('Temporal.Calendar.prototype.monthCode', Calendar.prototype.monthCode);\nDefineIntrinsic('Temporal.Calendar.prototype.monthDayFromFields', Calendar.prototype.monthDayFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.monthsInYear', Calendar.prototype.monthsInYear);\nDefineIntrinsic('Temporal.Calendar.prototype.weekOfYear', Calendar.prototype.weekOfYear);\nDefineIntrinsic('Temporal.Calendar.prototype.year', Calendar.prototype.year);\nDefineIntrinsic('Temporal.Calendar.prototype.yearMonthFromFields', Calendar.prototype.yearMonthFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.yearOfWeek', Calendar.prototype.yearOfWeek);\n\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n  dateFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['year', 'day']);\n    const overflow = ES.ToTemporalOverflow(options);\n    fields = resolveNonLunisolarMonth(fields);\n    let { year, month, day } = fields;\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n    return ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n  },\n  yearMonthFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['month', 'monthCode', 'year'], ['year']);\n    const overflow = ES.ToTemporalOverflow(options);\n    fields = resolveNonLunisolarMonth(fields);\n    let { year, month } = fields;\n    ({ year, month } = ES.RegulateISOYearMonth(year, month, overflow));\n    return ES.CreateTemporalYearMonth(year, month, calendarSlotValue, /* referenceISODay = */ 1);\n  },\n  monthDayFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['day']);\n    const overflow = ES.ToTemporalOverflow(options);\n    if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n      throw new TypeError('either year or monthCode required with month');\n    }\n    const useYear = fields.monthCode === undefined;\n    const referenceISOYear = 1972;\n    fields = resolveNonLunisolarMonth(fields);\n    let { month, day, year } = fields;\n    ({ month, day } = ES.RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n    return ES.CreateTemporalMonthDay(month, day, calendarSlotValue, referenceISOYear);\n  },\n  fields(fields) {\n    return fields;\n  },\n  fieldKeysToIgnore(keys) {\n    const result = new OriginalSet();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      ES.Call(SetPrototypeAdd, result, [key]);\n      if (key === 'month') {\n        ES.Call(SetPrototypeAdd, result, ['monthCode']);\n      } else if (key === 'monthCode') {\n        ES.Call(SetPrototypeAdd, result, ['month']);\n      }\n    }\n    return [...ES.Call(SetPrototypeValues, result, [])];\n  },\n  dateAdd(date, years, months, weeks, days, overflow, calendarSlotValue) {\n    let year = GetSlot(date, ISO_YEAR);\n    let month = GetSlot(date, ISO_MONTH);\n    let day = GetSlot(date, ISO_DAY);\n    ({ year, month, day } = ES.AddISODate(year, month, day, years, months, weeks, days, overflow));\n    return ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n  },\n  dateUntil(one, two, largestUnit) {\n    return ES.DifferenceISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY),\n      largestUnit\n    );\n  },\n  year(date) {\n    return GetSlot(date, ISO_YEAR);\n  },\n  era() {\n    return undefined;\n  },\n  eraYear() {\n    return undefined;\n  },\n  month(date) {\n    return GetSlot(date, ISO_MONTH);\n  },\n  monthCode(date) {\n    return buildMonthCode(GetSlot(date, ISO_MONTH));\n  },\n  day(date) {\n    return GetSlot(date, ISO_DAY);\n  },\n  dayOfWeek(date) {\n    return ES.DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n  dayOfYear(date) {\n    return ES.DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n  weekOfYear(date) {\n    return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY)).week;\n  },\n  yearOfWeek(date) {\n    return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY)).year;\n  },\n  daysInWeek() {\n    return 7;\n  },\n  daysInMonth(date) {\n    return ES.ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n  },\n  daysInYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    return ES.LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n  },\n  monthsInYear() {\n    return 12;\n  },\n  inLeapYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    return ES.LeapYear(GetSlot(date, ISO_YEAR));\n  }\n};\n\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\n// proposal for ECMA-262. These calendars will be standardized as part of\n// ECMA-402. Code below here includes an implementation of these calendars to\n// validate the Temporal API and to get feedback. However, native non-ISO\n// calendar behavior is at least somewhat implementation-defined, so may not\n// match this polyfill's output exactly.\n//\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\n// to ensure a clean separation between the ISO calendar implementation which is\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\n// ECMA-402.\n//\n// To ensure this separation, the implementation is split. A `CalendarImpl`\n// interface defines the common operations between both ISO and non-ISO\n// calendars.\n\n/**\n * This type is passed through from Calendar#dateFromFields().\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\n */\ntype CalendarDateFields = Params['dateFromFields'][0] & { monthExtra?: string };\n\n/**\n * This is a \"fully populated\" calendar date record. It's only lacking\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\n * which is only used in some cases.\n */\ntype FullCalendarDate = {\n  era?: string;\n  eraYear?: number;\n  year: number;\n  month: number;\n  monthCode: string;\n  day: number;\n  monthExtra?: string;\n};\n\n// The types below are various subsets of calendar dates\ntype CalendarYMD = { year: number; month: number; day: number };\ntype CalendarYM = { year: number; month: number };\ntype CalendarYearOnly = { year: number };\ntype EraAndEraYear = { era: string; eraYear: number };\n\n/** Record representing YMD of an ISO calendar date */\ntype IsoYMD = { year: number; month: number; day: number };\n\ntype Overflow = NonNullable<Temporal.AssignmentOptions['overflow']>;\n\nfunction monthCodeNumberPart(monthCode: string) {\n  if (!monthCode.startsWith('M')) {\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n  }\n  const month = +monthCode.slice(1);\n  if (isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\n  return month;\n}\n\nfunction buildMonthCode(month: number | string, leap = false) {\n  return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\n  calendarDate: T,\n  overflow: Overflow | undefined = undefined,\n  monthsPerYear = 12\n) {\n  let { month, monthCode } = calendarDate;\n  if (monthCode === undefined) {\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\n    // The ISO calendar uses the default (undefined) value because it does\n    // constrain/reject after this method returns. Non-ISO calendars, however,\n    // rely on this function to constrain/reject out-of-range `month` values.\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\n    monthCode = buildMonthCode(month);\n  } else {\n    const numberPart = monthCodeNumberPart(monthCode);\n    if (month !== undefined && month !== numberPart) {\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n    }\n    if (monthCode !== buildMonthCode(numberPart)) {\n      throw new RangeError(`Invalid month code: ${monthCode}`);\n    }\n    month = numberPart;\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n  }\n  return { ...calendarDate, month, monthCode };\n}\n\ntype CachedTypes = Temporal.PlainYearMonth | Temporal.PlainDate | Temporal.PlainMonthDay;\n\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n  map = new Map();\n  calls = 0;\n  now: number;\n  hits = 0;\n  misses = 0;\n  constructor(cacheToClone?: OneObjectCache) {\n    this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n    if (cacheToClone !== undefined) {\n      let i = 0;\n      for (const entry of cacheToClone.map.entries()) {\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\n        this.map.set(...entry);\n      }\n    }\n  }\n  get(key: string) {\n    const result = this.map.get(key);\n    if (result) {\n      this.hits++;\n      this.report();\n    }\n    this.calls++;\n    return result;\n  }\n  set(key: string, value: unknown) {\n    this.map.set(key, value);\n    this.misses++;\n    this.report();\n  }\n  report() {\n    /*\n    if (this.calls === 0) return;\n    const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n    const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n    console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n    */\n  }\n  setObject(obj: CachedTypes) {\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\n    OneObjectCache.objectMap.set(obj, this);\n    this.report();\n  }\n\n  static objectMap = new WeakMap();\n  static MAX_CACHE_ENTRIES = 1000;\n\n  /**\n   * Returns a WeakMap-backed cache that's used to store expensive results\n   * that are associated with a particular Temporal object instance.\n   *\n   * @param obj - object to associate with the cache\n   */\n  static getCacheForObject(obj: CachedTypes) {\n    let cache = OneObjectCache.objectMap.get(obj);\n    if (!cache) {\n      cache = new OneObjectCache();\n      OneObjectCache.objectMap.set(obj, cache);\n    }\n    return cache;\n  }\n}\n\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\n  const yearString = ES.ISOYearString(isoYear);\n  const monthString = ES.ISODateTimePartString(isoMonth);\n  const dayString = ES.ISODateTimePartString(isoDay);\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\n\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\n  return {\n    years: one.year - two.year,\n    months: one.month - two.month,\n    days: one.day - two.day\n  };\n}\n\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nabstract class HelperBase {\n  abstract id: BuiltinCalendarId;\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\n  abstract estimateIsoDate(calendarDate: CalendarYMD): IsoYMD;\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: IsoYMD): T;\n  constantEra?: string;\n  checkIcuBugs?(isoDate: IsoYMD): void;\n  private formatter?: globalThis.Intl.DateTimeFormat;\n  getFormatter() {\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n    // calendars that are used. Note that the nonIsoHelperBase object is spread\n    // into each each calendar's implementation before any cache is created, so\n    // each calendar gets its own separate cached formatter.\n    if (typeof this.formatter === 'undefined') {\n      this.formatter = new IntlDateTimeFormat(`en-US-u-ca-${this.id}`, {\n        day: 'numeric',\n        month: 'numeric',\n        year: 'numeric',\n        era: this.eraLength,\n        timeZone: 'UTC'\n      });\n    }\n    return this.formatter;\n  }\n  isoToCalendarDate(isoDate: IsoYMD, cache: OneObjectCache): FullCalendarDate {\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n\n    const dateTimeFormat = this.getFormatter();\n    let parts, isoString;\n    try {\n      isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n      parts = dateTimeFormat.formatToParts(new Date(isoString));\n    } catch (e: unknown) {\n      throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n    }\n    const result: Partial<FullCalendarDate> = {};\n    for (let { type, value } of parts) {\n      if (type === 'year') result.eraYear = +value;\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n      if (type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) result.eraYear = +value;\n      if (type === 'month') {\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n          throw new RangeError(`Unexpected month: ${value}`);\n        }\n        // If the month has no numeric part (should only see this for the Hebrew\n        // calendar with newer FF / Chromium versions; see\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n        // placeholder month index of `1` and rely on the derived class to\n        // calculate the correct month index from the month name stored in\n        // `monthExtra`.\n        result.month = matches[1] ? +matches[1] : 1;\n        if (result.month < 1) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\n          );\n        }\n        if (result.month > 13) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n          );\n        }\n\n        // The ICU formats for the Hebrew calendar no longer support a numeric\n        // month format. So we'll rely on the derived class to interpret it.\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\n        // \"bis\" indicating a leap month.\n        if (matches[2]) result.monthExtra = matches[2];\n      }\n      if (type === 'day') result.day = +value;\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\n        // The convention for Temporal era values is lowercase, so following\n        // that convention in this prototype. Punctuation is removed, accented\n        // letters are normalized, and spaces are replaced with dashes.\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n        // The call to normalize() and the replacement regex deals with era\n        // names that contain non-ASCII characters like Japanese eras. Also\n        // ignore extra content in parentheses like JPN era date ranges.\n        value = value.split(' (')[0];\n        result.era = value\n          .normalize('NFD')\n          .replace(/[^-0-9 \\p{L}]/gu, '')\n          .replace(' ', '-')\n          .toLowerCase();\n      }\n    }\n    if (result.eraYear === undefined) {\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n      // output of Intl.DateTimeFormat.formatToParts.\n      throw new RangeError(\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n      );\n    }\n    // Translate eras that may be handled differently by Temporal vs. by Intl\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n    if (this.reviseIntlEra) {\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n      result.era = era;\n      result.eraYear = eraYear;\n    }\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\n\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.month === undefined) throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n    cache.set(key, calendarDate);\n    // Also cache the reverse mapping\n    ['constrain', 'reject'].forEach((overflow) => {\n      const keyReverse = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: calendarDate.year,\n        month: calendarDate.month,\n        day: calendarDate.day,\n        overflow,\n        id: this.id\n      });\n      cache.set(keyReverse, isoDate);\n    });\n    return calendarDate;\n  }\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\n    const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n    // the derived class must deal with it.\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\n    if (day === undefined) throw new RangeError('Missing day');\n    if (monthCode !== undefined) {\n      if (typeof monthCode !== 'string') {\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n      }\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    if (this.constantEra) {\n      if (era !== undefined && era !== this.constantEra) {\n        throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n      }\n      if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n        throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n      }\n    }\n    if (this.hasEra) {\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n      }\n    }\n  }\n  /**\n   * Allows derived calendars to add additional fields and/or to make\n   * adjustments e.g. to set the era based on the date or to revise the month\n   * number in lunisolar calendars per\n   * https://github.com/tc39/proposal-temporal/issues/1203.\n   *\n   * The base implementation fills in missing values by assuming the simplest\n   * possible calendar:\n   * - no eras or a constant era defined in `.constantEra`\n   * - non-lunisolar calendar (no leap months)\n   * */\n  adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache: OneObjectCache | undefined = undefined,\n    overflow: Overflow = 'constrain',\n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\n    let calendarDate = calendarDateParam;\n    this.validateCalendarDate(calendarDate);\n    // For calendars that always use the same era, set it here so that derived\n    // calendars won't need to implement this method simply to set the era.\n    if (this.constantEra) {\n      // year and eraYear always match when there's only one possible era\n      const { year, eraYear } = calendarDate;\n      calendarDate = {\n        ...calendarDate,\n        era: this.constantEra,\n        year: year !== undefined ? year : eraYear,\n        eraYear: eraYear !== undefined ? eraYear : year\n      };\n    }\n\n    const largestMonth = this.monthsInYear(calendarDate as CalendarYearOnly, cache);\n    let { month, monthCode } = calendarDate;\n\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\n  }\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let { month, day } = calendarDate;\n    if (overflow === 'reject') {\n      ES.RejectToRange(month, 1, largestMonth);\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n    } else {\n      month = ES.ConstrainToRange(month, 1, largestMonth);\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n    }\n    return { ...calendarDate, month, day };\n  }\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): IsoYMD {\n    const originalDate = dateParam as Partial<FullCalendarDate>;\n    // First, normalize the calendar date to ensure that (year, month, day)\n    // are all present, converting monthCode and eraYear if needed.\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\n    // not in this particular year, may not be caught here for some calendars.\n    // If so, these will be handled lower below.\n    date = this.regulateMonthDayNaive(date, overflow, cache);\n\n    const { year, month, day } = date;\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n    let cached = cache.get(key);\n    if (cached) return cached;\n    // If YMD are present in the input but the input has been constrained\n    // already, then cache both the original value and the constrained value.\n    let keyOriginal;\n    if (\n      originalDate.year !== undefined &&\n      originalDate.month !== undefined &&\n      originalDate.day !== undefined &&\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\n    ) {\n      keyOriginal = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: originalDate.year,\n        month: originalDate.month,\n        day: originalDate.day,\n        overflow,\n        id: this.id\n      });\n      cached = cache.get(keyOriginal);\n      if (cached) return cached;\n    }\n\n    // First, try to roughly guess the result\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\n    const calculateSameMonthResult = (diffDays: number) => {\n      // If the estimate is in the same year & month as the target, then we can\n      // calculate the result exactly and short-circuit any additional logic.\n      // This optimization assumes that months are continuous. It would break if\n      // a calendar skipped days, like the Julian->Gregorian switchover. But the\n      // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n      // that's currently detected by `checkIcuBugs()` which will throw. So\n      // this optimization should be safe for all ICU calendars.\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n      if (date.day > this.minimumMonthLength(date)) {\n        // There's a chance that the calendar date is out of range. Throw or\n        // constrain if so.\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n          if (overflow === 'reject') {\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n          }\n          // Back up a day at a time until we're not hanging over the month end\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        }\n      }\n      return testIsoEstimate;\n    };\n    let sign = 0;\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n    let diff = simpleDateDiff(date, roundtripEstimate);\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      diff = simpleDateDiff(date, roundtripEstimate);\n      if (diff.years === 0 && diff.months === 0) {\n        isoEstimate = calculateSameMonthResult(diff.days);\n      } else {\n        sign = this.compareCalendarDates(date, roundtripEstimate);\n      }\n    }\n    // If the initial guess is not in the same month, then then bisect the\n    // distance to the target, starting with 8 days per step.\n    let increment = 8;\n    while (sign) {\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n      const oldRoundtripEstimate = roundtripEstimate;\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      const oldSign = sign;\n      sign = this.compareCalendarDates(date, roundtripEstimate);\n      if (sign) {\n        diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years === 0 && diff.months === 0) {\n          isoEstimate = calculateSameMonthResult(diff.days);\n          // Signal the loop condition that there's a match.\n          sign = 0;\n        } else if (oldSign && sign !== oldSign) {\n          if (increment > 1) {\n            // If the estimate overshot the target, try again with a smaller increment\n            // in the reverse direction.\n            increment /= 2;\n          } else {\n            // Increment is 1, and neither the previous estimate nor the new\n            // estimate is correct. The only way that can happen is if the\n            // original date was an invalid value that will be constrained or\n            // rejected here.\n            if (overflow === 'reject') {\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n            } else {\n              // To constrain, pick the earliest value\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n              // If current value is larger, then back up to the previous value.\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\n              sign = 0;\n            }\n          }\n        }\n      }\n    }\n    cache.set(key, isoEstimate);\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\n    if (\n      date.year === undefined ||\n      date.month === undefined ||\n      date.day === undefined ||\n      date.monthCode === undefined ||\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\n    ) {\n      throw new RangeError('Unexpected missing property');\n    }\n    return isoEstimate;\n  }\n  temporalToCalendarDate(\n    date: Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n    const result = this.isoToCalendarDate(isoDate, cache);\n    return result;\n  }\n  compareCalendarDates(date1Param: Partial<CalendarYMD>, date2Param: Partial<CalendarYMD>): 0 | 1 | -1 {\n    // `date1` and `date2` are already records. The calls below simply validate\n    // that all three required fields are present.\n    const date1 = ES.PrepareTemporalFields(date1Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n    const date2 = ES.PrepareTemporalFields(date2Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\n    return 0;\n  }\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n    return this.isoToCalendarDate(isoDate, cache);\n  }\n  addDaysIso(isoDate: IsoYMD, days: number): IsoYMD {\n    const added = ES.AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n    return added;\n  }\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIso = this.addDaysIso(isoDate, days);\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n    return addedCalendar;\n  }\n  addMonthsCalendar(\n    calendarDateParam: CalendarYMD,\n    months: number,\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): CalendarYMD {\n    let calendarDate = calendarDateParam;\n    const { day } = calendarDate;\n    for (let i = 0, absMonths = MathAbs(months); i < absMonths; i++) {\n      const { month } = calendarDate;\n      const oldCalendarDate = calendarDate;\n      const days =\n        months < 0\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n          : this.daysInMonth(calendarDate, cache);\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n      let addedIso = this.addDaysIso(isoDate, days);\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\n\n      // Normally, we can advance one month by adding the number of days in the\n      // current month. However, if we're at the end of the current month and\n      // the next month has fewer days, then we rolled over to the after-next\n      // month. Below we detect this condition and back up until we're back in\n      // the desired month.\n      if (months > 0) {\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\n          addedIso = this.addDaysIso(addedIso, -1);\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\n        }\n      }\n\n      if (calendarDate.day !== day) {\n        // try to retain the original day-of-month, if possible\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n      }\n    }\n    if (overflow === 'reject' && calendarDate.day !== day) {\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n    }\n    return calendarDate;\n  }\n  addCalendar(\n    calendarDate: CalendarYMD & { monthCode: string },\n    { years = 0, months = 0, weeks = 0, days = 0 },\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const { year, day, monthCode } = calendarDate;\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\n    const initialDays = days + weeks * 7;\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n    return addedDays;\n  }\n  untilCalendar(\n    calendarOne: FullCalendarDate,\n    calendarTwo: FullCalendarDate,\n    largestUnit: Temporal.DateUnit,\n    cache: OneObjectCache\n  ): { years: number; months: number; weeks: number; days: number } {\n    let days = 0;\n    let weeks = 0;\n    let months = 0;\n    let years = 0;\n    switch (largestUnit) {\n      case 'day':\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        break;\n      case 'week': {\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        days = totalDays % 7;\n        weeks = (totalDays - days) / 7;\n        break;\n      }\n      case 'month':\n      case 'year': {\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n        if (!sign) {\n          return { years: 0, months: 0, weeks: 0, days: 0 };\n        }\n        const diffYears = calendarTwo.year - calendarOne.year;\n        const diffDays = calendarTwo.day - calendarOne.day;\n        if (largestUnit === 'year' && diffYears) {\n          let diffInYearSign = 0;\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\n        }\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n        // Now we have less than one year remaining. Add one month at a time\n        // until we go over the target, then back up one month and calculate\n        // remaining days and weeks.\n        let current;\n        let next: CalendarYMD = yearsAdded;\n        do {\n          months += sign;\n          current = next;\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n          if (next.day !== calendarOne.day) {\n            // In case the day was constrained down, try to un-constrain it\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n          }\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n        months -= sign; // correct for loop above which overshoots by 1\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n        days = remainingDays;\n        break;\n      }\n    }\n    return { years, months, weeks, days };\n  }\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    // Add enough days to roll over to the next month. One we're in the next\n    // month, we can calculate the length of the current month. NOTE: This\n    // algorithm assumes that months are continuous. It would break if a\n    // calendar skipped days, like the Julian->Gregorian switchover. But the\n    // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n    // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n    // that's currently detected by `checkIcuBugs()` which will throw. So this\n    // code should be safe for all ICU calendars.\n    const { day } = calendarDate;\n    const max = this.maximumMonthLength(calendarDate);\n    const min = this.minimumMonthLength(calendarDate);\n    // easiest case: we already know the month length if min and max are the same.\n    if (min === max) return min;\n\n    // Add enough days to get into the next month, without skipping it\n    const increment = day <= max - min ? max : min;\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n\n    // Now back up to the last day of the original month\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n    return endOfMonthCalendar.day;\n  }\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    const { day, month, year } = calendarDate;\n\n    // Check to see if we already know the month length, and return it if so\n    const previousMonthYear = month > 1 ? year : year - 1;\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\n    const min = this.minimumMonthLength(previousMonthDate);\n    const max = this.maximumMonthLength(previousMonthDate);\n    if (min === max) return max;\n\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n    return lastDayOfPreviousMonthCalendar.day;\n  }\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n  }\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n  }\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n    return this.isoDaysUntil(oneIso, twoIso);\n  }\n  isoDaysUntil(oneIso: IsoYMD, twoIso: IsoYMD): number {\n    const duration = ES.DifferenceISODate(\n      oneIso.year,\n      oneIso.month,\n      oneIso.day,\n      twoIso.year,\n      twoIso.month,\n      twoIso.day,\n      'day'\n    );\n    return duration.days;\n  }\n  // The short era format works for all calendars except Japanese, which will\n  // override.\n  eraLength: Intl.DateTimeFormatOptions['era'] = 'short';\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  hasEra = true;\n  // See https://github.com/tc39/proposal-temporal/issues/1784\n  erasBeginMidYear = false;\n  monthDayFromFields(fields: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): IsoYMD {\n    let { monthCode, day } = fields;\n    if (monthCode === undefined) {\n      let { year, era, eraYear } = fields;\n      if (year === undefined && (era === undefined || eraYear === undefined)) {\n        throw new TypeError('when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required');\n      }\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\n    }\n\n    let isoYear, isoMonth, isoDay;\n    let closestCalendar, closestIso;\n    // Look backwards starting from one of the calendar years spanning ISO year\n    // 1972, up to 100 calendar years prior, to find a year that has this month\n    // and day. Normal months and days will match immediately, but for leap days\n    // and leap months we may have to look for a while.\n    const startDateIso = { year: 1972, month: 12, day: 31 };\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\n    // Note: relies on lexicographical ordering of monthCodes\n    const calendarYear =\n      calendarOfStartDateIso.monthCode > monthCode ||\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\n        ? calendarOfStartDateIso.year\n        : calendarOfStartDateIso.year - 1;\n    for (let i = 0; i < 100; i++) {\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\n        { day, monthCode, year: calendarYear - i },\n        cache\n      );\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n        return { month: isoMonth, day: isoDay, year: isoYear };\n      } else if (overflow === 'constrain') {\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\n        if (\n          closestCalendar === undefined ||\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n            roundTripCalendarDate.day > closestCalendar.day)\n        ) {\n          closestCalendar = roundTripCalendarDate;\n          closestIso = isoDate;\n        }\n      }\n    }\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n  }\n}\n\ninterface HebrewMonthInfo {\n  [m: string]: (\n    | {\n        leap: undefined;\n        regular: number;\n      }\n    | {\n        leap: number;\n        regular: undefined;\n      }\n    | {\n        leap: number;\n        regular: number;\n      }\n  ) & {\n    monthCode: string;\n    days:\n      | number\n      | {\n          min: number;\n          max: number;\n        };\n  };\n}\n\nclass HebrewHelper extends HelperBase {\n  id = 'hebrew' as const;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    const { year } = calendarDate;\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\n    // also has per-year changes to the number of days of Heshvan and Kislev.\n    // Given that these can be calculated by counting the number of days in\n    // those months, I assume that these DO NOT need to be exposed as\n    // Hebrew-only prototype fields or methods.\n    return (7 * year + 1) % 19 < 7;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly) {\n    return this.inLeapYear(calendarDate) ? 13 : 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'min');\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'max');\n  }\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\n    const { month, year } = calendarDate;\n    const monthCode = this.getMonthCode(year, month);\n    const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\n    const daysInMonth = monthInfo[1].days;\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n  }\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = calendarDate;\n    return { year: year - 3760, month: 1, day: 1 };\n  }\n  months: HebrewMonthInfo = {\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n  };\n  getMonthCode(year: number, month: number) {\n    if (this.inLeapYear({ year })) {\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n    } else {\n      return buildMonthCode(month);\n    }\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    // The incoming type is actually CalendarDate (same as args to\n    // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n    // reassignments below, so as an alternative to 10+ type casts, we'll lie\n    // here and claim that the type has `day` and `year` filled in already.\n    let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate as Omit<\n      typeof calendarDate,\n      'year' | 'day'\n    > & { year: number; day: number };\n    if (year === undefined && eraYear !== undefined) year = eraYear;\n    if (eraYear === undefined && year !== undefined) eraYear = year;\n    if (fromLegacyDate) {\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n      // output returns the numeric equivalent of `month` as a string, meaning\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n      // means Adar. In this case, `month` will already be correct and no action\n      // is needed. However, in Node 14 and later formatToParts returns the name\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n      // correct `month` using the string name as a key.\n      if (monthExtra) {\n        const monthInfo = this.months[monthExtra];\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n      }\n      // Because we're getting data from legacy Date, then `month` will always be present\n      monthCode = this.getMonthCode(year, month as number);\n      const result = { year, month: month as number, day, era: undefined as string | undefined, eraYear, monthCode };\n      return result;\n    } else {\n      // When called without input coming from legacy Date output, simply ensure\n      // that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (month === undefined) {\n        if ((monthCode as string).endsWith('L')) {\n          if (monthCode !== 'M05L') {\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n          }\n          month = 6;\n          if (!this.inLeapYear({ year })) {\n            if (overflow === 'reject') {\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n            } else {\n              // constrain to same day of next month (Adar)\n              month = 6;\n              monthCode = 'M06';\n            }\n          }\n        } else {\n          month = monthCodeNumberPart(monthCode as string);\n          // if leap month is before this one, the month index is one more than the month code\n          if (this.inLeapYear({ year }) && month >= 6) month++;\n          const largestMonth = this.monthsInYear({ year });\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n      } else {\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n        } else {\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n        }\n        if (monthCode === undefined) {\n          monthCode = this.getMonthCode(year, month);\n        } else {\n          const calculatedMonthCode = this.getMonthCode(year, month);\n          if (calculatedMonthCode !== monthCode) {\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n          }\n        }\n      }\n      return { ...calendarDate, day, month, monthCode: monthCode as string, year, eraYear };\n    }\n  }\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  override hasEra = false;\n}\n\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nabstract class IslamicBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // In leap years, the 12th month has 30 days. In non-leap years: 29.\n    const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n    return days === 30;\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n  DAYS_PER_ISO_YEAR = 365.2425;\n  override constantEra = 'ah';\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: MathFloor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n  }\n}\n\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n  id = 'islamic' as const;\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n  id = 'islamic-umalqura' as const;\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n  id = 'islamic-tbla' as const;\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n  id = 'islamic-civil' as const;\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n  id = 'islamic-rgsa' as const;\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n  id = 'islamicc' as const;\n}\n\nclass PersianHelper extends HelperBase {\n  id = 'persian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // Same logic (count days in the last month) for Persian as for Islamic,\n    // even though Persian is solar and Islamic is lunar.\n    return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 29;\n    return month <= 6 ? 31 : 30;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 30;\n    return month <= 6 ? 31 : 30;\n  }\n  override constantEra = 'ap';\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: year + 621, month: 1, day: 1 };\n  }\n}\n\ninterface IndianMonthInfo {\n  [month: number]: {\n    length: number;\n    month: number;\n    day: number;\n    leap?: {\n      length: number;\n      month: number;\n      day: number;\n    };\n    nextYear?: true | undefined;\n  };\n}\n\nclass IndianHelper extends HelperBase {\n  id = 'indian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\n    // the result is a leap year in the Gregorian calendar, then the Saka year\n    // is a leap year as well.\n    return isGregorianLeapYear(calendarDate.year + 78);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  override constantEra = 'saka';\n  // Indian months always start at the same well-known Gregorian month and\n  // day. So this conversion is easy and fast. See\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\n  months: IndianMonthInfo = {\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n    2: { length: 31, month: 4, day: 21 },\n    3: { length: 31, month: 5, day: 22 },\n    4: { length: 31, month: 6, day: 22 },\n    5: { length: 31, month: 7, day: 23 },\n    6: { length: 31, month: 8, day: 23 },\n    7: { length: 30, month: 9, day: 23 },\n    8: { length: 30, month: 10, day: 23 },\n    9: { length: 30, month: 11, day: 22 },\n    10: { length: 30, month: 12, day: 22 },\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\n  };\n  getMonthInfo(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    let monthInfo = this.months[month];\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\n    return monthInfo;\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n    // calendar fast!\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const monthInfo = this.getMonthInfo(calendarDate);\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n    const isoMonth = monthInfo.month;\n    const isoDay = monthInfo.day;\n    const isoDate = ES.AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n    return isoDate;\n  }\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n  // expected.\n  vulnerableToBceBug =\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n  override checkIcuBugs(isoDate: IsoYMD) {\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\n      throw new RangeError(\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n      );\n    }\n  }\n}\n\n/**\n * Era metadata defined for each calendar.\n * TODO: instead of optional properties, this should really have rules\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\n *  */\ninterface InputEra {\n  /** name of the era */\n  name: string;\n\n  /**\n   * Signed calendar year where this era begins.Will be\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\n   * numbering starts at the beginning of the anchor era, which is true\n   * for all ICU calendars except Japanese. If an era starts mid-year\n   * then a calendar month and day are included. Otherwise\n   * `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch?: { year: number; month: number; day: number };\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: string;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n/**\n * Transformation of the `InputEra` type with all fields filled in by\n * `adjustEras()`\n * */\ninterface Era {\n  /** name of the era */\n  name: string;\n\n  /**\n   * alternate name of the era used in old versions of ICU data\n   * format is `era{n}` where n is the zero-based index of the era\n   * with the oldest era being 0.\n   * */\n  genericName: string;\n\n  /**\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\n   * eras) for the anchor era assuming that `year` numbering starts at the\n   * beginning of the anchor era, which is true for all ICU calendars except\n   * Japanese. For input, the month and day are optional. If an era starts\n   * mid-year then a calendar month and day are included.\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch: CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch: IsoYMD;\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: Era;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\n  let eras: (InputEra | Era)[] = erasParam;\n  if (eras.length === 0) {\n    throw new RangeError('Invalid era data: eras are required');\n  }\n  if (eras.length === 1 && eras[0].reverseOf) {\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n  }\n  if (eras.length === 1 && !eras[0].name) {\n    throw new RangeError('Invalid era data: at least one named era is required');\n  }\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\n    throw new RangeError('Invalid era data: only one era can count years backwards');\n  }\n\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\n  // anchor.\n  let anchorEra: Era | InputEra | undefined;\n  eras.forEach((e) => {\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n      anchorEra = e;\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n    } else if (!e.name) {\n      throw new RangeError('If era name is blank, it must be the anchor era');\n    }\n  });\n\n  // If the era name is undefined, then it's an anchor that doesn't interact\n  // with eras at all. For example, Japanese `year` is always the same as ISO\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n  // Strip it from the list that's returned.\n  eras = eras.filter((e) => e.name);\n\n  eras.forEach((e) => {\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n    // Replace the string-valued \"reverseOf\" property with the actual era object\n    // that's reversed.\n    const { reverseOf } = e;\n    if (reverseOf) {\n      const reversedEra = eras.find((era) => era.name === reverseOf);\n      if (reversedEra === undefined) throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n      e.reverseOf = reversedEra as Era;\n      e.anchorEpoch = reversedEra.anchorEpoch;\n      e.isoEpoch = reversedEra.isoEpoch;\n    }\n    type YMD = {\n      year: number;\n      month: number;\n      day: number;\n    };\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\n  });\n\n  // Ensure that the latest epoch is first in the array. This lets us try to\n  // match eras in index order, with the last era getting the remaining older\n  // years. Any reverse-signed era must be at the end.\n  ArraySort.call(eras, (e1, e2) => {\n    if (e1.reverseOf) return 1;\n    if (e2.reverseOf) return -1;\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\n    return e2.isoEpoch.year - e1.isoEpoch.year;\n  });\n\n  // If there's a reversed era, then the one before it must be the era that's\n  // being reversed.\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\n  if (lastEraReversed) {\n    if (lastEraReversed !== eras[eras.length - 2]) throw new RangeError('Invalid era data: invalid reverse-sign era');\n  }\n\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n  // zero-based index, with the oldest era being zero. This format is used by\n  // older versions of ICU data.\n  eras.forEach((e, i) => {\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\n  });\n\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\n}\n\nfunction isGregorianLeapYear(year: number) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n/** Base for all Gregorian-like calendars. */\nabstract class GregorianBaseHelper extends HelperBase {\n  id: BuiltinCalendarId;\n  eras: Era[];\n  anchorEra: Era;\n\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super();\n    this.id = id;\n    const { eras, anchorEra } = adjustEras(originalEras);\n    this.anchorEra = anchorEra;\n    this.eras = eras;\n  }\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // Calendars that don't override this method use the same months and leap\n    // years as Gregorian. Once we know the ISO year corresponding to the\n    // calendar year, we'll know if it's a leap year or not.\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n    return isGregorianLeapYear(year);\n  }\n  monthsInYear(/* calendarDate */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM): number {\n    const { month } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n  maximumMonthLength(calendarDate: CalendarYM): number {\n    return this.minimumMonthLength(calendarDate);\n  }\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\n  completeEraYear(calendarDate: Partial<FullCalendarDate>) {\n    const checkField = (name: keyof FullCalendarDate, value: string | number | undefined) => {\n      const currentValue = calendarDate[name];\n      if (currentValue != null && currentValue != value) {\n        throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n      }\n    };\n    const eraFromYear = (year: number) => {\n      let eraYear;\n      const adjustedCalendarDate = { ...calendarDate, year };\n      const matchingEra = this.eras.find((e, i) => {\n        if (i === this.eras.length - 1) {\n          if (e.reverseOf) {\n            // This is a reverse-sign era (like BCE) which must be the oldest\n            // era. Count years backwards.\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n            eraYear = e.anchorEpoch.year - year;\n            return true;\n          }\n          // last era always gets all \"leftover\" (older than epoch) years,\n          // so no need for a comparison like below.\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n        if (comparison >= 0) {\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        return false;\n      });\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\n      return { eraYear: eraYear as unknown as number, era: matchingEra.name };\n    };\n\n    let { year, eraYear, era } = calendarDate;\n    if (year != null) {\n      ({ eraYear, era } = eraFromYear(year));\n      checkField('era', era);\n      checkField('eraYear', eraYear);\n    } else if (eraYear != null) {\n      const matchingEra =\n        era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n      if (eraYear < 1 && matchingEra.reverseOf) {\n        throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n      }\n      if (matchingEra.reverseOf) {\n        year = matchingEra.anchorEpoch.year - eraYear;\n      } else {\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n      }\n      checkField('year', year);\n      // We'll accept dates where the month/day is earlier than the start of\n      // the era or after its end as long as it's in the same year. If that\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\n      // the `year`.\n      ({ eraYear, era } = eraFromYear(year));\n    } else {\n      throw new RangeError('Either `year` or `eraYear` and `era` are required');\n    }\n    return { ...calendarDate, year, eraYear, era };\n  }\n  override adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain'\n  ): FullCalendarDate {\n    let calendarDate = calendarDateParam;\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n    const { month, monthCode } = calendarDate;\n    if (month === undefined) calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode as string) };\n    this.validateCalendarDate(calendarDate);\n    calendarDate = this.completeEraYear(calendarDate);\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const { year, month, day } = calendarDate;\n    const { anchorEra } = this;\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n  }\n  // Several calendars based on the Gregorian calendar use Julian dates (not\n  // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n  v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n    .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n    .startsWith('12');\n  calendarIsVulnerableToJulianBug = false;\n  override checkIcuBugs(isoDate: IsoYMD) {\n    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n      const beforeJulianSwitch = ES.CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n      if (beforeJulianSwitch) {\n        throw new RangeError(\n          `calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n            ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)'\n        );\n      }\n    }\n  }\n}\n\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super(id, originalEras);\n  }\n  override inLeapYear(calendarDate: CalendarYearOnly) {\n    // Leap years happen one year before the Julian leap year. Note that this\n    // calendar is based on the Julian calendar which has a leap year every 4\n    // years, unlike the Gregorian calendar which doesn't have leap years on\n    // years divisible by 100 except years divisible by 400.\n    //\n    // Note that we're assuming that leap years in before-epoch times match\n    // how leap years are defined now. This is probably not accurate but I'm\n    // not sure how better to do it.\n    const { year } = calendarDate;\n    return (year + 1) % 4 === 0;\n  }\n  override monthsInYear(/* calendarDate */) {\n    return 13;\n  }\n  override minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\n    return 30;\n  }\n  override maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minimumMonthLength(calendarDate);\n  }\n}\n\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n  }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('coptic', [\n      { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n      { name: 'era0', reverseOf: 'era1' }\n    ]);\n  }\n}\n\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethiopic', [\n      { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n      { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n    ]);\n  }\n}\n\nclass RocHelper extends GregorianBaseHelper {\n  constructor() {\n    super('roc', [\n      { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n      { name: 'before-roc', reverseOf: 'minguo' }\n    ]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n}\n\nclass BuddhistHelper extends GregorianBaseHelper {\n  constructor() {\n    super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n}\n\nclass GregoryHelper extends GregorianBaseHelper {\n  constructor() {\n    super('gregory', [\n      { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n      { name: 'bce', reverseOf: 'ce' }\n    ]);\n  }\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\n    let { era, eraYear } = calendarDate;\n    // Firefox 96 introduced a bug where the `'short'` format of the era\n    // option mistakenly returns the one-letter (narrow) format instead. The\n    // code below handles either the correct or Firefox-buggy format. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n    if (era === 'bc' || era === 'b') era = 'bce';\n    if (era === 'ad' || era === 'a') era = 'ce';\n    return { era, eraYear } as T;\n  }\n}\n\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n  constructor() {\n    super('japanese', [\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n      { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n      { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n      { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n      { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n      { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n      { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n      { name: 'bce', reverseOf: 'ce' }\n    ]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n\n  // The last 3 Japanese eras confusingly return only one character in the\n  // default \"short\" era, so need to use the long format.\n  override eraLength = 'long' as const;\n\n  override erasBeginMidYear = true;\n\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: IsoYMD): T {\n    const { era, eraYear } = calendarDate;\n    const { year: isoYear } = isoDate;\n    if (this.eras.find((e) => e.name === era)) return { era, eraYear } as T;\n    return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear }) as T;\n  }\n}\n\ninterface ChineseMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth: number };\n}\ninterface ChineseDraftMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth?: number };\n}\n\nabstract class ChineseBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    const months = this.getMonthList(calendarDate.year, cache);\n    return ObjectEntries(months).length === 13;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\n    if (calendarYear === undefined) {\n      throw new TypeError('Missing year');\n    }\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n    const dateTimeFormat = this.getFormatter();\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n      const legacyDate = new Date(isoStringFeb1);\n      // Now add the requested number of days, which may wrap to the next month.\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n      const calendarMonthString = (newYearGuess.find((tv) => tv.type === 'month') as Intl.DateTimeFormatPart).value;\n      const calendarDay = +(newYearGuess.find((tv) => tv.type === 'day') as Intl.DateTimeFormatPart).value;\n      let calendarYearToVerify: globalThis.Intl.DateTimeFormatPart | number | undefined = newYearGuess.find(\n        (tv) => (tv.type as string) === 'relatedYear'\n      );\n      if (calendarYearToVerify !== undefined) {\n        calendarYearToVerify = +calendarYearToVerify.value;\n      } else {\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n        // output of Intl.DateTimeFormat.formatToParts.\n        throw new RangeError(\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n        );\n      }\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\n    };\n\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\n    // the first month or near the end of the last month of the previous year.\n    let isoDaysDelta = 17;\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n\n    // If we didn't guess the first month correctly, add (almost in some months)\n    // a lunar month\n    if (calendarMonthString !== '1') {\n      isoDaysDelta += 29;\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n    }\n\n    // Now back up to near the start of the first month, but not too near that\n    // off-by-one issues matter.\n    isoDaysDelta -= calendarDay - 5;\n    const result = {} as ChineseDraftMonthInfo;\n    let monthIndex = 1;\n    let oldCalendarDay: number | undefined;\n    let oldMonthString: string | undefined;\n    let done = false;\n    do {\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n      if (oldCalendarDay) {\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\n      }\n      if (calendarYearToVerify !== calendarYear) {\n        done = true;\n      } else {\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\n        // Move to the next month. Because months are sometimes 29 days, the day of the\n        // calendar month will move forward slowly but not enough to flip over to a new\n        // month before the loop ends at 12-13 months.\n        isoDaysDelta += 30;\n      }\n      oldCalendarDay = calendarDay;\n      oldMonthString = calendarMonthString;\n    } while (!done);\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n\n    cache.set(key, result);\n    return result as ChineseMonthInfo;\n  }\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year, month } = calendarDate;\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n    if (fromLegacyDate) {\n      // Legacy Date output returns a string that's an integer with an optional\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n      // month. Below we'll normalize the output.\n      year = eraYear;\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\n      const monthString = `${month}${monthExtra || ''}`;\n      const months = this.getMonthList(year as number, cache);\n      const monthInfo = months[monthString];\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n      month = monthInfo.monthIndex;\n      return { year: year as number, month, day: day as number, era: undefined, eraYear, monthCode };\n    } else {\n      // When called without input coming from legacy Date output,\n      // simply ensure that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (year === undefined) year = eraYear;\n      if (eraYear === undefined) eraYear = year;\n      if (month === undefined) {\n        ES.assertExists(monthCode);\n        const months = this.getMonthList(year as number, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        let monthInfo = months[numberPart];\n        month = monthInfo && monthInfo.monthIndex;\n\n        // If this leap month isn't present in this year, constrain to the same\n        // day of the previous month.\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\n          let withoutML = monthCode.slice(1, -1);\n          if (withoutML[0] === '0') withoutML = withoutML.slice(1);\n          monthInfo = months[withoutML];\n          if (monthInfo) {\n            month = monthInfo.monthIndex;\n            monthCode = buildMonthCode(withoutML);\n          }\n        }\n        if (month === undefined) {\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n        }\n      } else if (monthCode === undefined) {\n        const months = this.getMonthList(year as number, cache);\n        const monthEntries = ObjectEntries(months);\n        const largestMonth = monthEntries.length;\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, largestMonth);\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\n        } else {\n          month = ES.ConstrainToRange(month, 1, largestMonth);\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n        }\n        const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n        if (matchingMonthEntry === undefined) {\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n        }\n        monthCode = buildMonthCode(\n          matchingMonthEntry[0].replace('bis', ''),\n          matchingMonthEntry[0].indexOf('bis') !== -1\n        );\n      } else {\n        // Both month and monthCode are present. Make sure they don't conflict.\n        const months = this.getMonthList(year as number, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        const monthInfo = months[numberPart];\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n        if (month !== monthInfo.monthIndex) {\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n        }\n      }\n      return {\n        ...calendarDate,\n        year: year as number,\n        eraYear,\n        month,\n        monthCode: monthCode,\n        day: day as number\n      };\n    }\n  }\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  override hasEra = false;\n}\n\nclass ChineseHelper extends ChineseBaseHelper {\n  id = 'chinese' as const;\n}\n\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n  id = 'dangi' as const;\n}\n\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nclass NonIsoCalendar implements CalendarImpl {\n  constructor(private readonly helper: HelperBase) {}\n  dateFromFields(\n    fieldsParam: Params['dateFromFields'][0],\n    options: NonNullable<Params['dateFromFields'][1]>,\n    calendarSlotValue: string\n  ): Temporal.PlainDate {\n    const cache = new OneObjectCache();\n    const fieldNames = this.fields(['day', 'month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n    const result = ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n    cache.setObject(result);\n    return result;\n  }\n  yearMonthFromFields(\n    fieldsParam: Params['yearMonthFromFields'][0],\n    options: NonNullable<Params['yearMonthFromFields'][1]>,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainYearMonth {\n    const cache = new OneObjectCache();\n    const fieldNames = this.fields(['month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n    const result = ES.CreateTemporalYearMonth(year, month, calendarSlotValue, /* referenceISODay = */ day);\n    cache.setObject(result);\n    return result;\n  }\n  monthDayFromFields(\n    fieldsParam: Params['monthDayFromFields'][0],\n    options: NonNullable<Params['monthDayFromFields'][1]>,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainMonthDay {\n    const cache = new OneObjectCache();\n    // For lunisolar calendars, either `monthCode` or `year` must be provided\n    // because `month` is ambiguous without a year or a code.\n    const fieldNames = this.fields(['day', 'month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n    // `year` is a reference year where this month/day exists in this calendar\n    const result = ES.CreateTemporalMonthDay(month, day, calendarSlotValue, /* referenceISOYear = */ year);\n    cache.setObject(result);\n    return result;\n  }\n  fields(fieldsParam: string[]): string[] {\n    let fields = fieldsParam;\n    if (ArrayIncludes.call(fields, 'year')) fields = [...fields, 'era', 'eraYear'];\n    return fields;\n  }\n  fieldKeysToIgnore(\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\n    const result = new OriginalSet();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      ES.Call(SetPrototypeAdd, result, [key]);\n      switch (key) {\n        case 'era':\n          ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          ES.Call(SetPrototypeAdd, result, ['year']);\n          break;\n        case 'eraYear':\n          ES.Call(SetPrototypeAdd, result, ['era']);\n          ES.Call(SetPrototypeAdd, result, ['year']);\n          break;\n        case 'year':\n          ES.Call(SetPrototypeAdd, result, ['era']);\n          ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          break;\n        case 'month':\n          ES.Call(SetPrototypeAdd, result, ['monthCode']);\n          // See https://github.com/tc39/proposal-temporal/issues/1784\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n        case 'monthCode':\n          ES.Call(SetPrototypeAdd, result, ['month']);\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n        case 'day':\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n      }\n    }\n    return [...ES.Call(SetPrototypeValues, result, [])];\n  }\n  dateAdd(\n    date: Temporal.PlainDate,\n    years: number,\n    months: number,\n    weeks: number,\n    days: number,\n    overflow: Overflow,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainDate {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n    const { year, month, day } = isoAdded;\n    const newTemporalObject = ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n    // The new object's cache starts with the cache of the old object\n    const newCache = new OneObjectCache(cache);\n    newCache.setObject(newTemporalObject);\n    return newTemporalObject;\n  }\n  dateUntil(one: Temporal.PlainDate, two: Temporal.PlainDate, largestUnit: Temporal.DateUnit) {\n    const cacheOne = OneObjectCache.getCacheForObject(one);\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\n    const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n    const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n    return result;\n  }\n  year(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.year;\n  }\n  month(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.month;\n  }\n  day(date: Temporal.PlainDate | Temporal.PlainMonthDay): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.day;\n  }\n  era(date: Temporal.PlainDate | Temporal.PlainYearMonth): string | undefined {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.era;\n  }\n  eraYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number | undefined {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.eraYear;\n  }\n  monthCode(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): string {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.monthCode;\n  }\n  dayOfWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].dayOfWeek(date);\n  }\n  dayOfYear(date: Temporal.PlainDate): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.isoToCalendarDate(date, cache);\n    const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n    const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n    return diffDays + 1;\n  }\n  weekOfYear(date: Temporal.PlainDate): number {\n    return impl['iso8601'].weekOfYear(date);\n  }\n  yearOfWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].yearOfWeek(date);\n  }\n  daysInWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].daysInWeek(date);\n  }\n  daysInMonth(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n\n    // Easy case: if the helper knows the length without any heavy calculation.\n    const max = this.helper.maximumMonthLength(calendarDate);\n    const min = this.helper.minimumMonthLength(calendarDate);\n    if (max === min) return max;\n\n    // The harder case is where months vary every year, e.g. islamic calendars.\n    // Find the answer by calculating the difference in days between the first\n    // day of the current month and the first day of the next month.\n    const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n    const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n    return result;\n  }\n  daysInYear(dateParam: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n    const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    return result;\n  }\n  monthsInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.monthsInYear(calendarDate, cache);\n    return result;\n  }\n  inLeapYear(dateParam: Temporal.PlainDate | Temporal.PlainYearMonth): boolean {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.inLeapYear(calendarDate, cache);\n    return result;\n  }\n}\n\nfor (const Helper of [\n  HebrewHelper,\n  PersianHelper,\n  EthiopicHelper,\n  EthioaaHelper,\n  CopticHelper,\n  ChineseHelper,\n  DangiHelper,\n  RocHelper,\n  IndianHelper,\n  BuddhistHelper,\n  GregoryHelper,\n  JapaneseHelper,\n  IslamicHelper,\n  IslamicUmalquraHelper,\n  IslamicTblaHelper,\n  IslamicCivilHelper,\n  IslamicRgsaHelper,\n  IslamicCcHelper\n]) {\n  const helper = new Helper();\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\n  // per-calendar logic.\n  impl[helper.id] = new NonIsoCalendar(helper);\n}\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\n\nexport class PlainDate implements Temporal.PlainDate {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    isoDayParam: Params['constructor'][2],\n    calendarParam: Params['constructor'][3] = 'iso8601'\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get yearOfWeek(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalDateLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalDateLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialDate = ES.PrepareTemporalFields(temporalDateLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarDateFromFields(calendar, fields, options);\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], optionsParam: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    const duration = ES.ToTemporalDuration(temporalDurationLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    optionsParam: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    const duration = ES.CreateNegatedTemporalDuration(ES.ToTemporalDuration(temporalDurationLike));\n    const options = ES.GetOptionsObject(optionsParam);\n\n    return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalDate(otherParam);\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalDateToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n  }\n  toPlainDateTime(temporalTimeParam: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    if (temporalTimeParam === undefined) return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n\n    const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    type TimeZoneAndPlainTimeProps = Exclude<typeof item, string | Temporal.TimeZoneProtocol>;\n    let timeZone: Temporal.TimeZoneLike, temporalTime: TimeZoneAndPlainTimeProps['plainTime'];\n    if (ES.IsObject(item)) {\n      if (ES.IsTemporalTimeZone(item)) {\n        timeZone = item;\n      } else {\n        const timeZoneLike = (item as TimeZoneAndPlainTimeProps).timeZone;\n        if (timeZoneLike === undefined) {\n          ES.uncheckedAssertNarrowedType<Temporal.TimeZoneProtocol>(\n            item,\n            \"if no timeZone property, then assume it's a custom time zone object\"\n          );\n          timeZone = ES.ToTemporalTimeZoneSlotValue(item);\n        } else {\n          timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneLike);\n          ES.uncheckedAssertNarrowedType<TimeZoneAndPlainTimeProps>(\n            item,\n            \"it's a property bag with a timeZone and optional plainTime\"\n          );\n          temporalTime = item.plainTime;\n        }\n      }\n    } else {\n      timeZone = ES.ToTemporalTimeZoneSlotValue(item);\n    }\n\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    let hour = 0,\n      minute = 0,\n      second = 0,\n      millisecond = 0,\n      microsecond = 0,\n      nanosecond = 0;\n    if (temporalTime !== undefined) {\n      temporalTime = ES.ToTemporalTime(temporalTime);\n      ES.uncheckedAssertNarrowedType<Temporal.PlainTime>(\n        temporalTime,\n        'ToTemporalTime above always returns a PlainTime'\n      );\n      hour = GetSlot(temporalTime, ISO_HOUR);\n      minute = GetSlot(temporalTime, ISO_MINUTE);\n      second = GetSlot(temporalTime, ISO_SECOND);\n      millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n      microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n      nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n    }\n\n    const dt = ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalDate(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalDate(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalDate(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    return ES.CompareISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY)\n    );\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\n}\n\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\n\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\n\nexport class PlainDateTime implements Temporal.PlainDateTime {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    isoDayParam: Params['constructor'][2],\n    hourParam: Params['constructor'][3] = 0,\n    minuteParam: Params['constructor'][4] = 0,\n    secondParam: Params['constructor'][5] = 0,\n    millisecondParam: Params['constructor'][6] = 0,\n    microsecondParam: Params['constructor'][7] = 0,\n    nanosecondParam: Params['constructor'][8] = 0,\n    calendarParam: Params['constructor'][9] = 'iso8601'\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalDateTimeSlots(\n      this,\n      isoYear,\n      isoMonth,\n      isoDay,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalDateTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalDateTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\n\n    const options = ES.GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialDateTime = ES.PrepareTemporalFields(temporalDateTimeLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n      ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    if (temporalTimeParam === undefined) return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n\n    const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withPlainDate(temporalDateParam: Params['withPlainDate'][0]): Return['withPlainDate'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return new PlainDateTime(\n      GetSlot(this, ISO_YEAR),\n      GetSlot(this, ISO_MONTH),\n      GetSlot(this, ISO_DAY),\n      GetSlot(this, ISO_HOUR),\n      GetSlot(this, ISO_MINUTE),\n      GetSlot(this, ISO_SECOND),\n      GetSlot(this, ISO_MILLISECOND),\n      GetSlot(this, ISO_MICROSECOND),\n      GetSlot(this, ISO_NANOSECOND),\n      calendar\n    );\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    let year = GetSlot(this, ISO_YEAR);\n    let month = GetSlot(this, ISO_MONTH);\n    let day = GetSlot(this, ISO_DAY);\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode\n    ));\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      GetSlot(this, CALENDAR)\n    );\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalDateTime(otherParam);\n    for (const slot of [\n      ISO_YEAR,\n      ISO_MONTH,\n      ISO_DAY,\n      ISO_HOUR,\n      ISO_MINUTE,\n      ISO_SECOND,\n      ISO_MILLISECOND,\n      ISO_MICROSECOND,\n      ISO_NANOSECOND\n    ]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n  }\n\n  toZonedDateTime(\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\n    optionsParam: Params['toZonedDateTime'][1] = undefined\n  ): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n    const options = ES.GetOptionsObject(optionsParam);\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    const instant = ES.GetInstantFor(timeZone, this, disambiguation);\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToDate(this);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToTime(this);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalDateTime(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalDateTime(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDateTime(oneParam);\n    const two = ES.ToTemporalDateTime(twoParam);\n    for (const slot of [\n      ISO_YEAR,\n      ISO_MONTH,\n      ISO_DAY,\n      ISO_HOUR,\n      ISO_MINUTE,\n      ISO_SECOND,\n      ISO_MILLISECOND,\n      ISO_MICROSECOND,\n      ISO_NANOSECOND\n    ] as const) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n    }\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\n}\n\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\nimport JSBI from 'jsbi';\n\nexport class Duration implements Temporal.Duration {\n  constructor(\n    yearsParam: Params['constructor'][0] = 0,\n    monthsParam: Params['constructor'][1] = 0,\n    weeksParam: Params['constructor'][2] = 0,\n    daysParam: Params['constructor'][3] = 0,\n    hoursParam: Params['constructor'][4] = 0,\n    minutesParam: Params['constructor'][5] = 0,\n    secondsParam: Params['constructor'][6] = 0,\n    millisecondsParam: Params['constructor'][7] = 0,\n    microsecondsParam: Params['constructor'][8] = 0,\n    nanosecondsParam: Params['constructor'][9] = 0\n  ) {\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\n\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    CreateSlots(this);\n    SetSlot(this, YEARS, years);\n    SetSlot(this, MONTHS, months);\n    SetSlot(this, WEEKS, weeks);\n    SetSlot(this, DAYS, days);\n    SetSlot(this, HOURS, hours);\n    SetSlot(this, MINUTES, minutes);\n    SetSlot(this, SECONDS, seconds);\n    SetSlot(this, MILLISECONDS, milliseconds);\n    SetSlot(this, MICROSECONDS, microseconds);\n    SetSlot(this, NANOSECONDS, nanoseconds);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${ES.TemporalDurationToString(this)}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get years(): Return['years'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, YEARS);\n  }\n  get months(): Return['months'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MONTHS);\n  }\n  get weeks(): Return['weeks'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, WEEKS);\n  }\n  get days(): Return['days'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, DAYS);\n  }\n  get hours(): Return['hours'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, HOURS);\n  }\n  get minutes(): Return['minutes'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MINUTES);\n  }\n  get seconds(): Return['seconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, SECONDS);\n  }\n  get milliseconds(): Return['milliseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MILLISECONDS);\n  }\n  get microseconds(): Return['microseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MICROSECONDS);\n  }\n  get nanoseconds(): Return['nanoseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, NANOSECONDS);\n  }\n  get sign(): Return['sign'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.DurationSign(\n      GetSlot(this, YEARS),\n      GetSlot(this, MONTHS),\n      GetSlot(this, WEEKS),\n      GetSlot(this, DAYS),\n      GetSlot(this, HOURS),\n      GetSlot(this, MINUTES),\n      GetSlot(this, SECONDS),\n      GetSlot(this, MILLISECONDS),\n      GetSlot(this, MICROSECONDS),\n      GetSlot(this, NANOSECONDS)\n    );\n  }\n  get blank(): Return['blank'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return (\n      ES.DurationSign(\n        GetSlot(this, YEARS),\n        GetSlot(this, MONTHS),\n        GetSlot(this, WEEKS),\n        GetSlot(this, DAYS),\n        GetSlot(this, HOURS),\n        GetSlot(this, MINUTES),\n        GetSlot(this, SECONDS),\n        GetSlot(this, MILLISECONDS),\n        GetSlot(this, MICROSECONDS),\n        GetSlot(this, NANOSECONDS)\n      ) === 0\n    );\n  }\n  with(durationLike: Params['with'][0]): Return['with'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const partialDuration = ES.PrepareTemporalFields(\n      durationLike,\n      // NOTE: Field order here is important.\n      [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n      ],\n      'partial'\n    );\n    const {\n      years = GetSlot(this, YEARS),\n      months = GetSlot(this, MONTHS),\n      weeks = GetSlot(this, WEEKS),\n      days = GetSlot(this, DAYS),\n      hours = GetSlot(this, HOURS),\n      minutes = GetSlot(this, MINUTES),\n      seconds = GetSlot(this, SECONDS),\n      milliseconds = GetSlot(this, MILLISECONDS),\n      microseconds = GetSlot(this, MICROSECONDS),\n      nanoseconds = GetSlot(this, NANOSECONDS)\n    } = partialDuration;\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  negated(): Return['negated'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.CreateNegatedTemporalDuration(this);\n  }\n  abs(): Return['abs'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return new Duration(\n      Math.abs(GetSlot(this, YEARS)),\n      Math.abs(GetSlot(this, MONTHS)),\n      Math.abs(GetSlot(this, WEEKS)),\n      Math.abs(GetSlot(this, DAYS)),\n      Math.abs(GetSlot(this, HOURS)),\n      Math.abs(GetSlot(this, MINUTES)),\n      Math.abs(GetSlot(this, SECONDS)),\n      Math.abs(GetSlot(this, MILLISECONDS)),\n      Math.abs(GetSlot(this, MICROSECONDS)),\n      Math.abs(GetSlot(this, NANOSECONDS))\n    );\n  }\n  add(other: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromDuration('add', this, other, options);\n  }\n  subtract(other: Params['subtract'][0], options: Params['subtract'][1] = undefined): Return['subtract'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromDuration('subtract', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n\n    let defaultLargestUnit = ES.DefaultTemporalLargestUnit(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    );\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n\n    let largestUnit = ES.GetTemporalUnit(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\n    let relativeTo = ES.ToRelativeTemporalObject(roundTo);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    let smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'datetime', undefined);\n\n    let smallestUnitPresent = true;\n    if (!smallestUnit) {\n      smallestUnitPresent = false;\n      smallestUnit = 'nanosecond';\n    }\n    defaultLargestUnit = ES.LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n    let largestUnitPresent = true;\n    if (!largestUnit) {\n      largestUnitPresent = false;\n      largestUnit = defaultLargestUnit;\n    }\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n    if (!smallestUnitPresent && !largestUnitPresent) {\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\n    }\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n\n    const maximumIncrements = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    } as { [k in Temporal.DateTimeUnit]?: number };\n    const maximum = maximumIncrements[smallestUnit];\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n    ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(\n      years,\n      months,\n      weeks,\n      days,\n      largestUnit,\n      relativeTo\n    ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      ES.RoundDuration(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode,\n        relativeTo\n      ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      ES.AdjustRoundedDurationDays(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode,\n        relativeTo\n      ));\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      largestUnit,\n      relativeTo\n    ));\n    ({ years, months, weeks, days } = ES.BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  total(optionsParam: Params['total'][0]): Return['total'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\n    const options =\n      typeof optionsParam === 'string'\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\n        : ES.GetOptionsObject(optionsParam);\n    const relativeTo = ES.ToRelativeTemporalObject(options);\n    const unit = ES.GetTemporalUnit(options, 'unit', 'datetime', ES.REQUIRED);\n\n    // Convert larger units down to days\n    ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n    // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n    let intermediate;\n    if (ES.IsTemporalZonedDateTime(relativeTo)) {\n      intermediate = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n    }\n    let balanceResult = ES.BalancePossiblyInfiniteDuration(\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      unit,\n      intermediate\n    );\n    if (balanceResult === 'positive overflow') {\n      return Infinity;\n    } else if (balanceResult === 'negative overflow') {\n      return -Infinity;\n    }\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = balanceResult);\n    // Finally, truncate to the correct unit and calculate remainder\n    const { total } = ES.RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      1,\n      unit,\n      'trunc',\n      relativeTo\n    );\n    return total;\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\n    }\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\n      precision,\n      'Precision cannot be \"minute\" because of RangeError above'\n    );\n    return ES.TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDurationToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    if (typeof Intl !== 'undefined' && typeof (Intl as any).DurationFormat !== 'undefined') {\n      return new (Intl as any).DurationFormat(locales, options).format(this);\n    }\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n    return ES.TemporalDurationToString(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() to compare Temporal.Duration');\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    if (ES.IsTemporalDuration(item)) {\n      return new Duration(\n        GetSlot(item, YEARS),\n        GetSlot(item, MONTHS),\n        GetSlot(item, WEEKS),\n        GetSlot(item, DAYS),\n        GetSlot(item, HOURS),\n        GetSlot(item, MINUTES),\n        GetSlot(item, SECONDS),\n        GetSlot(item, MILLISECONDS),\n        GetSlot(item, MICROSECONDS),\n        GetSlot(item, NANOSECONDS)\n      );\n    }\n    return ES.ToTemporalDuration(item);\n  }\n  static compare(\n    oneParam: Params['compare'][0],\n    twoParam: Params['compare'][1],\n    optionsParam: Params['compare'][2] = undefined\n  ) {\n    const one = ES.ToTemporalDuration(oneParam);\n    const two = ES.ToTemporalDuration(twoParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const relativeTo = ES.ToRelativeTemporalObject(options);\n    const y1 = GetSlot(one, YEARS);\n    const mon1 = GetSlot(one, MONTHS);\n    const w1 = GetSlot(one, WEEKS);\n    let d1 = GetSlot(one, DAYS);\n    const h1 = GetSlot(one, HOURS);\n    const min1 = GetSlot(one, MINUTES);\n    const s1 = GetSlot(one, SECONDS);\n    const ms1 = GetSlot(one, MILLISECONDS);\n    const µs1 = GetSlot(one, MICROSECONDS);\n    let ns1 = GetSlot(one, NANOSECONDS);\n    const y2 = GetSlot(two, YEARS);\n    const mon2 = GetSlot(two, MONTHS);\n    const w2 = GetSlot(two, WEEKS);\n    let d2 = GetSlot(two, DAYS);\n    const h2 = GetSlot(two, HOURS);\n    const min2 = GetSlot(two, MINUTES);\n    const s2 = GetSlot(two, SECONDS);\n    const ms2 = GetSlot(two, MILLISECONDS);\n    const µs2 = GetSlot(two, MICROSECONDS);\n    let ns2 = GetSlot(two, NANOSECONDS);\n    const shift1 = ES.CalculateOffsetShift(relativeTo, y1, mon1, w1, d1);\n    const shift2 = ES.CalculateOffsetShift(relativeTo, y2, mon2, w2, d2);\n    if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n      ({ days: d1 } = ES.UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n      ({ days: d2 } = ES.UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n    }\n    const totalNs1 = ES.TotalDurationNanoseconds(d1, h1, min1, s1, ms1, µs1, ns1, shift1);\n    const totalNs2 = ES.TotalDurationNanoseconds(d2, h2, min2, s2, ms2, µs2, ns2, shift2);\n    return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(totalNs1, totalNs2)));\n  }\n  [Symbol.toStringTag]!: 'Temporal.Duration';\n}\n\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_MONTH, ISO_DAY, ISO_YEAR, CALENDAR, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\n\nconst ObjectCreate = Object.create;\n\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\n  constructor(\n    isoMonthParam: Params['constructor'][0],\n    isoDayParam: Params['constructor'][0],\n    calendarParam: string | Temporal.CalendarProtocol = 'iso8601',\n    referenceISOYearParam = 1972\n  ) {\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    const referenceISOYear = ES.ToIntegerWithTruncation(referenceISOYearParam);\n\n    ES.CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n  }\n\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n\n  with(temporalMonthDayLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalMonthDayLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialMonthDay = ES.PrepareTemporalFields(temporalMonthDayLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarMonthDayFromFields(calendar, fields, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalMonthDay(otherParam);\n    for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalMonthDayToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalMonthDayToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const receiverFieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n\n    const inputFieldNames = ES.CalendarFields(calendar, ['year'] as const);\n    const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n\n    // TODO: Use MergeLists abstract operation.\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n    const options = ObjectCreate(null);\n    options.overflow = 'reject';\n    return ES.CalendarDateFromFields(calendar, mergedFields, options);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalMonthDay(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalMonthDay(\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR),\n        GetSlot(item, ISO_YEAR)\n      );\n    }\n    return ES.ToTemporalMonthDay(item, options);\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\n}\n\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport type { Temporal } from '..';\n\nconst instant: typeof Temporal.Now['instant'] = () => {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  return new Instant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime: typeof Temporal.Now['plainDateTime'] = (\n  calendarLike,\n  temporalTimeZoneLike = ES.DefaultTimeZone()\n) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n  const inst = instant();\n  return ES.GetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO: typeof Temporal.Now['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const inst = instant();\n  return ES.GetPlainDateTimeFor(tZ, inst, 'iso8601');\n};\nconst zonedDateTime: typeof Temporal.Now['zonedDateTime'] = (\n  calendarLike,\n  temporalTimeZoneLike = ES.DefaultTimeZone()\n) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO: typeof Temporal.Now['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return zonedDateTime('iso8601', temporalTimeZoneLike);\n};\nconst plainDate: typeof Temporal.Now['plainDate'] = (calendarLike, temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO: typeof Temporal.Now['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO: typeof Temporal.Now['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZoneId: typeof Temporal.Now['timeZoneId'] = () => {\n  return ES.DefaultTimeZone();\n};\n\nexport const Now: typeof Temporal.Now = {\n  instant,\n  plainDateTime,\n  plainDateTimeISO,\n  plainDate,\n  plainDateISO,\n  plainTimeISO,\n  timeZoneId,\n  zonedDateTime,\n  zonedDateTimeISO,\n  [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n  value: 'Temporal.Now',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\n\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\n\nconst ObjectAssign = Object.assign;\n\ntype TemporalTimeToStringOptions = {\n  unit: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['unit'];\n  increment: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['increment'];\n  roundingMode: Temporal.RoundingMode;\n};\n\nfunction TemporalTimeToString(\n  time: Temporal.PlainTime,\n  precision: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['precision'],\n  options: TemporalTimeToStringOptions | undefined = undefined\n) {\n  let hour = GetSlot(time, ISO_HOUR);\n  let minute = GetSlot(time, ISO_MINUTE);\n  let second = GetSlot(time, ISO_SECOND);\n  let millisecond = GetSlot(time, ISO_MILLISECOND);\n  let microsecond = GetSlot(time, ISO_MICROSECOND);\n  let nanosecond = GetSlot(time, ISO_NANOSECOND);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      increment,\n      unit,\n      roundingMode\n    ));\n  }\n\n  const hourString = ES.ISODateTimePartString(hour);\n  const minuteString = ES.ISODateTimePartString(minute);\n  const seconds = ES.FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  return `${hourString}:${minuteString}${seconds}`;\n}\n\nexport class PlainTime implements Temporal.PlainTime {\n  constructor(\n    isoHourParam = 0,\n    isoMinuteParam = 0,\n    isoSecondParam = 0,\n    isoMillisecondParam = 0,\n    isoMicrosecondParam = 0,\n    isoNanosecondParam = 0\n  ) {\n    const isoHour = isoHourParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoHourParam);\n    const isoMinute = isoMinuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinuteParam);\n    const isoSecond = isoSecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecondParam);\n    const isoMillisecond = isoMillisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecondParam);\n    const isoMicrosecond = isoMicrosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecondParam);\n    const isoNanosecond = isoNanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecondParam);\n\n    ES.RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n    CreateSlots(this);\n    SetSlot(this, ISO_HOUR, isoHour);\n    SetSlot(this, ISO_MINUTE, isoMinute);\n    SetSlot(this, ISO_SECOND, isoSecond);\n    SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n    SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n    SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n\n  with(temporalTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalTimeLike);\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\n\n    const fields = ES.ToTemporalTimeRecord(this);\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, partialTime);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainTime('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainTime('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const MAX_INCREMENTS = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\n\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode\n    ));\n\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalTime(otherParam);\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return true;\n  }\n\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return TemporalTimeToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n  }\n\n  toPlainDateTime(temporalDateParam: Params['toPlainDateTime'][0]): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    if (!ES.IsObject(item)) {\n      throw new TypeError('invalid argument');\n    }\n\n    const dateLike = item.plainDate;\n    if (dateLike === undefined) {\n      throw new TypeError('missing date property');\n    }\n    const temporalDate = ES.ToTemporalDate(dateLike);\n\n    const timeZoneLike = item.timeZone;\n    if (timeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property');\n    }\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneLike);\n\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return {\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND)\n    };\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n    if (ES.IsTemporalTime(item)) {\n      return new PlainTime(\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND)\n      );\n    }\n    return ES.ToTemporalTime(item, overflow);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalTime(oneParam);\n    const two = ES.ToTemporalTime(twoParam);\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND] as const) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n    }\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\n}\n\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { DefineIntrinsic, GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  TIMEZONE_ID,\n  EPOCHNANOSECONDS,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { TimeZoneParams as Params, TimeZoneReturn as Return } from './internaltypes';\n\nexport class TimeZone implements Temporal.TimeZone {\n  constructor(timeZoneIdentifierParam: string) {\n    // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n    //       This check exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: identifier is required');\n    }\n\n    const timeZoneIdentifier = ES.GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n    CreateSlots(this);\n    SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get id(): Return['id'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  getOffsetNanosecondsFor(instantParam: Params['getOffsetNanosecondsFor'][0]): Return['getOffsetNanosecondsFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (ES.IsTimeZoneOffsetString(id)) {\n      return ES.ParseTimeZoneOffsetString(id);\n    }\n\n    return ES.GetNamedTimeZoneOffsetNanoseconds(id, GetSlot(instant, EPOCHNANOSECONDS));\n  }\n  getOffsetStringFor(instantParam: Params['getOffsetStringFor'][0]): Return['getOffsetStringFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    return ES.GetOffsetStringFor(this, instant);\n  }\n  getPlainDateTimeFor(\n    instantParam: Params['getPlainDateTimeFor'][0],\n    calendarParam: Params['getPlainDateTimeFor'][1] = 'iso8601'\n  ): Return['getPlainDateTimeFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return ES.GetPlainDateTimeFor(this, instant, calendar);\n  }\n  getInstantFor(\n    dateTimeParam: Params['getInstantFor'][0],\n    optionsParam: Params['getInstantFor'][1] = undefined\n  ): Return['getInstantFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    return ES.GetInstantFor(this, dateTime, disambiguation);\n  }\n  getPossibleInstantsFor(dateTimeParam: Params['getPossibleInstantsFor'][0]): Return['getPossibleInstantsFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (ES.IsTimeZoneOffsetString(id)) {\n      const epochNs = ES.GetUTCEpochNanoseconds(\n        GetSlot(dateTime, ISO_YEAR),\n        GetSlot(dateTime, ISO_MONTH),\n        GetSlot(dateTime, ISO_DAY),\n        GetSlot(dateTime, ISO_HOUR),\n        GetSlot(dateTime, ISO_MINUTE),\n        GetSlot(dateTime, ISO_SECOND),\n        GetSlot(dateTime, ISO_MILLISECOND),\n        GetSlot(dateTime, ISO_MICROSECOND),\n        GetSlot(dateTime, ISO_NANOSECOND)\n      );\n      if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n      const offsetNs = ES.ParseTimeZoneOffsetString(id);\n      return [new Instant(JSBI.subtract(epochNs, JSBI.BigInt(offsetNs)))];\n    }\n\n    const possibleEpochNs = ES.GetNamedTimeZoneEpochNanoseconds(\n      id,\n      GetSlot(dateTime, ISO_YEAR),\n      GetSlot(dateTime, ISO_MONTH),\n      GetSlot(dateTime, ISO_DAY),\n      GetSlot(dateTime, ISO_HOUR),\n      GetSlot(dateTime, ISO_MINUTE),\n      GetSlot(dateTime, ISO_SECOND),\n      GetSlot(dateTime, ISO_MILLISECOND),\n      GetSlot(dateTime, ISO_MICROSECOND),\n      GetSlot(dateTime, ISO_NANOSECOND)\n    );\n    return possibleEpochNs.map((ns) => new Instant(ns));\n  }\n  getNextTransition(startingPointParam: Params['getNextTransition'][0]): Return['getNextTransition'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ES.ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds: JSBI | null = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = ES.GetNamedTimeZoneNextTransition(id, epochNanoseconds);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n  getPreviousTransition(startingPointParam: Params['getPreviousTransition'][0]): Return['getPreviousTransition'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ES.ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds: JSBI | null = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = ES.GetNamedTimeZonePreviousTransition(id, epochNanoseconds);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n  toString(): string {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    const timeZoneSlotValue = ES.ToTemporalTimeZoneSlotValue(item);\n    return ES.ToTemporalTimeZoneObject(timeZoneSlotValue);\n  }\n  [Symbol.toStringTag]!: 'Temporal.TimeZone';\n}\n\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\nDefineIntrinsic('Temporal.TimeZone.prototype.getOffsetNanosecondsFor', TimeZone.prototype.getOffsetNanosecondsFor);\nDefineIntrinsic('Temporal.TimeZone.prototype.getPossibleInstantsFor', TimeZone.prototype.getPossibleInstantsFor);\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, CALENDAR, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainYearMonthParams as Params, PlainYearMonthReturn as Return } from './internaltypes';\n\nconst ObjectCreate = Object.create;\n\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    calendarParam: Params['constructor'][2] = 'iso8601',\n    referenceISODayParam: Params['constructor'][3] = 1\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    const referenceISODay = ES.ToIntegerWithTruncation(referenceISODayParam);\n\n    ES.CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalYearMonthLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalYearMonthLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialYearMonth = ES.PrepareTemporalFields(temporalYearMonthLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarYearMonthFromFields(calendar, fields, options);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalYearMonth(otherParam);\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalYearMonthToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalYearMonthToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const receiverFieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n\n    const inputFieldNames = ES.CalendarFields(calendar, ['day'] as const);\n    const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n\n    // TODO: Use MergeLists abstract operation.\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n    const options = ObjectCreate(null);\n    options.overflow = 'reject';\n    return ES.CalendarDateFromFields(calendar, mergedFields, options);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalYearMonth(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalYearMonth(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, CALENDAR),\n        GetSlot(item, ISO_DAY)\n      );\n    }\n    return ES.ToTemporalYearMonth(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalYearMonth(oneParam);\n    const two = ES.ToTemporalYearMonth(twoParam);\n    return ES.CompareISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY)\n    );\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\n}\n\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n","import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  ISO_HOUR,\n  INSTANT,\n  ISO_DAY,\n  ISO_MONTH,\n  ISO_YEAR,\n  ISO_MICROSECOND,\n  ISO_MILLISECOND,\n  ISO_MINUTE,\n  ISO_NANOSECOND,\n  ISO_SECOND,\n  TIME_ZONE,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { ZonedDateTimeParams as Params, ZonedDateTimeReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND, ZERO, HOUR_NANOS } from './ecmascript';\n\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\nconst ObjectCreate = Object.create;\n\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\n  constructor(\n    epochNanosecondsParam: bigint | JSBI,\n    timeZoneParam: string | Temporal.TimeZoneProtocol,\n    calendarParam: string | Temporal.CalendarProtocol = 'iso8601'\n  ) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    //       ToTemporalTimeZoneSlotValue(undefined) has a clear enough message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get timeZoneId(): Return['timeZoneId'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalTimeZoneIdentifier(GetSlot(this, TIME_ZONE));\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_NANOSECOND);\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get epochSeconds(): Return['epochSeconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, BILLION));\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, MILLION));\n  }\n  get epochMicroseconds(): Return['epochMicroseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ES.ToBigIntExternal(ES.BigIntFloorDiv(value, THOUSAND));\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get hoursInDay(): Return['hoursInDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const year = GetSlot(dt, ISO_YEAR);\n    const month = GetSlot(dt, ISO_MONTH);\n    const day = GetSlot(dt, ISO_DAY);\n    const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n    const tomorrowFields = ES.AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n    const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const todayNs = GetSlot(ES.GetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n    const tomorrowNs = GetSlot(ES.GetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n    const diffNs = JSBI.subtract(tomorrowNs, todayNs);\n    return ES.BigIntDivideToNumber(diffNs, HOUR_NANOS);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get offset(): Return['offset'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.GetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n  with(temporalZonedDateTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\n      throw new TypeError('invalid zoned-date-time-like');\n    }\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fieldNames: (keyof Temporal.ZonedDateTimeLike)[] = ES.CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    fieldNames.push('offset');\n    let fields = ES.PrepareTemporalFields(this, fieldNames, ['offset']);\n    const partialZonedDateTime = ES.PrepareTemporalFields(temporalZonedDateTimeLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, ['offset']);\n\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    const offset = ES.ToTemporalOffset(options, 'prefer');\n\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n      ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n    const offsetNs = ES.ParseTimeZoneOffsetString(fields.offset);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      'option',\n      offsetNs,\n      timeZone,\n      disambiguation,\n      offset,\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n  withPlainDate(temporalDateParam: Params['withPlainDate'][0]): Return['withPlainDate'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n    const thisDt = dateTime(this);\n    const hour = GetSlot(thisDt, ISO_HOUR);\n    const minute = GetSlot(thisDt, ISO_MINUTE);\n    const second = GetSlot(thisDt, ISO_SECOND);\n    const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n    const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n    const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n\n    calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n\n    const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    const temporalTime = temporalTimeParam === undefined ? new PlainTime() : ES.ToTemporalTime(temporalTimeParam);\n\n    const thisDt = dateTime(this);\n    const year = GetSlot(thisDt, ISO_YEAR);\n    const month = GetSlot(thisDt, ISO_MONTH);\n    const day = GetSlot(thisDt, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromZonedDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromZonedDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    // first, round the underlying DateTime fields\n    const dt = dateTime(this);\n    let year = GetSlot(dt, ISO_YEAR);\n    let month = GetSlot(dt, ISO_MONTH);\n    let day = GetSlot(dt, ISO_DAY);\n    let hour = GetSlot(dt, ISO_HOUR);\n    let minute = GetSlot(dt, ISO_MINUTE);\n    let second = GetSlot(dt, ISO_SECOND);\n    let millisecond = GetSlot(dt, ISO_MILLISECOND);\n    let microsecond = GetSlot(dt, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n    const instantStart = ES.GetInstantFor(timeZone, dtStart, 'compatible');\n    const endNs = ES.AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = JSBI.subtract(endNs, JSBI.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n    if (JSBI.lessThanOrEqual(dayLengthNs, ZERO)) {\n      throw new RangeError('cannot round a ZonedDateTime in a calendar with zero or negative length days');\n    }\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode,\n      // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n      // (which can hold up to 104 days in nanoseconds)\n      JSBI.toNumber(dayLengthNs)\n    ));\n\n    // Now reset all DateTime fields but leave the TimeZone. The offset will\n    // also be retained if the new date/time values are still OK with the old\n    // offset. Otherwise the offset will be changed to be compatible with the\n    // new date/time values. If DST disambiguation is required, the `compatible`\n    // disambiguation algorithm will be used.\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      'option',\n      offsetNs,\n      timeZone,\n      'compatible',\n      'prefer',\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalZonedDateTime(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const showOffset = ES.ToShowOffsetOption(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const showTimeZone = ES.ToTimeZoneNameOption(options);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    optionsParam: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const optionsCopy = ObjectCreate(null);\n    // This is not quite per specification, but this polyfill's DateTimeFormat\n    // already doesn't match the InitializeDateTimeFormat operation, and the\n    // access order might change anyway;\n    // see https://github.com/tc39/ecma402/issues/747\n    ES.CopyDataProperties(optionsCopy, options, ['timeZone']);\n\n    if (options.timeZone !== undefined) {\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\n    }\n\n    if (\n      optionsCopy.year === undefined &&\n      optionsCopy.month === undefined &&\n      optionsCopy.day === undefined &&\n      optionsCopy.weekday === undefined &&\n      optionsCopy.dateStyle === undefined &&\n      optionsCopy.hour === undefined &&\n      optionsCopy.minute === undefined &&\n      optionsCopy.second === undefined &&\n      optionsCopy.timeStyle === undefined &&\n      optionsCopy.dayPeriod === undefined &&\n      optionsCopy.timeZoneName === undefined\n    ) {\n      optionsCopy.timeZoneName = 'short';\n      // The rest of the defaults will be filled in by formatting the Instant\n    }\n\n    let timeZone = ES.ToTemporalTimeZoneIdentifier(GetSlot(this, TIME_ZONE));\n    if (ES.IsTimeZoneOffsetString(timeZone)) {\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\n      throw new RangeError('toLocaleString does not support offset string time zones');\n    }\n    timeZone = ES.GetCanonicalTimeZoneIdentifier(timeZone);\n    optionsCopy.timeZone = timeZone;\n\n    const formatter = new DateTimeFormat(locales, optionsCopy);\n\n    const localeCalendarIdentifier = ES.Call(customResolvedOptions, formatter, []).calendar;\n    const calendarIdentifier = ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n    if (\n      calendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== calendarIdentifier\n    ) {\n      throw new RangeError(\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\n          ` in locale with calendar ${localeCalendarIdentifier}`\n      );\n    }\n\n    return formatter.format(GetSlot(this, INSTANT));\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n  }\n  startOfDay(): Return['startOfDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(\n      GetSlot(dt, ISO_YEAR),\n      GetSlot(dt, ISO_MONTH),\n      GetSlot(dt, ISO_DAY),\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      calendar\n    );\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const instant = ES.GetInstantFor(timeZone, dtStart, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toInstant(): Return['toInstant'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToDate(dateTime(this));\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToTime(dateTime(this));\n  }\n  toPlainDateTime(): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return dateTime(this);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const tz = GetSlot(this, TIME_ZONE);\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(dt, ISO_DAY),\n      isoHour: GetSlot(dt, ISO_HOUR),\n      isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n      isoMinute: GetSlot(dt, ISO_MINUTE),\n      isoMonth: GetSlot(dt, ISO_MONTH),\n      isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n      isoSecond: GetSlot(dt, ISO_SECOND),\n      isoYear: GetSlot(dt, ISO_YEAR),\n      offset: ES.GetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n      timeZone: tz\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n  getTimeZone(): Return['getTimeZone'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalTimeZoneObject(GetSlot(this, TIME_ZONE));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalZonedDateTime(item)) {\n      ES.ToTemporalDisambiguation(options); // validate and ignore\n      ES.ToTemporalOffset(options, 'reject');\n      ES.ToTemporalOverflow(options);\n      return ES.CreateTemporalZonedDateTime(\n        GetSlot(item, EPOCHNANOSECONDS),\n        GetSlot(item, TIME_ZONE),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalZonedDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalZonedDateTime(oneParam);\n    const two = ES.ToTemporalZonedDateTime(twoParam);\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\n}\n\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\n\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\n  return ES.GetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n","import { Instant } from './instant';\n\nimport JSBI from 'jsbi';\nimport { MILLION } from './ecmascript';\n\nexport function toTemporalInstant(this: Date) {\n  // Observable access to valueOf is not correct here, but unavoidable\n  const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n  return new Instant(epochNanoseconds);\n}\n","// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\n\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n  Temporal.Instant,\n  Temporal.Calendar,\n  Temporal.PlainDate,\n  Temporal.PlainDateTime,\n  Temporal.Duration,\n  Temporal.PlainMonthDay,\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\n  Temporal.PlainTime,\n  Temporal.TimeZone,\n  Temporal.PlainYearMonth,\n  Temporal.ZonedDateTime\n];\nfor (const type of types) {\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n    descriptor.configurable = false;\n    descriptor.enumerable = false;\n    descriptor.writable = false;\n    Object.defineProperty(type, 'prototype', descriptor);\n  }\n}\n\nexport { Temporal, Intl, toTemporalInstant };\n"],"names":["INTRINSICS","MakeIntrinsicClass","Class","name","Object","defineProperty","prototype","Symbol","toStringTag","value","writable","enumerable","configurable","prop","getOwnPropertyNames","desc","getOwnPropertyDescriptor","DefineIntrinsic","key","undefined","Error","GetIntrinsic","intrinsic","EPOCHNANOSECONDS","TIMEZONE_ID","ISO_YEAR","ISO_MONTH","ISO_DAY","ISO_HOUR","ISO_MINUTE","ISO_SECOND","ISO_MILLISECOND","ISO_MICROSECOND","ISO_NANOSECOND","CALENDAR","DATE_BRAND","YEAR_MONTH_BRAND","MONTH_DAY_BRAND","INSTANT","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","CALENDAR_ID","globalSlots","WeakMap","GetSlotsSymbol","for","_a","globalThis","_GetSlots","container","get","GetSlots","CreateSlotsSymbol","_b","_CreateSlots","set","create","CreateSlots","HasSlot","ids","myslots","every","id","GetSlot","TypeError","SetSlot","slots","tzComponent","timeZoneID","RegExp","source","join","yearpart","monthpart","daypart","datesplit","timesplit","offset","offsetpart","annotation","zoneddatetime","time","yearmonth","monthday","fraction","durationTime","duration","ArrayIncludes","Array","includes","ArrayPrototypePush","push","IntlDateTimeFormat","Intl","DateTimeFormat","MathMin","Math","min","MathMax","max","MathAbs","abs","MathFloor","floor","MathSign","sign","MathTrunc","trunc","NumberIsNaN","Number","isNaN","NumberIsFinite","isFinite","NumberCtor","StringCtor","String","NumberMaxSafeInteger","MAX_SAFE_INTEGER","ObjectCreate","ObjectGetOwnPropertyDescriptor","ReflectApply","Reflect","apply","ReflectOwnKeys","ownKeys","ZERO","JSBI","BigInt","ONE","SIXTY","TWENTY_FOUR","THOUSAND","MILLION","BILLION","NEGATIVE_ONE","HOUR_NANOS","multiply","MINUTE_NANOS","DAY_NANOS","NS_MIN","NS_MAX","YEAR_MIN","YEAR_MAX","BEFORE_FIRST_OFFSET_TRANSITION","ABOUT_TEN_YEARS_NANOS","ABOUT_ONE_YEAR_NANOS","TWO_WEEKS_NANOS","BUILTIN_CALENDAR_IDS","isZero","equal","GetMethod","obj","methodName","result","Call","target","thisArgument","argumentsList","args","arguments","length","IsObject","ToNumber","ToIntegerOrInfinity","number","integer","IsIntegralNumber","argument","absValue","ToString","ToIntegerWithTruncation","RangeError","ToPositiveIntegerWithTruncation","valueParam","property","ToIntegerIfIntegral","divmod","x","y","quotient","divide","remainder","isNegativeJSBI","lessThan","signJSBI","BUILTIN_CASTS","Map","BUILTIN_DEFAULTS","SINGULAR_PLURAL_UNITS","SINGULAR_FOR","map","e","PLURAL_FOR","p","s","UNITS_DESCENDING","DURATION_FIELDS","from","keys","sort","IntlDateTimeFormatEnUsCache","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","instance","timeZone","hour12","era","year","month","day","hour","minute","second","ToObject","CopyDataProperties","excludedKeys","excludedValues","nextKey","some","is","propertyIsEnumerable","call","propValue","IsTemporalInstant","item","IsTemporalTimeZone","IsTemporalCalendar","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","RejectTemporalLikeObject","calendar","ParseTemporalTimeZone","stringIdent","ianaName","z","ParseTemporalTimeZoneString","PARSE.timeZoneID","test","ParseISODateTime","GetCanonicalTimeZoneIdentifier","FormatTimeZoneOffsetString","ParseTimeZoneOffsetString","MaybeFormatCalendarAnnotation","showCalendar","FormatCalendarAnnotation","ToTemporalCalendarIdentifier","isoString","match","PARSE.zoneddatetime","exec","yearString","slice","hasTime","millisecond","microsecond","nanosecond","offsetSign","offsetHours","offsetMinutes","offsetSeconds","offsetFraction","endsWith","annotations","critical","matchAll","PARSE.annotation","RejectDateTime","ParseTemporalYearMonthString","PARSE.yearmonth","referenceISODay","ParseTemporalMonthDayString","PARSE.monthday","referenceISOYear","ParseTemporalInstant","ParseTemporalInstantString","offsetNs","BalanceISODateTime","epochNs","GetUTCEpochNanoseconds","RegulateISODate","yearParam","monthParam","dayParam","overflow","RejectISODate","ConstrainISODate","RegulateTime","hourParam","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","RejectTime","ConstrainTime","ConstrainToRange","ToTemporalDurationRecord","ParseTemporalDurationString","PARSE.duration","element","years","months","weeks","days","hours","fHours","minutesStr","fMinutes","secondsStr","fSeconds","minutes","seconds","excessNanoseconds","nanoseconds","microseconds","milliseconds","RejectDuration","partial","ToTemporalPartialDurationRecord","temporalDurationLike","any","ToTemporalOverflow","options","GetOption","ToTemporalDisambiguation","ToTemporalRoundingMode","fallback","ToTemporalOffset","ToCalendarNameOption","ToTemporalRoundingIncrement","increment","roundingIncrement","integerIncrement","ValidateTemporalRoundingIncrement","dividend","inclusive","maximum","ToFractionalSecondDigits","normalizedOptions","digitsValue","fractionalSecondDigits","digitCount","ToSecondsStringPrecisionRecord","smallestUnit","precision","unit","REQUIRED","GetTemporalUnit","unitGroup","requiredOrDefault","extraValues","allowedSingular","singular","category","defaultVal","allowedValues","plural","retval","has","ToRelativeTemporalObject","relativeTo","offsetBehaviour","matchMinutes","TemporalDateTimeToDate","GetTemporalCalendarSlotValueWithISODefault","fieldNames","CalendarFields","fields","PrepareTemporalFields","dateOptions","InterpretTemporalDateTimeFields","ToTemporalTimeZoneSlotValue","IsBuiltinCalendar","ASCIILowercase","CreateTemporalDate","CreateTemporalZonedDateTime","InterpretISODateTimeOffset","DefaultTemporalLargestUnit","v","LargerOfTwoTemporalUnits","unit1","unit2","indexOf","bag","requiredFields","emptySourceErrorMessage","ToTemporalTimeRecord","completeness","field","valueDesc","ToTemporalDate","itemParam","GetPlainDateTimeFor","CalendarDateFromFields","ParseTemporalDateString","date","ToTemporalDateTime","CreateTemporalDateTime","ParseTemporalDateTimeString","ToTemporalDuration","ToTemporalInstant","ns","ToTemporalMonthDay","calendarAbsent","calendarFromItem","ToTemporalCalendarSlotValue","monthCode","CalendarMonthDayFromFields","CreateTemporalMonthDay","ToTemporalTime","ParseTemporalTimeString","PARSE.time","ToTemporalYearMonth","CalendarYearMonthFromFields","CreateTemporalYearMonth","disambiguation","offsetOpt","matchMinute","dt","GetInstantFor","subtract","possibleInstants","GetPossibleInstantsFor","candidate","candidateOffset","GetOffsetNanosecondsFor","roundedCandidateOffset","toNumber","RoundNumberToIncrement","offsetStr","timeZoneString","toString","DisambiguatePossibleInstants","ToTemporalZonedDateTime","ParseTemporalZonedDateTimeString","CreateTemporalDateSlots","isoYear","isoMonth","isoDay","RejectDateRange","TemporalPlainDate","CreateTemporalDateTimeSlots","h","ms","RejectDateTimeRange","TemporalPlainDateTime","CreateTemporalMonthDaySlots","TemporalPlainMonthDay","CreateTemporalYearMonthSlots","RejectYearMonthRange","RejectToRange","TemporalPlainYearMonth","CreateTemporalZonedDateTimeSlots","epochNanoseconds","ValidateEpochNanoseconds","instant","TemporalZonedDateTime","fieldNamesParam","calendarObj","CalendarMergeFields","additionalFields","CalendarDateAdd","dateAddParam","dateAdd","CalendarDateUntil","otherDate","dateUntilParam","dateUntil","CalendarYear","dateLike","CalendarMonth","CalendarMonthCode","CalendarDay","CalendarEra","CalendarEraYear","CalendarDayOfWeek","CalendarDayOfYear","CalendarWeekOfYear","CalendarYearOfWeek","CalendarDaysInWeek","CalendarDaysInMonth","CalendarDaysInYear","CalendarMonthsInYear","CalendarInLeapYear","calendarLike","ObjectImplementsTemporalCalendarProtocol","object","identifier","slotValue","ToTemporalCalendarObject","CalendarEquals","one","two","ThrowIfCalendarsNotEqual","errorMessageAction","cal1","cal2","ConsolidateCalendars","sOne","sTwo","dateFromFieldsParam","temporalTimeZoneLike","ObjectImplementsTemporalTimeZoneProtocol","ToTemporalTimeZoneIdentifier","ToTemporalTimeZoneObject","TimeZoneEquals","dateTime","TemporalDateTimeToTime","getOffsetNanosecondsForParam","timeZoneObject","GetOffsetStringFor","GetISOPartsFromEpoch","Instant","numInstants","utcns","dayBefore","dayAfter","add","offsetBefore","PlainDateTime","earlier","AddDateTime","later","possible","getPossibleInstantsForParam","ISOYearString","ISODateTimePartString","part","FormatSecondsStringPart","secs","fractionNumber","padStart","TemporalInstantToString","outputTimeZone","FormatISOTimeZoneOffsetString","TemporalDurationToString","formatNumber","num","DurationSign","roundingMode","RoundDuration","dateParts","timeParts","secondParts","nsBigInt","msBigInt","secondsBigInt","total","TotalDurationNanoseconds","decimalPart","unshift","TemporalDateToString","TemporalDateTimeToString","RoundISODateTime","TemporalMonthDayToString","monthDay","resultString","calendarID","calendarString","TemporalYearMonthToString","yearMonth","TemporalZonedDateTimeToString","zdt","showTimeZone","showOffset","RoundInstant","tz","IsTimeZoneOffsetString","string","OFFSET","resolvedOptions","GetNamedTimeZoneOffsetNanoseconds","GetNamedTimeZoneDateTimeParts","reducedYear","yearCycles","nsIn400YearCycle","reducedUTC","utc","offsetNanosecondsParam","offsetNanoseconds","hourString","minuteString","secondString","post","legacyDate","Date","setUTCHours","setUTCFullYear","getTime","greaterThan","epochMilliseconds","nanos","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","GetFormatterParts","datetime","format","parseFromEnUsFormat","parts","split","toUpperCase","maxJSBI","afterLatestPossibleTzdbRuleChange","SystemUTCEpochNanoSeconds","GetNamedTimeZoneNextTransition","oneYearLater","uppercap","leftNanos","leftOffsetNs","rightNanos","rightOffsetNs","bisect","GetNamedTimeZonePreviousTransition","afterLatestRule","isFarFuture","lowercap","lastPrecomputed","newTimeToCheck","LeapYear","ISODaysInMonth","standard","leapyear","DayOfWeek","m","Y","c","dow","DayOfYear","WeekOfYear","doy","doj","week","mon","w","d","BalanceISOYearMonth","BalanceISODate","daysIn400YearCycle","nCycles","daysInYear","testYear","deltaDays","BalanceTime","NonNegativeBigIntDivmod","daysParam","hoursParam","minutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","offsetShift","NanosecondsToDays","TemporalInstant","dayLengthNs","startNs","start","endNs","end","dtStart","dtEnd","daysNumber","DifferenceISODateTime","intermediateNs","AddZonedDateTime","daysBigInt","isOverflow","relativeInstant","oneDayFartherNs","relativeNs","greaterThanOrEqual","BalanceDuration","largestUnit","BalancePossiblyInfiniteDuration","nanosecondsBigInt","microsecondsBigInt","millisecondsBigInt","minutesBigInt","hoursBigInt","UnbalanceDurationRelative","yearsParam","monthsParam","weeksParam","relativeToParam","TemporalDuration","signBI","oneYear","oneMonth","oneWeek","newRelativeTo","untilOptions","untilResult","oneYearMonths","oneYearDays","MoveRelativeDate","oneMonthDays","oneWeekDays","CalculateOffsetShift","after","CreateNegatedTemporalDuration","propSign","DifferenceISODate","y1","m1","d1","y2","m2","d2","CompareISODate","mid","AddISODate","midSign","larger","smaller","DifferenceTime","h1","min1","s1","ms1","ns1","h2","min2","s2","ms2","ns2","DifferenceInstant","diff","y1Param","mon1Param","d1Param","mon2","mon1","timeSign","date1","date2","dateLargestUnit","CopyOptions","DifferenceZonedDateTime","nsDiff","timeRemainderNs","intermediate","GetDifferenceSettings","op","group","disallowed","fallbackSmallest","smallestLargestDefaultUnit","ALLOWED_UNITS","reduce","allowed","unitInfo","NegateTemporalRoundingMode","defaultLargestUnit","DifferenceTemporalInstant","operation","otherParam","other","settings","onens","twons","DifferenceTemporalPlainDate","plainDate","DifferenceTemporalPlainDateTime","plainDateTime","DifferenceTemporalPlainTime","plainTime","DifferenceTemporalPlainYearMonth","thisFields","thisDate","otherFields","DifferenceTemporalZonedDateTime","zonedDateTime","AdjustRoundedDurationDays","AddTime","AddDuration","w1","w2","dateDuration1","dateDuration2","differenceOptions","AddInstant","sum","addedDate","dtIntermediate","AddDurationToOrSubtractDurationFromDuration","optionsParam","GetOptionsObject","AddDurationToOrSubtractDurationFromInstant","durationLike","ToLimitedTemporalDuration","disallowedProperties","record","AddDurationToOrSubtractDurationFromPlainDateTime","AddDurationToOrSubtractDurationFromPlainTime","temporalTime","AddDurationToOrSubtractDurationFromPlainYearMonth","fieldsCopy","startDate","Duration","nextMonth","endOfMonth","durationToAdd","optionsCopy","AddDurationToOrSubtractDurationFromZonedDateTime","quantity","mode","tiebreaker","tie","expandIsNearer","wholeDays","roundedRemainder","nsPerTimeUnit","RoundTime","nsPerUnit","rounded","DaysUntil","MoveRelativeZonedDateTime","direction","dayStart","dayEnd","zdtRelative","dayLength","yearsDuration","yearsLater","yearsMonthsWeeksLater","wholeDaysLater","yearsPassed","oldRelativeTo","divisor","BigIntDivideToNumber","yearsMonths","yearsMonthsLater","allNanoseconds","ComparisonResult","BigIntFloorDiv","left","right","ToBigIntExternal","arg","jsbiBI","ToBigInt","prim","toPrimFn","toPrimitive","now","DefaultTimeZone","CreateOnePropObject","propName","o","str","replace","l","code","charCodeAt","fromCharCode","PARSE.offset","getState","leftParam","rightParam","lstateParam","rstateParam","lstate","rstate","middle","mstate","DATE","YM","MD","TIME","DATETIME","INST","ORIGINAL","TZ_RESOLVED","CAL_ID","LOCALE","OPTIONS","descriptor","ObjectAssign","assign","ObjectHasOwnProperty","hasOwnProperty","getPropLazy","val","DateTimeFormatImpl","locale","this","hasOptions","original","ro","clonedResolved","dateAmend","yearMonthAmend","monthDayAmend","timeAmend","datetimeAmend","instantAmend","supportedLocalesOf","locales","propertyDescriptors","rest","formatter","extractOverrides","formatRange","a","b","isTemporalObject","sameTemporalType","aa","aformatter","bb","bformatter","formatToParts","formatRangeToParts","amend","amended","opt","weekday","timeZoneName","dateStyle","hasTimeOptions","dayPeriod","timeStyle","hasDateOptions","ES.IsTemporalDate","ES.IsTemporalTime","ES.IsTemporalDateTime","ES.IsTemporalZonedDateTime","ES.IsTemporalYearMonth","ES.IsTemporalMonthDay","ES.IsTemporalInstant","temporalObj","main","DateTime","ES.GetInstantFor","ES.ToTemporalCalendarIdentifier","constructor","ES.ToBigInt","ES.ValidateEpochNanoseconds","epochSeconds","ES.BigIntFloorDiv","epochMicroseconds","ES.ToBigIntExternal","ES.AddDurationToOrSubtractDurationFromInstant","until","ES.DifferenceTemporalInstant","since","round","roundToParam","roundTo","ES.CreateOnePropObject","ES.GetOptionsObject","ES.ToTemporalRoundingIncrement","ES.ToTemporalRoundingMode","ES.GetTemporalUnit","ES.REQUIRED","ES.ValidateTemporalRoundingIncrement","roundedNs","ES.RoundInstant","equals","ES.ToTemporalInstant","digits","ES.ToFractionalSecondDigits","ES.ToTemporalTimeZoneSlotValue","ES.ToSecondsStringPrecisionRecord","ES.TemporalInstantToString","toJSON","toLocaleString","valueOf","toZonedDateTime","ES.IsObject","ES.ToTemporalCalendarSlotValue","ES.CreateTemporalZonedDateTime","toZonedDateTimeISO","timeZoneParam","static","epochSecondsParam","ES.ToNumber","epochMillisecondsParam","epochMicrosecondsParam","epochNanosecondsParam","oneParam","twoParam","oneNs","twoNs","ArraySort","ObjectEntries","entries","OriginalSet","Set","SetPrototypeAdd","SetPrototypeValues","values","impl","Calendar","idParam","ES.ToString","ES.IsBuiltinCalendar","ES.ASCIILowercase","ES.IsTemporalCalendar","dateFromFields","yearMonthFromFields","monthDayFromFields","fieldsArray","delete","mergeFields","fieldsParam","additionalFieldsParam","ES.ToObject","ES.CopyDataProperties","additionalFieldsCopy","additionalKeys","overriddenKeys","fieldKeysToIgnore","merged","fieldsKeys","ES.Call","dateParam","durationParam","ES.ToTemporalDate","ES.ToTemporalDuration","ES.ToTemporalOverflow","ES.BalanceDuration","eraYear","dayOfWeek","dayOfYear","weekOfYear","yearOfWeek","daysInWeek","daysInMonth","monthsInYear","inLeapYear","ES.ToTemporalCalendarObject","monthCodeNumberPart","startsWith","buildMonthCode","leap","resolveNonLunisolarMonth","calendarDate","monthsPerYear","ES.RejectToRange","ES.ConstrainToRange","numberPart","calendarSlotValue","ES.PrepareTemporalFields","ES.RegulateISODate","ES.CreateTemporalDate","RegulateISOYearMonth","ES.RegulateISOYearMonth","ES.CreateTemporalYearMonth","useYear","ES.CreateTemporalMonthDay","ix","ES.AddISODate","ES.DifferenceISODate","ES.DayOfWeek","ES.DayOfYear","ES.WeekOfYear","ES.ISODaysInMonth","ES.LeapYear","OneObjectCache","cacheToClone","calls","hits","misses","performance","i","entry","MAX_CACHE_ENTRIES","report","setObject","objectMap","cache","toUtcIsoDateString","ES.ISOYearString","ES.ISODateTimePartString","simpleDateDiff","HelperBase","eraLength","hasEra","erasBeginMidYear","getFormatter","isoToCalendarDate","isoDate","JSON","stringify","func","cached","dateTimeFormat","type","matches","monthExtra","normalize","toLowerCase","reviseIntlEra","checkIcuBugs","adjustCalendarDate","forEach","keyReverse","validateCalendarDate","constantEra","calendarDateParam","fromLegacyDate","calendarType","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","originalDate","keyOriginal","isoEstimate","estimateIsoDate","calculateSameMonthResult","diffDays","testIsoEstimate","addDaysIso","minimumMonthLength","testCalendarDate","roundtripEstimate","diffTotalDaysEstimate","compareCalendarDates","oldRoundtripEstimate","oldSign","temporalToCalendarDate","date1Param","date2Param","ES.ComparisonResult","regulateDate","addDaysCalendar","addedIso","addMonthsCalendar","absMonths","oldCalendarDate","daysInPreviousMonth","monthsInOldYear","addCalendar","addedYears","addedMonths","initialDays","untilCalendar","calendarOne","calendarTwo","calendarDaysUntil","totalDays","diffYears","diffInYearSign","current","next","addedIsoDate","addedCalendarDate","endOfMonthIso","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","startOfCalendarYear","startOfCalendarMonth","oneIso","twoIso","isoDaysUntil","closestCalendar","closestIso","calendarOfStartDateIso","calendarYear","roundTripCalendarDate","HebrewHelper","Tishri","regular","Heshvan","Kislev","Tevet","Shevat","Adar","Nisan","Iyar","Sivan","Tamuz","Av","Elul","minMaxMonthLength","minOrMax","getMonthCode","monthInfo","find","IslamicBaseHelper","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","IslamicHelper","IslamicUmalquraHelper","IslamicTblaHelper","IslamicCivilHelper","IslamicRgsaHelper","IslamicCcHelper","PersianHelper","IndianHelper","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","GregorianBaseHelper","originalEras","super","v8IsVulnerableToJulianBug","calendarIsVulnerableToJulianBug","eras","anchorEra","adjustEras","erasParam","reverseOf","filter","isAnchor","anchorEpoch","hasYearZero","reversedEra","isoEpoch","e1","e2","lastEraReversed","genericName","completeEraYear","checkField","currentValue","eraFromYear","adjustedCalendarDate","matchingEra","ES.CompareISODate","OrthodoxBaseHelper","EthioaaHelper","CopticHelper","EthiopicHelper","RocHelper","BuddhistHelper","GregoryHelper","JapaneseHelper","ChineseBaseHelper","getMonthList","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","calendarMonthString","tv","calendarDay","calendarYearToVerify","isoDaysDelta","oldCalendarDay","oldMonthString","monthIndex","done","monthString","withoutML","monthEntries","matchingMonthEntry","ChineseHelper","DangiHelper","NonIsoCalendar","helper","getCacheForObject","added","isoAdded","newTemporalObject","cacheOne","cacheTwo","startOfYear","startOfMonthCalendar","startOfNextMonthCalendar","startOfYearCalendar","startOfNextYearCalendar","Helper","PlainDate","isoYearParam","isoMonthParam","isoDayParam","calendarParam","ES.CreateTemporalDateSlots","ES.ToIntegerWithTruncation","calendarId","ES.CalendarEra","ES.CalendarEraYear","ES.CalendarYear","ES.CalendarMonth","ES.CalendarMonthCode","ES.CalendarDay","ES.CalendarDayOfWeek","ES.CalendarDayOfYear","ES.CalendarWeekOfYear","ES.CalendarYearOfWeek","ES.CalendarDaysInWeek","ES.CalendarDaysInMonth","ES.CalendarDaysInYear","ES.CalendarMonthsInYear","ES.CalendarInLeapYear","with","temporalDateLike","ES.RejectTemporalLikeObject","ES.CalendarFields","ES.CalendarMergeFields","ES.CalendarDateFromFields","withCalendar","ES.CalendarDateAdd","ES.CreateNegatedTemporalDuration","ES.DifferenceTemporalPlainDate","slot","ES.CalendarEquals","ES.TemporalDateToString","ES.ToCalendarNameOption","toPlainDateTime","temporalTimeParam","ES.CreateTemporalDateTime","ES.ToTemporalTime","ES.IsTemporalTimeZone","timeZoneLike","toPlainYearMonth","ES.CalendarYearMonthFromFields","toPlainMonthDay","ES.CalendarMonthDayFromFields","getISOFields","getCalendar","ES.CreateTemporalDateTimeSlots","temporalDateTimeLike","ES.InterpretTemporalDateTimeFields","withPlainTime","withPlainDate","temporalDateParam","temporalDate","ES.ConsolidateCalendars","ES.AddDurationToOrSubtractDurationFromPlainDateTime","ES.DifferenceTemporalPlainDateTime","ES.RoundISODateTime","ES.ToTemporalDateTime","ES.TemporalDateTimeToString","ES.ToTemporalDisambiguation","toPlainDate","ES.TemporalDateTimeToDate","toPlainTime","ES.TemporalDateTimeToTime","isoHour","isoMicrosecond","isoMillisecond","isoMinute","isoNanosecond","isoSecond","val1","val2","ES.ToIntegerIfIntegral","ES.RejectDuration","ES.IsTemporalDuration","ES.DurationSign","blank","partialDuration","negated","ES.AddDurationToOrSubtractDurationFromDuration","ES.DefaultTemporalLargestUnit","ES.ToRelativeTemporalObject","smallestUnitPresent","ES.LargerOfTwoTemporalUnits","largestUnitPresent","ES.UnbalanceDurationRelative","ES.RoundDuration","ES.AdjustRoundedDurationDays","BalanceDurationRelative","ES.BalanceDurationRelative","ES.MoveRelativeZonedDateTime","balanceResult","ES.BalancePossiblyInfiniteDuration","Infinity","ES.TemporalDurationToString","DurationFormat","console","warn","shift1","ES.CalculateOffsetShift","shift2","totalNs1","ES.TotalDurationNanoseconds","totalNs2","PlainMonthDay","referenceISOYearParam","ES.CreateTemporalMonthDaySlots","temporalMonthDayLike","ES.ToTemporalMonthDay","ES.TemporalMonthDayToString","receiverFieldNames","inputFieldNames","mergedFields","ES.SystemUTCEpochNanoSeconds","ES.DefaultTimeZone","tZ","ES.GetPlainDateTimeFor","plainDateTimeISO","Now","plainDateISO","plainTimeISO","timeZoneId","zonedDateTimeISO","TemporalTimeToString","ES.RoundTime","ES.FormatSecondsStringPart","PlainTime","isoHourParam","isoMinuteParam","isoSecondParam","isoMillisecondParam","isoMicrosecondParam","isoNanosecondParam","ES.RejectTime","temporalTimeLike","partialTime","ES.ToTemporalTimeRecord","ES.RegulateTime","ES.AddDurationToOrSubtractDurationFromPlainTime","ES.DifferenceTemporalPlainTime","TimeZone","timeZoneIdentifierParam","ES.GetCanonicalTimeZoneIdentifier","getOffsetNanosecondsFor","instantParam","ES.IsTimeZoneOffsetString","ES.ParseTimeZoneOffsetString","ES.GetNamedTimeZoneOffsetNanoseconds","getOffsetStringFor","ES.GetOffsetStringFor","getPlainDateTimeFor","getInstantFor","dateTimeParam","getPossibleInstantsFor","ES.GetUTCEpochNanoseconds","possibleEpochNs","GetNamedTimeZoneEpochNanoseconds","nsEarlier","nsLater","earliest","latest","ES.GetNamedTimeZoneEpochNanoseconds","getNextTransition","startingPointParam","startingPoint","ES.GetNamedTimeZoneNextTransition","getPreviousTransition","ES.GetNamedTimeZonePreviousTransition","ES.ToTemporalTimeZoneObject","PlainYearMonth","referenceISODayParam","ES.CreateTemporalYearMonthSlots","temporalYearMonthLike","ES.AddDurationToOrSubtractDurationFromPlainYearMonth","ES.DifferenceTemporalPlainYearMonth","ES.ToTemporalYearMonth","ES.TemporalYearMonthToString","customResolvedOptions","ZonedDateTime","ES.CreateTemporalZonedDateTimeSlots","ES.ToTemporalTimeZoneIdentifier","hoursInDay","today","tomorrowFields","tomorrow","todayNs","tomorrowNs","ES.BigIntDivideToNumber","ES.GetOffsetNanosecondsFor","temporalZonedDateTimeLike","ES.ToTemporalOffset","ES.InterpretISODateTimeOffset","thisDt","withTimeZone","ES.AddDurationToOrSubtractDurationFromZonedDateTime","ES.DifferenceTemporalZonedDateTime","instantStart","ES.AddZonedDateTime","lessThanOrEqual","ES.ToTemporalZonedDateTime","ES.TimeZoneEquals","ToShowOffsetOption","ES.ToShowOffsetOption","ToTimeZoneNameOption","ES.ToTimeZoneNameOption","ES.TemporalZonedDateTimeToString","localeCalendarIdentifier","calendarIdentifier","startOfDay","toInstant","getTimeZone","toTemporalInstant","types","Temporal.Instant","Temporal.Calendar","Temporal.PlainDate","Temporal.PlainDateTime","Temporal.Duration","Temporal.PlainMonthDay","Temporal.PlainTime","Temporal.TimeZone","Temporal.PlainYearMonth","Temporal.ZonedDateTime"],"mappings":"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"}