var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import chai, { expect } from 'chai';
import freeForAll from '../vectors/protocol-definitions/free-for-all.json' assert { type: 'json' };
import friendRoleProtocolDefinition from '../vectors/protocol-definitions/friend-role.json' assert { type: 'json' };
import nestedProtocol from '../vectors/protocol-definitions/nested.json' assert { type: 'json' };
import threadRoleProtocolDefinition from '../vectors/protocol-definitions/thread-role.json' assert { type: 'json' };
import { ArrayUtility } from '../../src/utils/array.js';
import { DateSort } from '../../src/types/records-types.js';
import { DwnConstant } from '../../src/core/dwn-constant.js';
import { DwnErrorCode } from '../../src/core/dwn-error.js';
import { Encoder } from '../../src/utils/encoder.js';
import { Jws } from '../../src/utils/jws.js';
import { Message } from '../../src/core/message.js';
import { RecordsQuery } from '../../src/interfaces/records-query.js';
import { RecordsQueryHandler } from '../../src/handlers/records-query.js';
import { RecordsWriteHandler } from '../../src/handlers/records-write.js';
import { stubInterface } from 'ts-sinon';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestEventStream } from '../test-event-stream.js';
import { TestStores } from '../test-stores.js';
import { TestStubGenerator } from '../utils/test-stub-generator.js';
import { DidKey, UniversalResolver } from '@web5/dids';
import { Dwn, RecordsWrite, Time } from '../../src/index.js';
chai.use(chaiAsPromised);
export function testRecordsQueryHandler() {
    describe('RecordsQueryHandler.handle()', () => {
        describe('functional tests', () => {
            let didResolver;
            let messageStore;
            let dataStore;
            let resumableTaskStore;
            let eventLog;
            let eventStream;
            let dwn;
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new UniversalResolver({ didResolvers: [DidKey] });
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                resumableTaskStore = stores.resumableTaskStore;
                eventLog = stores.eventLog;
                eventStream = TestEventStream.get();
                dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog, eventStream, resumableTaskStore });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield resumableTaskStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('should reject when published is set to false with a dateSort set to sorting by `PublishedAscending` or `PublishedDescending`', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generatePersona();
                TestStubGenerator.stubDidResolver(didResolver, [alice]);
                const query = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { published: false } });
                //control
                let reply = yield dwn.processMessage(alice.did, query.message);
                expect(reply.status.code).to.equal(200);
                // modify dateSort to publishedAscending
                query.message.descriptor.dateSort = DateSort.PublishedAscending;
                reply = yield dwn.processMessage(alice.did, query.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.include('queries must not filter for `published:false` and sort');
                // modify dateSort to publishedDescending
                query.message.descriptor.dateSort = DateSort.PublishedDescending;
                reply = yield dwn.processMessage(alice.did, query.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.include('queries must not filter for `published:false` and sort');
            }));
            it('should return recordId, descriptor, authorization and attestation', () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const alice = yield TestDataGenerator.generatePersona();
                const bob = yield TestDataGenerator.generatePersona();
                TestStubGenerator.stubDidResolver(didResolver, [alice, bob]);
                const dataFormat = 'myAwesomeDataFormat';
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [bob], dataFormat });
                const writeReply = yield dwn.processMessage(alice.did, write.message, { dataStream: write.dataStream });
                expect(writeReply.status.code).to.equal(202);
                const query = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataFormat } });
                const reply = yield dwn.processMessage(alice.did, query.message);
                expect((_a = reply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(1);
                const entry = reply.entries[0];
                expect(entry.authorization).to.deep.equal(write.message.authorization);
                expect(entry.attestation).to.deep.equal(write.message.attestation);
                expect(entry.descriptor).to.deep.equal(write.message.descriptor);
                expect(entry.recordId).to.equal(write.message.recordId);
            }));
            it('should return records matching the query', () => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                // insert three messages into DB, two with matching protocol
                const alice = yield TestDataGenerator.generatePersona();
                const dataFormat = 'myAwesomeDataFormat';
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dataFormat, schema: 'schema1' });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dataFormat, schema: 'schema2' });
                // setting up a stub resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing singular conditional query
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataFormat } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_b = reply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(2); // only 2 entries should match the query on protocol
                // testing multi-conditional query, reuse data generated above for bob
                const messageData2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        dataFormat,
                        schema: 'schema1'
                    }
                });
                const reply2 = yield dwn.processMessage(alice.did, messageData2.message);
                expect(reply2.status.code).to.equal(200);
                expect((_c = reply2.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(1); // only 1 entry should match the query
            }));
            it('should return `encodedData` if data size is within the spec threshold', () => __awaiter(this, void 0, void 0, function* () {
                var _d;
                const data = TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded); // within/on threshold
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, data });
                const writeReply = yield dwn.processMessage(alice.did, write.message, { dataStream: write.dataStream });
                expect(writeReply.status.code).to.equal(202);
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { recordId: write.message.recordId } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_d = reply.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(data));
            }));
            it('should not return `encodedData` if data size is greater then spec threshold', () => __awaiter(this, void 0, void 0, function* () {
                var _e;
                const data = TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded + 1); // exceeding threshold
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, data });
                const writeReply = yield dwn.processMessage(alice.did, write.message, { dataStream: write.dataStream });
                expect(writeReply.status.code).to.equal(202);
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { recordId: write.message.recordId } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_e = reply.entries) === null || _e === void 0 ? void 0 : _e.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.be.undefined;
            }));
            it('should include `initialWrite` property if RecordsWrite is not initial write', () => __awaiter(this, void 0, void 0, function* () {
                var _f, _g;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: false });
                const writeReply = yield dwn.processMessage(alice.did, write.message, { dataStream: write.dataStream });
                expect(writeReply.status.code).to.equal(202);
                // write an update to the record
                const write2 = yield RecordsWrite.createFrom({ recordsWriteMessage: write.message, published: true, signer: Jws.createSigner(alice) });
                const write2Reply = yield dwn.processMessage(alice.did, write2.message);
                expect(write2Reply.status.code).to.equal(202);
                // make sure result returned now has `initialWrite` property
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { recordId: write.message.recordId } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_f = reply.entries) === null || _f === void 0 ? void 0 : _f.length).to.equal(1);
                expect(reply.entries[0].initialWrite).to.exist;
                expect((_g = reply.entries[0].initialWrite) === null || _g === void 0 ? void 0 : _g.recordId).to.equal(write.message.recordId);
            }));
            it('should be able to query by attester', () => __awaiter(this, void 0, void 0, function* () {
                var _h, _j, _k;
                // scenario: 2 records authored by alice, 1st attested by alice, 2nd attested by bob
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const recordsWrite1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [alice] });
                const recordsWrite2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [bob] });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, recordsWrite1.message, { dataStream: recordsWrite1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, recordsWrite2.message, { dataStream: recordsWrite2.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                // testing attester filter
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { attester: alice.did } });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_h = reply1.entries) === null || _h === void 0 ? void 0 : _h.length).to.equal(1);
                const reply1Attester = Jws.getSignerDid(reply1.entries[0].attestation.signatures[0]);
                expect(reply1Attester).to.equal(alice.did);
                // testing attester + another filter
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { attester: bob.did, schema: recordsWrite2.message.descriptor.schema }
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_j = reply2.entries) === null || _j === void 0 ? void 0 : _j.length).to.equal(1);
                const reply2Attester = Jws.getSignerDid(reply2.entries[0].attestation.signatures[0]);
                expect(reply2Attester).to.equal(bob.did);
                // testing attester filter that yields no results
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { attester: carol.did } });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_k = reply3.entries) === null || _k === void 0 ? void 0 : _k.length).to.equal(0);
            }));
            it('should be able to query by author', () => __awaiter(this, void 0, void 0, function* () {
                var _l, _m, _o, _p;
                // scenario alice and bob both author records into alice's DWN.
                // alice is able to filter for records authored by bob.
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const protocolDefinition = freeForAll;
                const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition
                });
                const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                expect(protocolsConfigureReply.status.code).to.equal(202);
                const aliceAuthorWrite = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    protocol: protocolDefinition.protocol,
                    schema: protocolDefinition.types.post.schema,
                    dataFormat: protocolDefinition.types.post.dataFormats[0],
                    protocolPath: 'post'
                });
                const aliceAuthorReply = yield dwn.processMessage(alice.did, aliceAuthorWrite.message, { dataStream: aliceAuthorWrite.dataStream });
                expect(aliceAuthorReply.status.code).to.equal(202);
                const bobAuthorWrite = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    protocol: protocolDefinition.protocol,
                    schema: protocolDefinition.types.post.schema,
                    dataFormat: protocolDefinition.types.post.dataFormats[0],
                    protocolPath: 'post'
                });
                const bobAuthorReply = yield dwn.processMessage(alice.did, bobAuthorWrite.message, { dataStream: bobAuthorWrite.dataStream });
                expect(bobAuthorReply.status.code).to.equal(202);
                // alice queries with an empty filter, gets both
                let recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                let queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_l = queryReply.entries) === null || _l === void 0 ? void 0 : _l.length).to.equal(2);
                // filter for bob as author
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        author: bob.did,
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_m = queryReply.entries) === null || _m === void 0 ? void 0 : _m.length).to.equal(1);
                expect(queryReply.entries[0].recordId).to.equal(bobAuthorWrite.message.recordId);
                // empty array for author should return all same as undefined author field
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        author: [],
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_o = queryReply.entries) === null || _o === void 0 ? void 0 : _o.length).to.equal(2);
                // query for both authors explicitly
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        author: [alice.did, bob.did],
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_p = queryReply.entries) === null || _p === void 0 ? void 0 : _p.length).to.equal(2);
            }));
            it('should be able to query by recipient', () => __awaiter(this, void 0, void 0, function* () {
                var _q, _r, _s, _t, _u;
                // scenario alice authors records for bob and carol into alice's DWN.
                // bob and carol are able to filter for records for them.
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                const protocolDefinition = freeForAll;
                const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition
                });
                const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                expect(protocolsConfigureReply.status.code).to.equal(202);
                const aliceToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                    protocol: protocolDefinition.protocol,
                    schema: protocolDefinition.types.post.schema,
                    dataFormat: protocolDefinition.types.post.dataFormats[0],
                    protocolPath: 'post'
                });
                const aliceToBobReply = yield dwn.processMessage(alice.did, aliceToBob.message, { dataStream: aliceToBob.dataStream });
                expect(aliceToBobReply.status.code).to.equal(202);
                const aliceToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: carol.did,
                    protocol: protocolDefinition.protocol,
                    schema: protocolDefinition.types.post.schema,
                    dataFormat: protocolDefinition.types.post.dataFormats[0],
                    protocolPath: 'post'
                });
                const aliceToCarolReply = yield dwn.processMessage(alice.did, aliceToCarol.message, { dataStream: aliceToCarol.dataStream });
                expect(aliceToCarolReply.status.code).to.equal(202);
                // alice queries with an empty filter, gets both
                let recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                let queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_q = queryReply.entries) === null || _q === void 0 ? void 0 : _q.length).to.equal(2);
                // filter for bob as recipient
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_r = queryReply.entries) === null || _r === void 0 ? void 0 : _r.length).to.equal(1);
                expect(queryReply.entries[0].recordId).to.equal(aliceToBob.message.recordId);
                // filter for carol as recipient
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        recipient: carol.did,
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_s = queryReply.entries) === null || _s === void 0 ? void 0 : _s.length).to.equal(1);
                expect(queryReply.entries[0].recordId).to.equal(aliceToCarol.message.recordId);
                // empty array for recipient should return all same as undefined recipient field
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        recipient: [],
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_t = queryReply.entries) === null || _t === void 0 ? void 0 : _t.length).to.equal(2);
                // query for both recipients explicitly
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        recipient: [bob.did, carol.did],
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_u = queryReply.entries) === null || _u === void 0 ? void 0 : _u.length).to.equal(2);
            }));
            it('should be able to query for published records', () => __awaiter(this, void 0, void 0, function* () {
                var _v, _w, _x, _y, _z, _0, _1, _2, _3;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                // create a published record
                const publishedWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true, schema: 'post' });
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWrite.message, { dataStream: publishedWrite.dataStream });
                expect(publishedWriteReply.status.code).to.equal(202);
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, { dataStream: draftWrite.dataStream });
                expect(draftWriteReply.status.code).to.equal(202);
                // query for only published records
                const publishedPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { schema: 'post', published: true } });
                let publishedPostReply = yield dwn.processMessage(alice.did, publishedPostQuery.message);
                expect(publishedPostReply.status.code).to.equal(200);
                expect((_v = publishedPostReply.entries) === null || _v === void 0 ? void 0 : _v.length).to.equal(1);
                expect(publishedPostReply.entries[0].recordId).to.equal(publishedWrite.message.recordId);
                // make an query for published records from non owner
                const notOwnerPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post', published: true } });
                let notOwnerPublishedPostReply = yield dwn.processMessage(alice.did, notOwnerPostQuery.message);
                expect(notOwnerPublishedPostReply.status.code).to.equal(200);
                expect((_w = notOwnerPublishedPostReply.entries) === null || _w === void 0 ? void 0 : _w.length).to.equal(1);
                expect(notOwnerPublishedPostReply.entries[0].recordId).to.equal(publishedWrite.message.recordId);
                // anonymous query for published records
                const anonymousPostQuery = yield RecordsQuery.create({ filter: { schema: 'post', published: true } });
                let anonymousPublishedPostReply = yield dwn.processMessage(alice.did, anonymousPostQuery.message);
                expect(anonymousPublishedPostReply.status.code).to.equal(200);
                expect((_x = anonymousPublishedPostReply.entries) === null || _x === void 0 ? void 0 : _x.length).to.equal(1);
                expect(anonymousPublishedPostReply.entries[0].recordId).to.equal(publishedWrite.message.recordId);
                // publish the unpublished record
                const publishedDraftWrite = yield RecordsWrite.createFrom({
                    recordsWriteMessage: draftWrite.message,
                    published: true,
                    signer: Jws.createSigner(alice)
                });
                const publishedDraftReply = yield dwn.processMessage(alice.did, publishedDraftWrite.message);
                expect(publishedDraftReply.status.code).to.equal(202);
                // issue the same query for published records
                publishedPostReply = yield dwn.processMessage(alice.did, publishedPostQuery.message);
                expect(publishedPostReply.status.code).to.equal(200);
                expect((_y = publishedPostReply.entries) === null || _y === void 0 ? void 0 : _y.length).to.equal(2);
                const returnedRecordIds = (_z = publishedPostReply.entries) === null || _z === void 0 ? void 0 : _z.map(e => e.recordId);
                // ensure that both records now exist in results
                expect(returnedRecordIds).to.have.members([publishedWrite.message.recordId, draftWrite.message.recordId]);
                // query after publishing from non owner
                notOwnerPublishedPostReply = yield dwn.processMessage(alice.did, anonymousPostQuery.message);
                expect(notOwnerPublishedPostReply.status.code).to.equal(200);
                expect((_0 = notOwnerPublishedPostReply.entries) === null || _0 === void 0 ? void 0 : _0.length).to.equal(2);
                const nonOwnerReturnedRecordIds = (_1 = notOwnerPublishedPostReply.entries) === null || _1 === void 0 ? void 0 : _1.map(e => e.recordId);
                expect(nonOwnerReturnedRecordIds).to.have.members([publishedWrite.message.recordId, draftWrite.message.recordId]);
                // anonymous query after publishing
                anonymousPublishedPostReply = yield dwn.processMessage(alice.did, anonymousPostQuery.message);
                expect(anonymousPublishedPostReply.status.code).to.equal(200);
                expect((_2 = anonymousPublishedPostReply.entries) === null || _2 === void 0 ? void 0 : _2.length).to.equal(2);
                const anonymousReturnedRecordIds = (_3 = anonymousPublishedPostReply.entries) === null || _3 === void 0 ? void 0 : _3.map(e => e.recordId);
                expect(anonymousReturnedRecordIds).to.have.members([publishedWrite.message.recordId, draftWrite.message.recordId]);
            }));
            it('should be able to query for unpublished records', () => __awaiter(this, void 0, void 0, function* () {
                var _4, _5;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // create a published record
                const publishedWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true, schema: 'post' });
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWrite.message, { dataStream: publishedWrite.dataStream });
                expect(publishedWriteReply.status.code).to.equal(202);
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, { dataStream: draftWrite.dataStream });
                expect(draftWriteReply.status.code).to.equal(202);
                // query for only unpublished records
                const unpublishedPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { schema: 'post', published: false } });
                let unpublishedPostReply = yield dwn.processMessage(alice.did, unpublishedPostQuery.message);
                expect(unpublishedPostReply.status.code).to.equal(200);
                expect((_4 = unpublishedPostReply.entries) === null || _4 === void 0 ? void 0 : _4.length).to.equal(1);
                expect(unpublishedPostReply.entries[0].recordId).to.equal(draftWrite.message.recordId);
                // publish the unpublished record
                const publishedDraftWrite = yield RecordsWrite.createFrom({
                    recordsWriteMessage: draftWrite.message,
                    published: true,
                    signer: Jws.createSigner(alice)
                });
                const publishedDraftReply = yield dwn.processMessage(alice.did, publishedDraftWrite.message);
                expect(publishedDraftReply.status.code).to.equal(202);
                // issue the same query for unpublished records
                unpublishedPostReply = yield dwn.processMessage(alice.did, unpublishedPostQuery.message);
                expect(unpublishedPostReply.status.code).to.equal(200);
                expect((_5 = unpublishedPostReply.entries) === null || _5 === void 0 ? void 0 : _5.length).to.equal(0);
            }));
            it('should not be able to query for unpublished records if unauthorized', () => __awaiter(this, void 0, void 0, function* () {
                var _6, _7, _8, _9;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                // create a published record
                const publishedWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true, schema: 'post' });
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWrite.message, { dataStream: publishedWrite.dataStream });
                expect(publishedWriteReply.status.code).to.equal(202);
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, { dataStream: draftWrite.dataStream });
                expect(draftWriteReply.status.code).to.equal(202);
                // bob queries for unpublished records returns zero
                const unpublishedNotOwner = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post', published: false } });
                let notOwnerPostReply = yield dwn.processMessage(alice.did, unpublishedNotOwner.message);
                expect(notOwnerPostReply.status.code).to.equal(200);
                expect((_6 = notOwnerPostReply.entries) === null || _6 === void 0 ? void 0 : _6.length).to.equal(0);
                // publish the unpublished record
                const publishedDraftWrite = yield RecordsWrite.createFrom({
                    recordsWriteMessage: draftWrite.message,
                    published: true,
                    signer: Jws.createSigner(alice)
                });
                const publishedDraftReply = yield dwn.processMessage(alice.did, publishedDraftWrite.message);
                expect(publishedDraftReply.status.code).to.equal(202);
                // without published filter
                let publishedNotOwner = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post' } });
                let publishedNotOwnerReply = yield dwn.processMessage(alice.did, publishedNotOwner.message);
                expect(publishedNotOwnerReply.status.code).to.equal(200);
                expect((_7 = publishedNotOwnerReply.entries) === null || _7 === void 0 ? void 0 : _7.length).to.equal(2);
                // with explicit published true
                publishedNotOwner = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post', published: true } });
                publishedNotOwnerReply = yield dwn.processMessage(alice.did, publishedNotOwner.message);
                expect(publishedNotOwnerReply.status.code).to.equal(200);
                expect((_8 = publishedNotOwnerReply.entries) === null || _8 === void 0 ? void 0 : _8.length).to.equal(2);
                // with explicit published false after publishing should still return nothing
                notOwnerPostReply = yield dwn.processMessage(alice.did, unpublishedNotOwner.message);
                expect(notOwnerPostReply.status.code).to.equal(200);
                expect((_9 = notOwnerPostReply.entries) === null || _9 === void 0 ? void 0 : _9.length).to.equal(0);
            }));
            it('should be able to query for a record by a dataCid', () => __awaiter(this, void 0, void 0, function* () {
                var _10;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // create a record
                const writeRecord = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const writeRecordReply = yield dwn.processMessage(alice.did, writeRecord.message, { dataStream: writeRecord.dataStream });
                expect(writeRecordReply.status.code).to.equal(202);
                const recordDataCid = writeRecord.message.descriptor.dataCid;
                // query for the record by it's dataCid
                const dataCidQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataCid: recordDataCid } });
                const dataCidQueryReply = yield dwn.processMessage(alice.did, dataCidQuery.message);
                expect(dataCidQueryReply.status.code).to.equal(200);
                expect((_10 = dataCidQueryReply.entries) === null || _10 === void 0 ? void 0 : _10.length).to.equal(1);
                expect(dataCidQueryReply.entries[0].recordId).to.equal(writeRecord.message.recordId);
            }));
            it('should be able to query with `dataSize` filter (half-open range)', () => __awaiter(this, void 0, void 0, function* () {
                var _11, _12, _13, _14, _15, _16, _17, _18;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(10) });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(50) });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(100) });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing gt
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gt: 10 } },
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_11 = reply1.entries) === null || _11 === void 0 ? void 0 : _11.length).to.equal(2);
                expect((_12 = reply1.entries) === null || _12 === void 0 ? void 0 : _12.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write2.dataBytes),
                    Encoder.bytesToBase64Url(write3.dataBytes)
                ]);
                // testing lt
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { lt: 100 } },
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_13 = reply2.entries) === null || _13 === void 0 ? void 0 : _13.length).to.equal(2);
                expect((_14 = reply2.entries) === null || _14 === void 0 ? void 0 : _14.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write1.dataBytes),
                    Encoder.bytesToBase64Url(write2.dataBytes)
                ]);
                // testing gte
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gte: 10 } },
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_15 = reply3.entries) === null || _15 === void 0 ? void 0 : _15.length).to.equal(3);
                expect((_16 = reply3.entries) === null || _16 === void 0 ? void 0 : _16.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write1.dataBytes),
                    Encoder.bytesToBase64Url(write2.dataBytes),
                    Encoder.bytesToBase64Url(write3.dataBytes)
                ]);
                // testing lte
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { lte: 100 } },
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_17 = reply4.entries) === null || _17 === void 0 ? void 0 : _17.length).to.equal(3);
                expect((_18 = reply4.entries) === null || _18 === void 0 ? void 0 : _18.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write1.dataBytes),
                    Encoder.bytesToBase64Url(write2.dataBytes),
                    Encoder.bytesToBase64Url(write3.dataBytes)
                ]);
            }));
            it('should be able to range query with `dataSize` filter (open & closed range)', () => __awaiter(this, void 0, void 0, function* () {
                var _19, _20, _21, _22, _23, _24;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(10) });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(50) });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(100) });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing range using gt & lt
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gt: 10, lt: 60 } },
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_19 = reply1.entries) === null || _19 === void 0 ? void 0 : _19.length).to.equal(1);
                expect(reply1.entries[0].recordId).to.equal(write2.message.recordId);
                // testing range using gte & lt
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gte: 10, lt: 60 } },
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_20 = reply2.entries) === null || _20 === void 0 ? void 0 : _20.length).to.equal(2);
                const reply2RecordIds = (_21 = reply2.entries) === null || _21 === void 0 ? void 0 : _21.map(e => e.recordId);
                expect(reply2RecordIds).to.have.members([write1.message.recordId, write2.message.recordId]);
                // testing range using gt & lte
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gt: 50, lte: 100 } },
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_22 = reply3.entries) === null || _22 === void 0 ? void 0 : _22.length).to.equal(1);
                expect(reply3.entries[0].recordId).to.equal(write3.message.recordId);
                // testing range using gte & lte
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gte: 10, lte: 100 } },
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_23 = reply4.entries) === null || _23 === void 0 ? void 0 : _23.length).to.equal(3);
                const reply4RecordIds = (_24 = reply4.entries) === null || _24 === void 0 ? void 0 : _24.map(e => e.recordId);
                expect(reply4RecordIds).to.have.members([write1.message.recordId, write2.message.recordId, write3.message.recordId]);
            }));
            it('should be able to range query by `dateCreated`', () => __awaiter(this, void 0, void 0, function* () {
                var _25, _26, _27, _28;
                // scenario: 3 records authored by alice, created on first of 2021, 2022, and 2023 respectively
                // only the first 2 records share the same schema
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021 });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2022, messageTimestamp: firstDayOf2022 });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2023, messageTimestamp: firstDayOf2023 });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing `from` range
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_25 = reply1.entries) === null || _25 === void 0 ? void 0 : _25.length).to.equal(2);
                expect(reply1.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
                expect(reply1.entries[1].encodedData).to.equal(Encoder.bytesToBase64Url(write3.dataBytes));
                // testing `to` range
                const lastDayOf2022 = Time.createTimestamp({ year: 2022, month: 12, day: 31 });
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { to: lastDayOf2022 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_26 = reply2.entries) === null || _26 === void 0 ? void 0 : _26.length).to.equal(2);
                expect(reply2.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write1.dataBytes));
                expect(reply2.entries[1].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
                // testing `from` and `to` range
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: lastDayOf2022, to: lastDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_27 = reply3.entries) === null || _27 === void 0 ? void 0 : _27.length).to.equal(1);
                expect(reply3.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write3.dataBytes));
                // testing edge case where value equals `from` and `to`
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: firstDayOf2022, to: firstDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_28 = reply4.entries) === null || _28 === void 0 ? void 0 : _28.length).to.equal(1);
                expect(reply4.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
            }));
            it('should not return records that were published and then unpublished ', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: 3 records authored by alice, published on first of 2021, 2022, and 2023 respectively
                // then the records are unpublished and tested to not return when filtering for published records
                var _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40;
                const firstDayOf2020 = Time.createTimestamp({ year: 2020, month: 1, day: 1 });
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2021, messageTimestamp: firstDayOf2020
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2022, messageTimestamp: firstDayOf2020
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2023, messageTimestamp: firstDayOf2020
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // confirm range before un-publishing.
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const ownerRangeQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, ownerRangeQuery.message);
                expect((_29 = reply1.entries) === null || _29 === void 0 ? void 0 : _29.length).to.equal(2);
                const reply1RecordIds = (_30 = reply1.entries) === null || _30 === void 0 ? void 0 : _30.map(e => e.recordId);
                expect(reply1RecordIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // confirm published true filter before un-publishing
                const ownerPublishedQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { published: true },
                    dateSort: DateSort.CreatedAscending
                });
                let ownerPublishedReply = yield dwn.processMessage(alice.did, ownerPublishedQuery.message);
                expect(ownerPublishedReply.status.code).to.equal(200);
                expect((_31 = ownerPublishedReply.entries) === null || _31 === void 0 ? void 0 : _31.length).to.equal(3);
                const ownerPublishedIds = (_32 = ownerPublishedReply.entries) === null || _32 === void 0 ? void 0 : _32.map(e => e.recordId);
                expect(ownerPublishedIds).to.have.members([write1.message.recordId, write2.message.recordId, write3.message.recordId]);
                // confirm for anonymous query before un-publishing
                const anonymousRangeQuery = yield RecordsQuery.create({
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                let anonymousRangeReply = yield dwn.processMessage(alice.did, anonymousRangeQuery.message);
                expect(anonymousRangeReply.status.code).to.equal(200);
                expect((_33 = anonymousRangeReply.entries) === null || _33 === void 0 ? void 0 : _33.length).to.equal(2);
                const anonymousReplyIds = (_34 = anonymousRangeReply.entries) === null || _34 === void 0 ? void 0 : _34.map(e => e.recordId);
                expect(anonymousReplyIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // confirm anonymous published true filter before un-publishing
                const anonymousPublishedQuery = yield RecordsQuery.create({
                    filter: { published: true },
                    dateSort: DateSort.CreatedAscending
                });
                let anonymousPublishedReply = yield dwn.processMessage(alice.did, anonymousPublishedQuery.message);
                expect(anonymousPublishedReply.status.code).to.equal(200);
                expect((_35 = anonymousPublishedReply.entries) === null || _35 === void 0 ? void 0 : _35.length).to.equal(3);
                const anonymousPublishedIds = (_36 = anonymousPublishedReply.entries) === null || _36 === void 0 ? void 0 : _36.map(e => e.recordId);
                expect(anonymousPublishedIds).to.have.members([write1.message.recordId, write2.message.recordId, write3.message.recordId]);
                //unpublish records
                const write1Unpublish = yield RecordsWrite.createFrom({
                    signer: Jws.createSigner(alice),
                    recordsWriteMessage: write1.message,
                    published: false
                });
                const write2Unpublish = yield RecordsWrite.createFrom({
                    signer: Jws.createSigner(alice),
                    recordsWriteMessage: write2.message,
                    published: false
                });
                const write3Unpublish = yield RecordsWrite.createFrom({
                    signer: Jws.createSigner(alice),
                    recordsWriteMessage: write3.message,
                    published: false
                });
                const unpublished1Response = yield dwn.processMessage(alice.did, write1Unpublish.message);
                const unpublished2Response = yield dwn.processMessage(alice.did, write2Unpublish.message);
                const unpublished3Response = yield dwn.processMessage(alice.did, write3Unpublish.message);
                expect(unpublished1Response.status.code).to.equal(202);
                expect(unpublished2Response.status.code).to.equal(202);
                expect(unpublished3Response.status.code).to.equal(202);
                // try datePublished range query as an anonymous user after unpublish
                anonymousRangeReply = yield dwn.processMessage(alice.did, anonymousRangeQuery.message);
                expect(anonymousRangeReply.status.code).to.equal(200);
                expect((_37 = anonymousRangeReply.entries) === null || _37 === void 0 ? void 0 : _37.length).to.equal(0);
                // try published:true filter as an anonymous user after unpublish
                anonymousPublishedReply = yield dwn.processMessage(alice.did, anonymousPublishedQuery.message);
                expect(anonymousPublishedReply.status.code).to.equal(200);
                expect((_38 = anonymousPublishedReply.entries) === null || _38 === void 0 ? void 0 : _38.length).to.equal(0);
                // try datePublished range query as owner after unpublish
                const ownerRangeReply = yield dwn.processMessage(alice.did, ownerRangeQuery.message);
                expect(ownerRangeReply.status.code).to.equal(200);
                expect((_39 = ownerRangeReply.entries) === null || _39 === void 0 ? void 0 : _39.length).to.equal(0);
                // try published:true filter as owner after unpublish
                ownerPublishedReply = yield dwn.processMessage(alice.did, ownerPublishedQuery.message);
                expect(ownerPublishedReply.status.code).to.equal(200);
                expect((_40 = ownerPublishedReply.entries) === null || _40 === void 0 ? void 0 : _40.length).to.equal(0);
            }));
            it('should be able to range query by `datePublished`', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: 3 records authored by alice, published on first of 2021, 2022, and 2023 respectively
                // all 3 records are created on first of 2020
                var _41, _42, _43, _44, _45, _46, _47, _48, _49, _50;
                const firstDayOf2020 = Time.createTimestamp({ year: 2020, month: 1, day: 1 });
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2021, messageTimestamp: firstDayOf2020
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2022, messageTimestamp: firstDayOf2020
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2023, messageTimestamp: firstDayOf2020
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing `from` range
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_41 = reply1.entries) === null || _41 === void 0 ? void 0 : _41.length).to.equal(2);
                const reply1RecordIds = (_42 = reply1.entries) === null || _42 === void 0 ? void 0 : _42.map(e => e.recordId);
                expect(reply1RecordIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // testing `to` range
                const lastDayOf2022 = Time.createTimestamp({ year: 2022, month: 12, day: 31 });
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { to: lastDayOf2022 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_43 = reply2.entries) === null || _43 === void 0 ? void 0 : _43.length).to.equal(2);
                const reply2RecordIds = (_44 = reply2.entries) === null || _44 === void 0 ? void 0 : _44.map(e => e.recordId);
                expect(reply2RecordIds).to.have.members([write1.message.recordId, write2.message.recordId]);
                // testing `from` and `to` range
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: lastDayOf2022, to: lastDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_45 = reply3.entries) === null || _45 === void 0 ? void 0 : _45.length).to.equal(1);
                expect(reply3.entries[0].recordId).to.equal(write3.message.recordId);
                // testing edge case where value equals `from` and `to`
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: firstDayOf2022, to: firstDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_46 = reply4.entries) === null || _46 === void 0 ? void 0 : _46.length).to.equal(1);
                expect(reply4.entries[0].recordId).to.equal(write2.message.recordId);
                // check for anonymous range query
                const anonymousRecordQuery = yield RecordsQuery.create({
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const anonymousReply = yield dwn.processMessage(alice.did, anonymousRecordQuery.message);
                expect(anonymousReply.status.code).to.equal(200);
                expect((_47 = anonymousReply.entries) === null || _47 === void 0 ? void 0 : _47.length).to.equal(2);
                const anonymousReplyIds = (_48 = anonymousReply.entries) === null || _48 === void 0 ? void 0 : _48.map(e => e.recordId);
                expect(anonymousReplyIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // check for non owner range query
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const nonOwnerRange = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const nonOwnerReply = yield dwn.processMessage(alice.did, nonOwnerRange.message);
                expect(nonOwnerReply.status.code).to.equal(200);
                expect((_49 = nonOwnerReply.entries) === null || _49 === void 0 ? void 0 : _49.length).to.equal(2);
                const nonOwnerReplyIds = (_50 = nonOwnerReply.entries) === null || _50 === void 0 ? void 0 : _50.map(e => e.recordId);
                expect(nonOwnerReplyIds).to.have.members([write2.message.recordId, write3.message.recordId]);
            }));
            it('should be able to range query by `dateUpdated`', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: alice creates 3 records on the first day of 2020.
                // alice then updates these records to published on first of 2021, 2022, and 2023 respectively
                // this should update the messageTimestamp on the respective messages
                var _51, _52, _53, _54, _55, _56;
                const firstDayOf2020 = Time.createTimestamp({ year: 2020, month: 1, day: 1 });
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2020, messageTimestamp: firstDayOf2020
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2020, messageTimestamp: firstDayOf2020
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2020, messageTimestamp: firstDayOf2020
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // update to published
                const write1Update = yield RecordsWrite.createFrom({
                    recordsWriteMessage: write1.message,
                    published: true,
                    messageTimestamp: firstDayOf2021,
                    datePublished: firstDayOf2021,
                    signer: Jws.createSigner(alice)
                });
                const write2Update = yield RecordsWrite.createFrom({
                    recordsWriteMessage: write2.message,
                    published: true,
                    messageTimestamp: firstDayOf2022,
                    datePublished: firstDayOf2022,
                    signer: Jws.createSigner(alice)
                });
                const write3Update = yield RecordsWrite.createFrom({
                    recordsWriteMessage: write3.message,
                    published: true,
                    messageTimestamp: firstDayOf2023,
                    datePublished: firstDayOf2023,
                    signer: Jws.createSigner(alice)
                });
                const writeReplyUpdate1 = yield dwn.processMessage(alice.did, write1Update.message);
                const writeReplyUpdate2 = yield dwn.processMessage(alice.did, write2Update.message);
                const writeReplyUpdate3 = yield dwn.processMessage(alice.did, write3Update.message);
                expect(writeReplyUpdate1.status.code).to.equal(202);
                expect(writeReplyUpdate2.status.code).to.equal(202);
                expect(writeReplyUpdate3.status.code).to.equal(202);
                // testing `from` range
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_51 = reply1.entries) === null || _51 === void 0 ? void 0 : _51.length).to.equal(2);
                const reply1RecordIds = (_52 = reply1.entries) === null || _52 === void 0 ? void 0 : _52.map(e => e.recordId);
                expect(reply1RecordIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // testing `to` range
                const lastDayOf2022 = Time.createTimestamp({ year: 2022, month: 12, day: 31 });
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { to: lastDayOf2022 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_53 = reply2.entries) === null || _53 === void 0 ? void 0 : _53.length).to.equal(2);
                const reply2RecordIds = (_54 = reply2.entries) === null || _54 === void 0 ? void 0 : _54.map(e => e.recordId);
                expect(reply2RecordIds).to.have.members([write1.message.recordId, write2.message.recordId]);
                // testing `from` and `to` range
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { from: lastDayOf2022, to: lastDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_55 = reply3.entries) === null || _55 === void 0 ? void 0 : _55.length).to.equal(1);
                expect(reply3.entries[0].recordId).to.equal(write3.message.recordId);
                // testing edge case where value equals `from` and `to`
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { from: firstDayOf2022, to: firstDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_56 = reply4.entries) === null || _56 === void 0 ? void 0 : _56.length).to.equal(1);
                expect(reply4.entries[0].recordId).to.equal(write2.message.recordId);
            }));
            it('should be able use range and exact match queries at the same time', () => __awaiter(this, void 0, void 0, function* () {
                var _57;
                // scenario: 3 records authored by alice, created on first of 2021, 2022, and 2023 respectively
                // only the first 2 records share the same schema
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const schema = '2021And2022Schema';
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021, schema
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2022, messageTimestamp: firstDayOf2022, schema
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2023, messageTimestamp: firstDayOf2023
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing range criterion with another exact match
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery5 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        schema,
                        dateCreated: { from: lastDayOf2021, to: lastDayOf2023 } // by itself selects the last 2 records
                    },
                    dateSort: DateSort.CreatedAscending
                });
                const reply = yield dwn.processMessage(alice.did, recordsQuery5.message);
                expect((_57 = reply.entries) === null || _57 === void 0 ? void 0 : _57.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
            }));
            it('should include `authorization` in returned records', () => __awaiter(this, void 0, void 0, function* () {
                var _58;
                const alice = yield TestDataGenerator.generatePersona();
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                const writeReply = yield dwn.processMessage(alice.did, message, { dataStream });
                expect(writeReply.status.code).to.equal(202);
                const queryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: message.descriptor.schema }
                });
                const queryReply = yield dwn.processMessage(alice.did, queryData.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_58 = queryReply.entries) === null || _58 === void 0 ? void 0 : _58.length).to.equal(1);
                expect(queryReply.entries[0].authorization).to.deep.equal(message.authorization);
            }));
            it('should include `attestation` in returned records', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: alice and bob attest to a message alice authored
                var _59, _60, _61;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [alice] });
                const writeReply = yield dwn.processMessage(alice.did, message, { dataStream });
                expect(writeReply.status.code).to.equal(202);
                const queryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: message.descriptor.schema }
                });
                const queryReply = yield dwn.processMessage(alice.did, queryData.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_59 = queryReply.entries) === null || _59 === void 0 ? void 0 : _59.length).to.equal(1);
                const recordsWriteMessage = queryReply.entries[0];
                expect((_61 = (_60 = recordsWriteMessage.attestation) === null || _60 === void 0 ? void 0 : _60.signatures) === null || _61 === void 0 ? void 0 : _61.length).to.equal(1);
            }));
            it('should omit records that are not published if `dateSort` sorts on `datePublished`', () => __awaiter(this, void 0, void 0, function* () {
                var _62, _63;
                // setup: 2 records in DWN: 1 published and 1 unpublished
                const alice = yield TestDataGenerator.generatePersona();
                const schema = 'aSchema';
                const publishedWriteData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, published: true
                });
                const unpublishedWriteData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, schema
                });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWriteData.message, { dataStream: publishedWriteData.dataStream });
                const unpublishedWriteReply = yield dwn.processMessage(alice.did, unpublishedWriteData.message, { dataStream: unpublishedWriteData.dataStream });
                expect(publishedWriteReply.status.code).to.equal(202);
                expect(unpublishedWriteReply.status.code).to.equal(202);
                // test published date ascending sort does not include any records that are not published
                const publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema }
                });
                const publishedAscendingQueryReply = yield dwn.processMessage(alice.did, publishedAscendingQueryData.message);
                expect((_62 = publishedAscendingQueryReply.entries) === null || _62 === void 0 ? void 0 : _62.length).to.equal(1);
                expect(publishedAscendingQueryReply.entries[0].recordId).to.equal(publishedWriteData.message.recordId);
                // test published date scending sort does not include any records that are not published
                const publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema }
                });
                const publishedDescendingQueryReply = yield dwn.processMessage(alice.did, publishedDescendingQueryData.message);
                expect((_63 = publishedDescendingQueryReply.entries) === null || _63 === void 0 ? void 0 : _63.length).to.equal(1);
                expect(publishedDescendingQueryReply.entries[0].recordId).to.equal(publishedWriteData.message.recordId);
            }));
            it('should sort records if `dateSort` is specified with and without a cursor', () => __awaiter(this, void 0, void 0, function* () {
                var _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75;
                // insert three messages into DB
                const alice = yield TestDataGenerator.generatePersona();
                const schema = 'aSchema';
                const published = true;
                const write1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                yield Time.minimalSleep();
                const write2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                yield Time.minimalSleep();
                const write3Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data, intentionally out of order
                const writeReply2 = yield dwn.processMessage(alice.did, write2Data.message, { dataStream: write2Data.dataStream });
                const writeReply1 = yield dwn.processMessage(alice.did, write1Data.message, { dataStream: write1Data.dataStream });
                const writeReply3 = yield dwn.processMessage(alice.did, write3Data.message, { dataStream: write3Data.dataStream });
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // createdAscending test
                let createdAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedAscending,
                    filter: { schema }
                });
                let createdAscendingQueryReply = yield dwn.processMessage(alice.did, createdAscendingQueryData.message);
                expect(createdAscendingQueryReply.entries.length).to.equal(3);
                expect((_64 = createdAscendingQueryReply.entries) === null || _64 === void 0 ? void 0 : _64[0].recordId).to.equal(write1Data.message.recordId);
                expect((_65 = createdAscendingQueryReply.entries) === null || _65 === void 0 ? void 0 : _65[1].recordId).to.equal(write2Data.message.recordId);
                expect((_66 = createdAscendingQueryReply.entries) === null || _66 === void 0 ? void 0 : _66[2].recordId).to.equal(write3Data.message.recordId);
                // to test with a cursor we first get a single record
                createdAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedAscending,
                    filter: { schema },
                    pagination: { limit: 1 }
                });
                createdAscendingQueryReply = yield dwn.processMessage(alice.did, createdAscendingQueryData.message);
                expect(createdAscendingQueryReply.entries.length).to.equal(1);
                // we then use the single record query's cursor to get the rest of the records
                createdAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedAscending,
                    filter: { schema },
                    pagination: { cursor: createdAscendingQueryReply.cursor }
                });
                createdAscendingQueryReply = yield dwn.processMessage(alice.did, createdAscendingQueryData.message);
                expect(createdAscendingQueryReply.entries.length).to.equal(2);
                expect(createdAscendingQueryReply.entries[0].recordId).to.equal(write2Data.message.recordId);
                expect(createdAscendingQueryReply.entries[1].recordId).to.equal(write3Data.message.recordId);
                // createdDescending test
                let createdDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedDescending,
                    filter: { schema }
                });
                let createdDescendingQueryReply = yield dwn.processMessage(alice.did, createdDescendingQueryData.message);
                expect(createdDescendingQueryReply.entries.length).to.equal(3);
                expect((_67 = createdDescendingQueryReply.entries) === null || _67 === void 0 ? void 0 : _67[0].recordId).to.equal(write3Data.message.recordId);
                expect((_68 = createdDescendingQueryReply.entries) === null || _68 === void 0 ? void 0 : _68[1].recordId).to.equal(write2Data.message.recordId);
                expect((_69 = createdDescendingQueryReply.entries) === null || _69 === void 0 ? void 0 : _69[2].recordId).to.equal(write1Data.message.recordId);
                // to test with a cursor we first get a single record
                createdDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedDescending,
                    filter: { schema },
                    pagination: { limit: 1 }
                });
                createdDescendingQueryReply = yield dwn.processMessage(alice.did, createdDescendingQueryData.message);
                expect(createdDescendingQueryReply.entries.length).to.equal(1);
                // we then use the single record query's cursor to get the rest of the records
                createdDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedDescending,
                    filter: { schema },
                    pagination: { cursor: createdDescendingQueryReply.cursor }
                });
                createdDescendingQueryReply = yield dwn.processMessage(alice.did, createdDescendingQueryData.message);
                expect(createdDescendingQueryReply.entries.length).to.equal(2);
                expect(createdDescendingQueryReply.entries[0].recordId).to.equal(write2Data.message.recordId);
                expect(createdDescendingQueryReply.entries[1].recordId).to.equal(write1Data.message.recordId);
                // publishedAscending test
                let publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema }
                });
                let publishedAscendingQueryReply = yield dwn.processMessage(alice.did, publishedAscendingQueryData.message);
                expect(publishedAscendingQueryReply.entries.length).to.equal(3);
                expect((_70 = publishedAscendingQueryReply.entries) === null || _70 === void 0 ? void 0 : _70[0].recordId).to.equal(write1Data.message.recordId);
                expect((_71 = publishedAscendingQueryReply.entries) === null || _71 === void 0 ? void 0 : _71[1].recordId).to.equal(write2Data.message.recordId);
                expect((_72 = publishedAscendingQueryReply.entries) === null || _72 === void 0 ? void 0 : _72[2].recordId).to.equal(write3Data.message.recordId);
                // to test with a cursor we first get a single record
                publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema },
                    pagination: { limit: 1 }
                });
                publishedAscendingQueryReply = yield dwn.processMessage(alice.did, publishedAscendingQueryData.message);
                expect(publishedAscendingQueryReply.entries.length).to.equal(1);
                publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema },
                    pagination: { cursor: publishedAscendingQueryReply.cursor }
                });
                publishedAscendingQueryReply = yield dwn.processMessage(alice.did, publishedAscendingQueryData.message);
                expect(publishedAscendingQueryReply.entries.length).to.equal(2);
                expect(publishedAscendingQueryReply.entries[0].recordId).to.equal(write2Data.message.recordId);
                expect(publishedAscendingQueryReply.entries[1].recordId).to.equal(write3Data.message.recordId);
                // publishedDescending test
                let publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema }
                });
                let publishedDescendingQueryReply = yield dwn.processMessage(alice.did, publishedDescendingQueryData.message);
                expect(publishedDescendingQueryReply.entries.length).to.equal(3);
                expect((_73 = publishedDescendingQueryReply.entries) === null || _73 === void 0 ? void 0 : _73[0].recordId).to.equal(write3Data.message.recordId);
                expect((_74 = publishedDescendingQueryReply.entries) === null || _74 === void 0 ? void 0 : _74[1].recordId).to.equal(write2Data.message.recordId);
                expect((_75 = publishedDescendingQueryReply.entries) === null || _75 === void 0 ? void 0 : _75[2].recordId).to.equal(write1Data.message.recordId);
                publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema },
                    pagination: { limit: 1 }
                });
                publishedDescendingQueryReply = yield dwn.processMessage(alice.did, publishedDescendingQueryData.message);
                expect(publishedDescendingQueryReply.entries.length).to.equal(1);
                publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema },
                    pagination: { cursor: publishedDescendingQueryReply.cursor }
                });
                publishedDescendingQueryReply = yield dwn.processMessage(alice.did, publishedDescendingQueryData.message);
                expect(publishedDescendingQueryReply.entries.length).to.equal(2);
                expect(publishedDescendingQueryReply.entries[0].recordId).to.equal(write2Data.message.recordId);
                expect(publishedDescendingQueryReply.entries[1].recordId).to.equal(write1Data.message.recordId);
            }));
            it('should tiebreak using `messageCid` when sorting encounters identical values', () => __awaiter(this, void 0, void 0, function* () {
                var _76;
                // setup: 3 messages with the same `dateCreated` value
                const dateCreated = Time.getCurrentTimestamp();
                const messageTimestamp = dateCreated;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const schema = 'aSchema';
                const published = true;
                const write1Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                const write2Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                const write3Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                // sort the messages in lexicographical order against `messageCid`
                const [oldestWrite, middleWrite, newestWrite] = yield ArrayUtility.asyncSort([write1Data, write2Data, write3Data], (messageDataA, messageDataB) => { return Message.compareCid(messageDataA.message, messageDataB.message); });
                // intentionally write the RecordsWrite of out lexicographical order to avoid the test query below accidentally having the correct order
                const reply2 = yield dwn.processMessage(alice.did, middleWrite.message, { dataStream: middleWrite.dataStream });
                expect(reply2.status.code).to.equal(202);
                const reply3 = yield dwn.processMessage(alice.did, newestWrite.message, { dataStream: newestWrite.dataStream });
                expect(reply3.status.code).to.equal(202);
                const reply1 = yield dwn.processMessage(alice.did, oldestWrite.message, { dataStream: oldestWrite.dataStream });
                expect(reply1.status.code).to.equal(202);
                const queryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending
                });
                const queryReply = yield dwn.processMessage(alice.did, queryMessageData.message);
                // verify that messages returned are sorted/tiebreak by `messageCid`
                expect(queryReply.status.code).to.equal(200);
                expect((_76 = queryReply.entries) === null || _76 === void 0 ? void 0 : _76.length).to.equal(3);
                expect((queryReply.entries[0]).recordId).to.equal(oldestWrite.message.recordId);
                expect((queryReply.entries[1]).recordId).to.equal(middleWrite.message.recordId);
                expect((queryReply.entries[2]).recordId).to.equal(newestWrite.message.recordId);
                // sort descending should be reversed
                const queryMessageDescending = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedDescending
                });
                const descendingReply = yield dwn.processMessage(alice.did, queryMessageDescending.message);
                expect((descendingReply.entries[0]).recordId).to.equal(newestWrite.message.recordId);
                expect((descendingReply.entries[1]).recordId).to.equal(middleWrite.message.recordId);
                expect((descendingReply.entries[2]).recordId).to.equal(oldestWrite.message.recordId);
            }));
            it('should paginate all records in ascending order', () => __awaiter(this, void 0, void 0, function* () {
                var _77;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const messages = yield Promise.all(Array(12).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'https://schema'
                })));
                for (const message of messages) {
                    const result = yield dwn.processMessage(alice.did, message.message, { dataStream: message.dataStream });
                    expect(result.status.code).to.equal(202);
                }
                const limit = 5;
                const results = [];
                let cursor;
                while (true) {
                    const pageQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: alice,
                        filter: {
                            schema: 'https://schema'
                        },
                        pagination: {
                            limit: limit,
                            cursor,
                        },
                        dateSort: DateSort.CreatedAscending
                    });
                    const pageReply = yield dwn.processMessage(alice.did, pageQuery.message);
                    expect(pageReply.status.code).to.equal(200);
                    cursor = pageReply.cursor;
                    expect((_77 = pageReply.entries) === null || _77 === void 0 ? void 0 : _77.length).to.be.lte(limit);
                    results.push(...pageReply.entries);
                    if (cursor === undefined) {
                        break;
                    }
                }
                expect(results.length).to.equal(messages.length);
                expect(messages.every(({ message }) => results.map(e => e.recordId).includes(message.recordId)));
            }));
            it('should paginate all records in descending order', () => __awaiter(this, void 0, void 0, function* () {
                var _78;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const messages = yield Promise.all(Array(12).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'https://schema'
                })));
                for (const message of messages) {
                    const result = yield dwn.processMessage(alice.did, message.message, { dataStream: message.dataStream });
                    expect(result.status.code).to.equal(202);
                }
                const limit = 5;
                const results = [];
                let cursor;
                while (true) {
                    const pageQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: alice,
                        filter: {
                            schema: 'https://schema'
                        },
                        pagination: {
                            limit: limit,
                            cursor,
                        },
                        dateSort: DateSort.CreatedDescending,
                    });
                    const pageReply = yield dwn.processMessage(alice.did, pageQuery.message);
                    expect(pageReply.status.code).to.equal(200);
                    cursor = pageReply.cursor;
                    expect((_78 = pageReply.entries) === null || _78 === void 0 ? void 0 : _78.length).to.be.lte(limit);
                    results.push(...pageReply.entries);
                    if (cursor === undefined) {
                        break;
                    }
                }
                expect(results.length).to.equal(messages.length);
                expect(messages.every(({ message }) => results.map(e => e.recordId).includes(message.recordId)));
            }));
            it('should allow an anonymous unauthenticated query to return published records', () => __awaiter(this, void 0, void 0, function* () {
                var _79, _80;
                // write 2 records into Alice's DB:
                // 1st is unpublished
                // 2nd is published
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const record1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'https://schema1', published: false });
                const record2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'https://schema2', published: true });
                const recordsWrite1Reply = yield dwn.processMessage(alice.did, record1Data.message, { dataStream: record1Data.dataStream });
                expect(recordsWrite1Reply.status.code).to.equal(202);
                const recordsWrite2Reply = yield dwn.processMessage(alice.did, record2Data.message, { dataStream: record2Data.dataStream });
                expect(recordsWrite2Reply.status.code).to.equal(202);
                // test correctness for anonymous query
                const anonymousQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    anonymous: true,
                    filter: { dateCreated: { from: '2000-01-01T10:20:30.123456Z' } }
                });
                // sanity check
                expect(anonymousQueryMessageData.message.authorization).to.not.exist;
                const replyToQuery = yield dwn.processMessage(alice.did, anonymousQueryMessageData.message);
                expect(replyToQuery.status.code).to.equal(200);
                expect((_79 = replyToQuery.entries) === null || _79 === void 0 ? void 0 : _79.length).to.equal(1);
                expect(replyToQuery.entries[0].descriptor.schema).to.equal('https://schema2');
                // explicitly for published records
                const anonymousQueryPublished = yield TestDataGenerator.generateRecordsQuery({
                    anonymous: true,
                    filter: { dateCreated: { from: '2000-01-01T10:20:30.123456Z' }, published: true }
                });
                // sanity check
                expect(anonymousQueryPublished.message.authorization).to.not.exist;
                // should return the published records
                const publishedReply = yield dwn.processMessage(alice.did, anonymousQueryPublished.message);
                expect(publishedReply.status.code).to.equal(200);
                expect((_80 = publishedReply.entries) === null || _80 === void 0 ? void 0 : _80.length).to.equal(1);
                expect(publishedReply.entries[0].descriptor.schema).to.equal('https://schema2');
            }));
            it('should only return published records and unpublished records that are meant for specific recipient(s)', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: Alice installs a free-for-all protocol on her DWN
                // She writes both private and public messages for bob and carol, carol and bob also write public and privet messages for alice and each other
                // Bob, Alice and Carol should only be able to see private messages pertaining to themselves, and any public messages filtered by a recipient
                // Bob, Alice and Carol should be able to filter for ONLY public messages or ONLY private messages
                var _81, _82, _83, _84;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                // install the free-for-all protocol on Alice's DWN
                const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition: freeForAll
                });
                const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
                expect(protocolConfigureReply.status.code).to.equal(202);
                // write private records for bob and carol
                const alicePrivateToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const alicePrivateToBobReply = yield dwn.processMessage(alice.did, alicePrivateToBob.message, { dataStream: alicePrivateToBob.dataStream });
                expect(alicePrivateToBobReply.status.code).to.equal(202);
                const alicePrivateToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const alicePrivateToCarolReply = yield dwn.processMessage(alice.did, alicePrivateToCarol.message, {
                    dataStream: alicePrivateToCarol.dataStream
                });
                expect(alicePrivateToCarolReply.status.code).to.equal(202);
                // write private records from carol to alice and bob
                const carolPrivateToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const carolPrivateToAliceReply = yield dwn.processMessage(alice.did, carolPrivateToAlice.message, {
                    dataStream: carolPrivateToAlice.dataStream
                });
                expect(carolPrivateToAliceReply.status.code).to.equal(202);
                const carolPrivateToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const carolPrivateToBobReply = yield dwn.processMessage(alice.did, carolPrivateToBob.message, {
                    dataStream: carolPrivateToBob.dataStream
                });
                expect(carolPrivateToBobReply.status.code).to.equal(202);
                // write private records from bob to alice and carol
                const bobPrivateToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const bobPrivateToAliceReply = yield dwn.processMessage(alice.did, bobPrivateToAlice.message, {
                    dataStream: bobPrivateToAlice.dataStream
                });
                expect(bobPrivateToAliceReply.status.code).to.equal(202);
                const bobPrivateToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const bobPrivateToCarolReply = yield dwn.processMessage(alice.did, bobPrivateToCarol.message, {
                    dataStream: bobPrivateToCarol.dataStream
                });
                expect(bobPrivateToCarolReply.status.code).to.equal(202);
                // write public records from alice to bob and carol
                const alicePublicToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const alicePublicToBobReply = yield dwn.processMessage(alice.did, alicePublicToBob.message, {
                    dataStream: alicePublicToBob.dataStream
                });
                expect(alicePublicToBobReply.status.code).to.equal(202);
                const alicePublicToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const alicePublicToCarolReply = yield dwn.processMessage(alice.did, alicePublicToCarol.message, {
                    dataStream: alicePublicToCarol.dataStream
                });
                expect(alicePublicToCarolReply.status.code).to.equal(202);
                // write public records from bob to alice and carol
                const bobPublicToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const bobPublicToAliceReply = yield dwn.processMessage(alice.did, bobPublicToAlice.message, {
                    dataStream: bobPublicToAlice.dataStream
                });
                expect(bobPublicToAliceReply.status.code).to.equal(202);
                const bobPublicToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const bobPublicToCarolReply = yield dwn.processMessage(alice.did, bobPublicToCarol.message, {
                    dataStream: bobPublicToCarol.dataStream
                });
                expect(bobPublicToCarolReply.status.code).to.equal(202);
                // write public records from carol to alice and bob
                const carolPublicToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const carolPublicToAliceReply = yield dwn.processMessage(alice.did, carolPublicToAlice.message, {
                    dataStream: carolPublicToAlice.dataStream
                });
                expect(carolPublicToAliceReply.status.code).to.equal(202);
                const carolPublicToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const carolPublicToBobReply = yield dwn.processMessage(alice.did, carolPublicToBob.message, {
                    dataStream: carolPublicToBob.dataStream
                });
                expect(carolPublicToBobReply.status.code).to.equal(202);
                // bob queries for records with himself and alice as recipients
                const bobQueryMessagesForBobAlice = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', recipient: [bob.did, alice.did] }
                });
                const bobQueryMessagesForBobAliceReply = yield dwn.processMessage(alice.did, bobQueryMessagesForBobAlice.message);
                expect(bobQueryMessagesForBobAliceReply.status.code).to.equal(200);
                expect((_81 = bobQueryMessagesForBobAliceReply.entries) === null || _81 === void 0 ? void 0 : _81.length).to.equal(7);
                // Since Bob is the author if the query, we expect for him to be able to see:
                // Private Messages THAT ANYONE sent to Bob
                // Private Messages THAT ONLY HE sent to Alice
                // Public Messages THAT ANYONE sent to Alice
                // Public Messages THAT ANYONE sent to Bob
                expect(bobQueryMessagesForBobAliceReply.entries.map(e => e.recordId)).to.have.members([
                    alicePrivateToBob.message.recordId,
                    carolPrivateToBob.message.recordId,
                    bobPrivateToAlice.message.recordId,
                    alicePublicToBob.message.recordId,
                    bobPublicToAlice.message.recordId,
                    carolPublicToAlice.message.recordId,
                    carolPublicToBob.message.recordId,
                ]);
                // carol queries for records with herself as the recipient
                const carolQueryMessagesForCarolAlice = yield TestDataGenerator.generateRecordsQuery({
                    author: carol,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', recipient: carol.did }
                });
                const carolQueryMessagesForCarolAliceReply = yield dwn.processMessage(alice.did, carolQueryMessagesForCarolAlice.message);
                expect(carolQueryMessagesForCarolAliceReply.status.code).to.equal(200);
                expect((_82 = carolQueryMessagesForCarolAliceReply.entries) === null || _82 === void 0 ? void 0 : _82.length).to.equal(4);
                // Since Carol is the author if the query, we expect for her to be able to see:
                // Private Messages THAT ANYONE sent to Carol
                // Private Messages THAT ONLY SHE sent to Alice
                // Public Messages THAT ANYONE sent to Alice
                // Public Messages THAT ANYONE sent to Carol
                expect(carolQueryMessagesForCarolAliceReply.entries.map(e => e.recordId)).to.have.members([
                    alicePrivateToCarol.message.recordId,
                    bobPrivateToCarol.message.recordId,
                    alicePublicToCarol.message.recordId,
                    bobPublicToCarol.message.recordId,
                ]);
                // alice queries for ONLY published records with herself and bob as recipients
                const aliceQueryPublished = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', recipient: [alice.did, bob.did], published: true }
                });
                const aliceQueryPublishedReply = yield dwn.processMessage(alice.did, aliceQueryPublished.message);
                expect(aliceQueryPublishedReply.status.code).to.equal(200);
                expect((_83 = aliceQueryPublishedReply.entries) === null || _83 === void 0 ? void 0 : _83.length).to.equal(4);
                expect(aliceQueryPublishedReply.entries.map(e => e.recordId)).to.have.members([
                    alicePublicToBob.message.recordId,
                    carolPublicToBob.message.recordId,
                    bobPublicToAlice.message.recordId,
                    carolPublicToAlice.message.recordId,
                ]);
                // carol queries for ONLY private records with herself and alice as the recipients
                const carolQueryPrivate = yield TestDataGenerator.generateRecordsQuery({
                    author: carol,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', recipient: [carol.did, alice.did], published: false }
                });
                const carolQueryPrivateReply = yield dwn.processMessage(alice.did, carolQueryPrivate.message);
                expect(carolQueryPrivateReply.status.code).to.equal(200);
                expect((_84 = carolQueryPrivateReply.entries) === null || _84 === void 0 ? void 0 : _84.length).to.equal(3);
                // Carol can query for private messages she authored to alice, and her own private messages with herself as the recipient
                expect(carolQueryPrivateReply.entries.map(e => e.recordId)).to.have.members([
                    alicePrivateToCarol.message.recordId,
                    bobPrivateToCarol.message.recordId,
                    carolPrivateToAlice.message.recordId,
                ]);
            }));
            it('should only return published records and unpublished records that are authored by specific author(s)', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: Alice installs a free-for-all protocol on her DWN
                // She writes both private and public messages for bob and carol, carol and bob also write public and privet messages for alice and each other
                // Bob, Alice and Carol should only be able to see private messages pertaining to themselves, and any public messages filtered by an author
                // Bob, Alice and Carol should be able to filter for ONLY public messages or ONLY private messages
                var _85, _86, _87, _88;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                // install the free-for-all protocol on Alice's DWN
                const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition: freeForAll
                });
                const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
                expect(protocolConfigureReply.status.code).to.equal(202);
                // write private records for bob and carol
                const alicePrivateToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const alicePrivateToBobReply = yield dwn.processMessage(alice.did, alicePrivateToBob.message, { dataStream: alicePrivateToBob.dataStream });
                expect(alicePrivateToBobReply.status.code).to.equal(202);
                const alicePrivateToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const alicePrivateToCarolReply = yield dwn.processMessage(alice.did, alicePrivateToCarol.message, {
                    dataStream: alicePrivateToCarol.dataStream
                });
                expect(alicePrivateToCarolReply.status.code).to.equal(202);
                // write private records from carol to alice and bob
                const carolPrivateToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const carolPrivateToAliceReply = yield dwn.processMessage(alice.did, carolPrivateToAlice.message, {
                    dataStream: carolPrivateToAlice.dataStream
                });
                expect(carolPrivateToAliceReply.status.code).to.equal(202);
                const carolPrivateToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const carolPrivateToBobReply = yield dwn.processMessage(alice.did, carolPrivateToBob.message, {
                    dataStream: carolPrivateToBob.dataStream
                });
                expect(carolPrivateToBobReply.status.code).to.equal(202);
                // write private records from bob to alice and carol
                const bobPrivateToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const bobPrivateToAliceReply = yield dwn.processMessage(alice.did, bobPrivateToAlice.message, {
                    dataStream: bobPrivateToAlice.dataStream
                });
                expect(bobPrivateToAliceReply.status.code).to.equal(202);
                const bobPrivateToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                });
                const bobPrivateToCarolReply = yield dwn.processMessage(alice.did, bobPrivateToCarol.message, {
                    dataStream: bobPrivateToCarol.dataStream
                });
                expect(bobPrivateToCarolReply.status.code).to.equal(202);
                // write public records from alice to bob and carol
                const alicePublicToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const alicePublicToBobReply = yield dwn.processMessage(alice.did, alicePublicToBob.message, {
                    dataStream: alicePublicToBob.dataStream
                });
                expect(alicePublicToBobReply.status.code).to.equal(202);
                const alicePublicToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const alicePublicToCarolReply = yield dwn.processMessage(alice.did, alicePublicToCarol.message, {
                    dataStream: alicePublicToCarol.dataStream
                });
                expect(alicePublicToCarolReply.status.code).to.equal(202);
                // write public records from bob to alice and carol
                const bobPublicToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const bobPublicToAliceReply = yield dwn.processMessage(alice.did, bobPublicToAlice.message, {
                    dataStream: bobPublicToAlice.dataStream
                });
                expect(bobPublicToAliceReply.status.code).to.equal(202);
                const bobPublicToCarol = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: carol.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const bobPublicToCarolReply = yield dwn.processMessage(alice.did, bobPublicToCarol.message, {
                    dataStream: bobPublicToCarol.dataStream
                });
                expect(bobPublicToCarolReply.status.code).to.equal(202);
                // write public records from carol to alice and bob
                const carolPublicToAlice = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: alice.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const carolPublicToAliceReply = yield dwn.processMessage(alice.did, carolPublicToAlice.message, {
                    dataStream: carolPublicToAlice.dataStream
                });
                expect(carolPublicToAliceReply.status.code).to.equal(202);
                const carolPublicToBob = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: bob.did,
                    protocol: freeForAll.protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                    published: true
                });
                const carolPublicToBobReply = yield dwn.processMessage(alice.did, carolPublicToBob.message, {
                    dataStream: carolPublicToBob.dataStream
                });
                expect(carolPublicToBobReply.status.code).to.equal(202);
                // bob queries for records with himself and alice as authors
                const bobQueryMessagesForBobAlice = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', author: [bob.did, alice.did] }
                });
                const bobQueryMessagesForBobAliceReply = yield dwn.processMessage(alice.did, bobQueryMessagesForBobAlice.message);
                expect(bobQueryMessagesForBobAliceReply.status.code).to.equal(200);
                expect((_85 = bobQueryMessagesForBobAliceReply.entries) === null || _85 === void 0 ? void 0 : _85.length).to.equal(7);
                // Since Bob is the author if the query, we expect for him to be able to see:
                // Private Messages Bob authored TO ANYONE
                // Private Messages Alice authored To Bob
                // Public Messages Alice authored
                // Public Messages Bob authored
                expect(bobQueryMessagesForBobAliceReply.entries.map(e => e.recordId)).to.have.members([
                    alicePrivateToBob.message.recordId,
                    bobPrivateToAlice.message.recordId,
                    bobPrivateToCarol.message.recordId,
                    alicePublicToBob.message.recordId,
                    alicePublicToCarol.message.recordId,
                    bobPublicToAlice.message.recordId,
                    bobPublicToCarol.message.recordId
                ]);
                // carol queries for records with herself as the author
                const carolQueryMessagesForCarolAlice = yield TestDataGenerator.generateRecordsQuery({
                    author: carol,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', author: carol.did }
                });
                const carolQueryMessagesForCarolAliceReply = yield dwn.processMessage(alice.did, carolQueryMessagesForCarolAlice.message);
                expect(carolQueryMessagesForCarolAliceReply.status.code).to.equal(200);
                expect((_86 = carolQueryMessagesForCarolAliceReply.entries) === null || _86 === void 0 ? void 0 : _86.length).to.equal(4);
                // Since Carol is the author if the query, we expect for her to be able to see:
                // All messages that Carol sent to anyone, private or public
                expect(carolQueryMessagesForCarolAliceReply.entries.map(e => e.recordId)).to.have.members([
                    carolPrivateToAlice.message.recordId,
                    carolPrivateToBob.message.recordId,
                    carolPublicToAlice.message.recordId,
                    carolPublicToBob.message.recordId
                ]);
                // alice queries for ONLY published records with herself and bob as authors
                const aliceQueryPublished = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', author: [alice.did, bob.did], published: true }
                });
                const aliceQueryPublishedReply = yield dwn.processMessage(alice.did, aliceQueryPublished.message);
                expect(aliceQueryPublishedReply.status.code).to.equal(200);
                expect((_87 = aliceQueryPublishedReply.entries) === null || _87 === void 0 ? void 0 : _87.length).to.equal(4);
                expect(aliceQueryPublishedReply.entries.map(e => e.recordId)).to.have.members([
                    alicePublicToBob.message.recordId,
                    alicePublicToCarol.message.recordId,
                    bobPublicToAlice.message.recordId,
                    bobPublicToCarol.message.recordId
                ]);
                // carol queries for ONLY private records with herself and alice as the authors
                const carolQueryPrivate = yield TestDataGenerator.generateRecordsQuery({
                    author: carol,
                    filter: { protocol: freeForAll.protocol, protocolPath: 'post', author: [carol.did, alice.did], published: false }
                });
                const carolQueryPrivateReply = yield dwn.processMessage(alice.did, carolQueryPrivate.message);
                expect(carolQueryPrivateReply.status.code).to.equal(200);
                expect((_88 = carolQueryPrivateReply.entries) === null || _88 === void 0 ? void 0 : _88.length).to.equal(3);
                expect(carolQueryPrivateReply.entries.map(e => e.recordId)).to.have.members([
                    alicePrivateToCarol.message.recordId,
                    carolPrivateToAlice.message.recordId,
                    carolPrivateToBob.message.recordId
                ]);
            }));
            it('should paginate correctly for fetchRecordsAsNonOwner()', () => __awaiter(this, void 0, void 0, function* () {
                var _89, e_1, _90, _91;
                var _92, _93, _94, _95, _96;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const schema = 'schema1';
                // published messages bob
                const bobPublishedPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: bob, schema, data: TestDataGenerator.randomBytes(10), published: true,
                }));
                // published messages alice
                const alicePublishedPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10), published: true,
                }));
                // alice non public messages
                const aliceMessagesPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10)
                }));
                // bob non public messages
                const bobMessagesPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: bob, schema, data: TestDataGenerator.randomBytes(10)
                }));
                // non public messages intended for bob
                const aliceMessagesForBobPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10), recipient: bob.did,
                }));
                const messagePromises = [
                    ...bobPublishedPromise,
                    ...aliceMessagesPromise,
                    ...bobMessagesPromise,
                    ...alicePublishedPromise,
                    ...aliceMessagesForBobPromise,
                ];
                const recordsWriteHandler = new RecordsWriteHandler(didResolver, messageStore, dataStore, eventLog, eventStream);
                const messages = [];
                try {
                    for (var _97 = true, messagePromises_1 = __asyncValues(messagePromises), messagePromises_1_1; messagePromises_1_1 = yield messagePromises_1.next(), _89 = messagePromises_1_1.done, !_89; _97 = true) {
                        _91 = messagePromises_1_1.value;
                        _97 = false;
                        const { recordsWrite, message, dataBytes } = _91;
                        const indexes = yield recordsWrite.constructIndexes(true);
                        const processedMessage = yield recordsWriteHandler.cloneAndAddEncodedData(message, dataBytes);
                        yield messageStore.put(alice.did, processedMessage, indexes);
                        yield eventLog.append(alice.did, yield Message.getCid(processedMessage), indexes);
                        messages.push(processedMessage);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_97 && !_89 && (_90 = messagePromises_1.return)) yield _90.call(messagePromises_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                const sortedMessages = yield ArrayUtility.asyncSort(messages, (a, b) => __awaiter(this, void 0, void 0, function* () { return Message.compareMessageTimestamp(a, b); }));
                const aliceRetrieved = [];
                // fetch all from alice for sanity, alice should get all of the records
                // page1 alice
                const aliceQueryMessageDataPage1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10 },
                });
                let results = yield dwn.processMessage(alice.did, aliceQueryMessageDataPage1.message);
                expect(results.status.code).to.equal(200);
                expect((_92 = results.entries) === null || _92 === void 0 ? void 0 : _92.length).to.equal(10, 'alice page 1');
                expect(results.cursor, 'alice page 1 cursor').to.not.be.undefined;
                aliceRetrieved.push(...results.entries);
                // page2 alice
                const aliceQueryMessageDataPage2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, cursor: results.cursor },
                });
                results = yield dwn.processMessage(alice.did, aliceQueryMessageDataPage2.message);
                expect(results.status.code).to.equal(200);
                expect((_93 = results.entries) === null || _93 === void 0 ? void 0 : _93.length).to.equal(10, 'alice page 2');
                expect(results.cursor, 'alice page 2 cursor').to.not.be.undefined;
                aliceRetrieved.push(...results.entries);
                // page3 alice
                const aliceQueryMessageDataPage3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, cursor: results.cursor },
                });
                results = yield dwn.processMessage(alice.did, aliceQueryMessageDataPage3.message);
                expect(results.status.code).to.equal(200);
                expect((_94 = results.entries) === null || _94 === void 0 ? void 0 : _94.length).to.equal(5, 'alice page 3');
                expect(results.cursor, 'alice page 3 cursor').to.not.exist;
                aliceRetrieved.push(...results.entries);
                const compareRecordId = (a, b) => {
                    return a.recordId === b.recordId;
                };
                expect(sortedMessages.every((m, i) => compareRecordId(aliceRetrieved.at(i), m)));
                const bobs = (m) => {
                    return m.descriptor.recipient === bob.did || m.descriptor.published === true || Message.getSigner(m) === bob.did;
                };
                // all records from alice have been validated
                // now we prepare to test records that only bob should get
                const bobSorted = sortedMessages.filter(m => bobs(m));
                const bobRetrieved = [];
                const bobQueryMessagePage1 = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10 },
                });
                results = yield dwn.processMessage(alice.did, bobQueryMessagePage1.message);
                expect(results.status.code).to.equal(200);
                expect((_95 = results.entries) === null || _95 === void 0 ? void 0 : _95.length).to.equal(10, 'bob page 1');
                expect(results.cursor, 'bob page 1 cursor').to.not.be.undefined;
                bobRetrieved.push(...results.entries);
                const bobQueryMessagePage2 = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, cursor: results.cursor },
                });
                results = yield dwn.processMessage(alice.did, bobQueryMessagePage2.message);
                expect(results.status.code).to.equal(200);
                expect((_96 = results.entries) === null || _96 === void 0 ? void 0 : _96.length).to.equal(10, 'bob page 2');
                expect(results.cursor, 'bob page 2 cursor').to.not.exist;
                bobRetrieved.push(...results.entries);
                expect(bobSorted.every((m, i) => compareRecordId(bobRetrieved.at(i), m)));
            }));
            // https://github.com/TBD54566975/dwn-sdk-js/issues/170
            it('#170 - should treat records with `published` explicitly set to `false` as unpublished', () => __awaiter(this, void 0, void 0, function* () {
                var _98, _99;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const schema = 'schema1';
                const unpublishedRecordsWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('1'), published: false } // explicitly setting `published` to `false`
                );
                const result1 = yield dwn.processMessage(alice.did, unpublishedRecordsWrite.message, { dataStream: unpublishedRecordsWrite.dataStream });
                expect(result1.status.code).to.equal(202);
                // alice should be able to see the unpublished record
                const queryByAlice = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                const replyToAliceQuery = yield dwn.processMessage(alice.did, queryByAlice.message);
                expect(replyToAliceQuery.status.code).to.equal(200);
                expect((_98 = replyToAliceQuery.entries) === null || _98 === void 0 ? void 0 : _98.length).to.equal(1);
                // actual test: bob should not be able to see unpublished record
                const queryByBob = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema }
                });
                const replyToBobQuery = yield dwn.processMessage(alice.did, queryByBob.message);
                expect(replyToBobQuery.status.code).to.equal(200);
                expect((_99 = replyToBobQuery.entries) === null || _99 === void 0 ? void 0 : _99.length).to.equal(0);
            }));
            it('should allow DWN owner to use `recipient` as a filter in queries', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const bobQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { recipient: bob.did } // alice as the DWN owner querying bob's records
                });
                const replyToBobQuery = yield dwn.processMessage(alice.did, bobQueryMessageData.message);
                expect(replyToBobQuery.status.code).to.equal(200);
            }));
            it('should not fetch entries across tenants', () => __awaiter(this, void 0, void 0, function* () {
                var _100;
                // insert three messages into DB, two with matching schema
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const schema = 'myAwesomeSchema';
                const recordsWriteMessage1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema });
                const recordsWriteMessage2Data = yield TestDataGenerator.generateRecordsWrite({ author: bob, schema });
                const aliceQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                // insert data into 2 different tenants
                yield dwn.processMessage(alice.did, recordsWriteMessage1Data.message, { dataStream: recordsWriteMessage1Data.dataStream });
                yield dwn.processMessage(bob.did, recordsWriteMessage2Data.message, { dataStream: recordsWriteMessage2Data.dataStream });
                const reply = yield dwn.processMessage(alice.did, aliceQueryMessageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_100 = reply.entries) === null || _100 === void 0 ? void 0 : _100.length).to.equal(1);
            }));
            it('should return 400 if protocol is not normalized', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // query for non-normalized protocol
                const recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { protocol: 'example.com/' },
                });
                // overwrite protocol because #create auto-normalizes protocol
                recordsQuery.message.descriptor.filter.protocol = 'example.com/';
                // Re-create auth because we altered the descriptor after signing
                recordsQuery.message.authorization = yield Message.createAuthorization({
                    descriptor: recordsQuery.message.descriptor,
                    signer: Jws.createSigner(alice)
                });
                // Send records write message
                const reply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(DwnErrorCode.UrlProtocolNotNormalized);
            }));
            it('should return 400 if schema is not normalized', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // query for non-normalized schema
                const recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: 'example.com/' },
                });
                // overwrite schema because #create auto-normalizes schema
                recordsQuery.message.descriptor.filter.schema = 'example.com/';
                // Re-create auth because we altered the descriptor after signing
                recordsQuery.message.authorization = yield Message.createAuthorization({
                    descriptor: recordsQuery.message.descriptor,
                    signer: Jws.createSigner(alice)
                });
                // Send records write message
                const reply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(DwnErrorCode.UrlSchemaNotNormalized);
            }));
            it('should return 400 if published is set to false and a datePublished range is provided', () => __awaiter(this, void 0, void 0, function* () {
                const fromDatePublished = Time.getCurrentTimestamp();
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // set to true so create does not fail
                const recordQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: fromDatePublished }, published: true }
                });
                // set to false
                recordQuery.message.descriptor.filter.published = false;
                const queryResponse = yield dwn.processMessage(alice.did, recordQuery.message);
                expect(queryResponse.status.code).to.equal(400);
                expect(queryResponse.status.detail).to.contain('descriptor/filter/published: must be equal to one of the allowed values');
            }));
            it('should return 401 for anonymous queries that filter explicitly for unpublished records', () => __awaiter(this, void 0, void 0, function* () {
                var _101;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, { dataStream: draftWrite.dataStream });
                expect(draftWriteReply.status.code).to.equal(202);
                // validate that alice can query
                const unpublishedPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { schema: 'post', published: false } });
                const unpublishedPostReply = yield dwn.processMessage(alice.did, unpublishedPostQuery.message);
                expect(unpublishedPostReply.status.code).to.equal(200);
                expect((_101 = unpublishedPostReply.entries) === null || _101 === void 0 ? void 0 : _101.length).to.equal(1);
                expect(unpublishedPostReply.entries[0].recordId).to.equal(draftWrite.message.recordId);
                // anonymous query for unpublished records
                const unpublishedAnonymous = yield RecordsQuery.create({ filter: { schema: 'post', published: false } });
                const anonymousPostReply = yield dwn.processMessage(alice.did, unpublishedAnonymous.message);
                expect(anonymousPostReply.status.code).to.equal(401);
                expect(anonymousPostReply.status.detail).contains('Missing JWS');
            }));
            describe('protocol based queries', () => {
                it('should return message scoped to the given `contextId`', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario:
                    // 0. Alice installs a nested protocol foo -> bar -> baz
                    // 1. Alice writes 2 foos, 2 bars under foo1, and 2 bazes under bar1
                    // 2. Alice should be able to query for all messages under foo1
                    // 3. Alice should be able to query for all messages under bar1
                    // 4. Alice should be able to query for all messages under baz1
                    var _a, _b, _c;
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = nestedProtocol;
                    // 0. Alice installs a nested protocol foo -> bar -> baz
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // 1. Alice writes 2 foos, 2 bars under foo1, and 2 bazes under bar1
                    // write 2 foos
                    const fooOptions = {
                        author: alice,
                        protocol: nestedProtocol.protocol,
                        protocolPath: 'foo',
                        schema: nestedProtocol.types.foo.schema,
                        dataFormat: nestedProtocol.types.foo.dataFormats[0],
                    };
                    const foo1 = yield TestDataGenerator.generateRecordsWrite(fooOptions);
                    const foo1WriteResponse = yield dwn.processMessage(alice.did, foo1.message, { dataStream: foo1.dataStream });
                    expect(foo1WriteResponse.status.code).equals(202);
                    const foo2 = yield TestDataGenerator.generateRecordsWrite(fooOptions);
                    const foo2WriteResponse = yield dwn.processMessage(alice.did, foo2.message, { dataStream: foo2.dataStream });
                    expect(foo2WriteResponse.status.code).equals(202);
                    // write 2 bars under foo1
                    const barOptions = {
                        author: alice,
                        protocol: nestedProtocol.protocol,
                        protocolPath: 'foo/bar',
                        schema: nestedProtocol.types.bar.schema,
                        dataFormat: nestedProtocol.types.bar.dataFormats[0],
                        parentContextId: foo1.message.contextId
                    };
                    const bar1 = yield TestDataGenerator.generateRecordsWrite(barOptions);
                    const bar1WriteResponse = yield dwn.processMessage(alice.did, bar1.message, { dataStream: bar1.dataStream });
                    expect(bar1WriteResponse.status.code).equals(202);
                    const bar2 = yield TestDataGenerator.generateRecordsWrite(barOptions);
                    const bar2WriteResponse = yield dwn.processMessage(alice.did, bar2.message, { dataStream: bar2.dataStream });
                    expect(bar2WriteResponse.status.code).equals(202);
                    // write 2 bazes under bar1
                    const bazOptions = {
                        author: alice,
                        protocol: nestedProtocol.protocol,
                        protocolPath: 'foo/bar/baz',
                        schema: nestedProtocol.types.baz.schema,
                        dataFormat: nestedProtocol.types.baz.dataFormats[0],
                        parentContextId: bar1.message.contextId
                    };
                    const baz1 = yield TestDataGenerator.generateRecordsWrite(bazOptions);
                    const baz1WriteResponse = yield dwn.processMessage(alice.did, baz1.message, { dataStream: baz1.dataStream });
                    expect(baz1WriteResponse.status.code).equals(202);
                    const baz2 = yield TestDataGenerator.generateRecordsWrite(bazOptions);
                    const baz2WriteResponse = yield dwn.processMessage(alice.did, baz2.message, { dataStream: baz2.dataStream });
                    expect(baz2WriteResponse.status.code).equals(202);
                    // 2. Alice should be able to query for all messages under foo1
                    const foo1ContextIdQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: alice,
                        filter: { contextId: foo1.message.contextId }
                    });
                    const foo1ContextIdQueryReply = yield dwn.processMessage(alice.did, foo1ContextIdQuery.message);
                    expect(foo1ContextIdQueryReply.status.code).to.equal(200);
                    expect((_a = foo1ContextIdQueryReply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(5);
                    expect(foo1ContextIdQueryReply.entries.map((entry) => entry.recordId)).to.include.members([
                        foo1.message.recordId,
                        bar1.message.recordId,
                        bar2.message.recordId,
                        baz1.message.recordId,
                        baz2.message.recordId
                    ]);
                    // 3. Alice should be able to query for all messages under bar1
                    const bar1ContextIdQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: alice,
                        filter: { contextId: bar1.message.contextId }
                    });
                    const bar1ContextIdQueryReply = yield dwn.processMessage(alice.did, bar1ContextIdQuery.message);
                    expect(bar1ContextIdQueryReply.status.code).to.equal(200);
                    expect((_b = bar1ContextIdQueryReply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(3);
                    expect(bar1ContextIdQueryReply.entries.map((entry) => entry.recordId)).to.include.members([
                        bar1.message.recordId,
                        baz1.message.recordId,
                        baz2.message.recordId
                    ]);
                    // 4. Alice should be able to query for all messages under baz1
                    const baz1ContextIdQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: alice,
                        filter: { contextId: baz1.message.contextId }
                    });
                    const baz1ContextIdQueryReply = yield dwn.processMessage(alice.did, baz1ContextIdQuery.message);
                    expect(baz1ContextIdQueryReply.status.code).to.equal(200);
                    expect((_c = baz1ContextIdQueryReply.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(1);
                    expect(baz1ContextIdQueryReply.entries.map((entry) => entry.recordId)).to.include.members([baz1.message.recordId]);
                }));
                it('does not try protocol authorization if protocolRole is not invoked', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice creates a thread and writes some chat messages. Alice addresses
                    //           only one chat message to Bob. Bob queries by protocol URI without invoking a protocolRole,
                    //           and he is able to receive the message addressed to him.
                    var _d, _e;
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const bob = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, { dataStream: threadRecord.dataStream });
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes one 'chat' record addressed to Bob
                    const chatRecordForBob = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread/chat',
                        published: false,
                        parentContextId: threadRecord.message.contextId,
                        data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                    });
                    const chatRecordForBobReply = yield dwn.processMessage(alice.did, chatRecordForBob.message, { dataStream: chatRecordForBob.dataStream });
                    expect(chatRecordForBobReply.status.code).to.equal(202);
                    // Alice writes two 'chat' records NOT addressed to Bob
                    for (let i = 0; i < 2; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            parentContextId: threadRecord.message.contextId,
                            data: new TextEncoder().encode('Bob cannot read this'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, { dataStream: chatRecord.dataStream });
                        expect(chatReply.status.code).to.equal(202);
                    }
                    // Bob queries without invoking any protocolRole
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                        },
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(200);
                    expect((_d = chatQueryReply.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(1);
                    expect(chatQueryReply.entries[0].recordId).to.eq(chatRecordForBob.message.recordId);
                    // bob queries without invoking any protocolRole and filters for unpublished records
                    const unpublishedChatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            published: false,
                            protocol: protocolDefinition.protocol,
                        },
                    });
                    const unpublishedChatReply = yield dwn.processMessage(alice.did, unpublishedChatQuery.message);
                    expect(unpublishedChatReply.status.code).to.equal(200);
                    expect((_e = unpublishedChatReply.entries) === null || _e === void 0 ? void 0 : _e.length).to.equal(1);
                    expect(unpublishedChatReply.entries[0].recordId).to.equal(chatRecordForBob.message.recordId);
                }));
                it('allows root-level role authorized queries', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice creates a thread and writes some chat messages writes a chat message. Bob invokes his
                    //           thread member role in order to query the chat messages.
                    var _f, _g;
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const bob = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = friendRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'friend' root-level role record with Bob as recipient
                    const friendRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'friend',
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const friendRoleReply = yield dwn.processMessage(alice.did, friendRoleRecord.message, { dataStream: friendRoleRecord.dataStream });
                    expect(friendRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                            published: false,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, { dataStream: chatRecord.dataStream });
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                        },
                        protocolRole: 'friend',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(200);
                    expect((_f = chatQueryReply.entries) === null || _f === void 0 ? void 0 : _f.length).to.equal(3);
                    expect(chatQueryReply.entries.map((record) => record.recordId)).to.have.all.members(chatRecordIds);
                    // Bob invokes his friendRole along with an explicit filter for unpublished records
                    const unpublishedChatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            published: false,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                        },
                        protocolRole: 'friend',
                    });
                    const unpublishedChatReply = yield dwn.processMessage(alice.did, unpublishedChatQuery.message);
                    expect(unpublishedChatReply.status.code).to.equal(200);
                    expect((_g = unpublishedChatReply.entries) === null || _g === void 0 ? void 0 : _g.length).to.equal(3);
                    expect(unpublishedChatReply.entries.map((record) => record.recordId)).to.have.all.members(chatRecordIds);
                }));
                it('can authorize queries using a context role.', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes some chat messages. Bob invokes his friend role in order to query the chat messages.
                    var _h;
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const bob = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, { dataStream: threadRecord.dataStream });
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes a 'participant' role record with Bob as recipient
                    const participantRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread/participant',
                        parentContextId: threadRecord.message.contextId,
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const participantRoleReply = yield dwn.processMessage(alice.did, participantRoleRecord.message, { dataStream: participantRoleRecord.dataStream });
                    expect(participantRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            parentContextId: threadRecord.message.contextId,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, { dataStream: chatRecord.dataStream });
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            contextId: threadRecord.message.contextId,
                        },
                        protocolRole: 'thread/participant',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(200);
                    expect((_h = chatQueryReply.entries) === null || _h === void 0 ? void 0 : _h.length).to.equal(3);
                    expect(chatQueryReply.entries.map((record) => record.recordId)).to.have.all.members(chatRecordIds);
                }));
                it('does not execute protocol queries where protocolPath is missing from the filter', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice gives Bob a root-level role and writes some chat messages. Bob invokes his root-level role to query those messages,
                    //           but his query filter does not include protocolPath.
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const bob = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = friendRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'friend' root-level role record with Bob as recipient
                    const friendRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'friend',
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const friendRoleReply = yield dwn.processMessage(alice.did, friendRoleRecord.message, { dataStream: friendRoleRecord.dataStream });
                    expect(friendRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                            published: false,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, { dataStream: chatRecord.dataStream });
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query but does not have `protocolPath` in the filter
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            // protocolPath deliberately omitted
                        },
                        protocolRole: 'friend',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(400);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.RecordsQueryFilterMissingRequiredProperties);
                }));
                it('does not execute context role authorized queries where contextId is missing from the filter', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes some chat messages and gives Bob a role allowing him to access them. But Bob's filter
                    //           does not contain a contextId so the query fails.
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const bob = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, { dataStream: threadRecord.dataStream });
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes a 'friend' root-level role record with Bob as recipient
                    const participantRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread/participant',
                        parentContextId: threadRecord.message.contextId,
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const participantRoleReply = yield dwn.processMessage(alice.did, participantRoleRecord.message, { dataStream: participantRoleRecord.dataStream });
                    expect(participantRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            parentContextId: threadRecord.message.contextId,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, { dataStream: chatRecord.dataStream });
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his thread participant role to query
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            // contextId deliberately omitted
                        },
                        protocolRole: 'thread/participant',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.eq(401);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationMissingContextId);
                }));
                it('should reject root-level role authorized queries if a matching root-level role record is not found for the message author', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice creates a thread and writes some chat messages writes a chat message.
                    //           Bob invokes a root-level role but fails because he does not actually have a role.
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const bob = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = friendRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                            published: false,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, { dataStream: chatRecord.dataStream });
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                        },
                        protocolRole: 'friend',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.eq(401);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationMatchingRoleRecordNotFound);
                }));
                it('should reject context role authorized queries if a matching context role record is not found for the message author', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield TestDataGenerator.generateDidKeyPersona();
                    const bob = yield TestDataGenerator.generateDidKeyPersona();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, { dataStream: threadRecord.dataStream });
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            parentContextId: threadRecord.message.contextId,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, { dataStream: chatRecord.dataStream });
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            contextId: threadRecord.message.contextId,
                        },
                        protocolRole: 'thread/participant',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.eq(401);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationMatchingRoleRecordNotFound);
                }));
            });
        });
        it('should return 401 if signature check fails', () => __awaiter(this, void 0, void 0, function* () {
            const { author, message } = yield TestDataGenerator.generateRecordsQuery();
            const tenant = author.did;
            // setting up a stub did resolver & message store
            // intentionally not supplying the public key so a different public key is generated to simulate invalid signature
            const mismatchingPersona = yield TestDataGenerator.generatePersona({ did: author.did, keyId: author.keyId });
            const didResolver = TestStubGenerator.createDidResolverStub(mismatchingPersona);
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsQueryHandler = new RecordsQueryHandler(didResolver, messageStore, dataStore);
            const reply = yield recordsQueryHandler.handle({ tenant, message });
            expect(reply.status.code).to.equal(401);
        }));
        it('should return 400 if fail parsing the message', () => __awaiter(this, void 0, void 0, function* () {
            const { author, message } = yield TestDataGenerator.generateRecordsQuery();
            const tenant = author.did;
            // setting up a stub method resolver & message store
            const didResolver = TestStubGenerator.createDidResolverStub(author);
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsQueryHandler = new RecordsQueryHandler(didResolver, messageStore, dataStore);
            // stub the `parse()` function to throw an error
            sinon.stub(RecordsQuery, 'parse').throws('anyError');
            const reply = yield recordsQueryHandler.handle({ tenant, message });
            expect(reply.status.code).to.equal(400);
        }));
    });
}
//# sourceMappingURL=records-query.spec.js.map